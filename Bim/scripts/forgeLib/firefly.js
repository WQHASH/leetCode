
(function() {

function getGlobal() {
    return (typeof window !== "undefined" && window !== null)
            ? window
            : (typeof self !== "undefined" && self !== null)
                ? self
                : global;
}

/**
 * Create namespace
 * @param {string} s - namespace (e.g. 'Autodesk.Viewing')
 * @return {Object} namespace
 */
function AutodeskNamespace(s) {
    var ns = getGlobal();

    var parts = s.split('.');
    for (var i = 0; i < parts.length; ++i) {
        ns[parts[i]] = ns[parts[i]] || {};
        ns = ns[parts[i]];
    }

    return ns;
};

// Define the most often used ones
AutodeskNamespace("Autodesk.Viewing.Private");

AutodeskNamespace("Autodesk.Viewing.Extensions");

AutodeskNamespace("Autodesk.Viewing.Shaders");

AutodeskNamespace('Autodesk.Viewing.UI');

AutodeskNamespace('Autodesk.LMVTK');

Autodesk.Viewing.getGlobal = getGlobal;
Autodesk.Viewing.AutodeskNamespace = AutodeskNamespace;
getGlobal().AutodeskNamespace = AutodeskNamespace;

})();
// Map wgs.js symbols back to Autodesk namespaces for backwards compatibility.
// If the worker parameter is true, only worker-specific symbols are mapped.
Autodesk.Viewing.Private.initializeLegacyNamespaces = function(worker) {
    var av = Autodesk.Viewing;
    var avs = av.Shaders;
    var avp = av.Private;
    var lmv = av.LMVTK;

    av.ErrorCodes = WGS.ErrorCodes;
    av.errorCodeString = WGS.errorCodeString;

    avp.InstanceTreeStorage = WGS.InstanceTreeStorage;
	avp.InstanceTreeAccess = WGS.InstanceTreeAccess;
    avp.BVHBuilder = WGS.BVHBuilder;
    avp.NodeArray = WGS.NodeArray;

    avp.ViewingService = WGS.ViewingService;
    WGS.ViewingService.setEndpoint(av.endpoint);
    if (avp.logger)
        WGS.setLogger(avp.logger);

    if (worker)
        return;

    av.FileLoaderManager.registerFileLoader("svf", ["svf", "gltf", "glb"], WGS.SvfLoader);
    av.LOAD_MISSING_GEOMETRY = WGS.LOAD_MISSING_GEOMETRY;
    av.MODEL_ROOT_LOADED_EVENT = WGS.MODEL_ROOT_LOADED_EVENT;
    av.FRAGMENTS_LOADED_EVENT = WGS.FRAGMENTS_LOADED_EVENT;
    av.OBJECT_TREE_CREATED_EVENT = WGS.OBJECT_TREE_CREATED_EVENT;
    av.OBJECT_TREE_UNAVAILABLE_EVENT = WGS.OBJECT_TREE_UNAVAILABLE_EVENT;
    av.TEXTURES_LOADED_EVENT = WGS.TEXTURES_LOADED_EVENT;

    avs.PackDepthShaderChunk = WGS.PackDepthShaderChunk;
    avs.TonemapShaderChunk = WGS.TonemapShaderChunk;
    avs.OrderedDitheringShaderChunk = WGS.OrderedDitheringShaderChunk;
    avs.CutPlanesUniforms = WGS.CutPlanesUniforms;
    avs.CutPlanesShaderChunk = WGS.CutPlanesShaderChunk;
    avs.PackNormalsShaderChunk = WGS.PackNormalsShaderChunk;
    avs.HatchPatternShaderChunk = WGS.HatchPatternShaderChunk;
    avs.EnvSamplingShaderChunk = WGS.EnvSamplingShaderChunk;
    avs.IdUniforms = WGS.IdUniforms;
    avs.IdFragmentDeclaration = WGS.IdFragmentDeclaration;
    avs.IdOutputShaderChunk = WGS.IdOutputShaderChunk;
    avs.FinalOutputShaderChunk = WGS.FinalOutputShaderChunk;
    avs.ThemingUniform = WGS.ThemingUniform;
    avs.ThemingFragmentDeclaration = WGS.ThemingFragmentDeclaration;
    avs.ThemingFragmentShaderChunk = WGS.ThemingFragmentShaderChunk;

    avs.BackgroundShader = WGS.BackgroundShader;

    avs.BlendShader = WGS.BlendShader;

    avs.CelShader = WGS.CelShader;

    avs.CopyShader = WGS.CopyShader;

    avs.FXAAShader = WGS.FXAAShader;

    avs.SAOBlurShader = WGS.SAOBlurShader;

    avs.SAOMinifyFirstShader = WGS.SAOMinifyFirstShader;
    avs.SAOMinifyShader = WGS.SAOMinifyShader;

    avs.SAOShader = WGS.SAOShader;

    avs.NormalsShader = WGS.NormalsShader;
    avs.EdgeShader = WGS.EdgeShader;

    avs.LineShader = WGS.LineShader;

    avp.LineStyleDefs = WGS.LineStyleDefs;
    avp.CreateLinePatternTexture = WGS.CreateLinePatternTexture;

    avp.FloatToHalf = WGS.FloatToHalf;
    avp.HalfToFloat = WGS.HalfToFloat;
    avp.IntToHalf = WGS.IntToHalf;
    avp.HalfToInt = WGS.HalfToInt;
    avp.HalfTest = WGS.HalfTest;

    avs.createShaderMaterial = WGS.createShaderMaterial;
    avs.setMacro = WGS.setMacro;
    avs.removeMacro = WGS.removeMacro;

    avs.LmvShaderPass = WGS.ShaderPass;

    avs.GaussianPass = WGS.GaussianPass;

    avs.GroundShadow = WGS.GroundShadow;
    avs.createGroundShape = WGS.createGroundShape;
    avs.setGroundShapeTransform = WGS.setGroundShapeTransform;

    avs.GroundReflection = WGS.GroundReflection;

    avp.FireflyWebGLShader = WGS.WebGLShader;

    avp.PrismMaps = WGS.PrismMaps;
    avp.GetPrismMapChunk = WGS.GetPrismMapChunk;
    avp.FireflyWebGLProgram = WGS.WebGLProgram;

    avs.ShadowMapCommonUniforms = WGS.ShadowMapCommonUniforms;
    avs.ShadowMapUniforms = WGS.ShadowMapUniforms;
    avs.ShadowMapDeclareCommonUniforms = WGS.ShadowMapDeclareCommonUniforms;
    avs.ShadowMapVertexDeclaration = WGS.ShadowMapVertexDeclaration;
    avs.ShadowMapVertexShaderChunk = WGS.ShadowMapVertexShaderChunk;
    avs.ShadowMapFragmentDeclaration = WGS.ShadowMapFragmentDeclaration;

    avs.FireflyPhongShader = WGS.PhongShader;

    avs.PrismShader = WGS.PrismShader;
    avs.GetPrismMapUniforms = WGS.GetPrismMapUniforms;
    avs.GetPrismMapSampleChunk = WGS.GetPrismMapSampleChunk;
    avs.GetPrismMapUniformChunk = WGS.GetPrismMapUniformChunk;
    avs.AverageOfFloat3 = WGS.AverageOfFloat3;
    avp.createPrismMaterial = WGS.createPrismMaterial;
    avp.clonePrismMaterial = WGS.clonePrismMaterial;

    avp.ShadowMapShader = WGS.ShadowMapShader;
    avp.GroundShadowShader = WGS.GroundShadowShader;
    avp.ShadowMapOverrideMaterials = WGS.ShadowMapOverrideMaterials;
    avp.SHADOWMAP_NEEDS_UPDATE = WGS.SHADOWMAP_NEEDS_UPDATE;
    avp.SHADOWMAP_INCOMPLETE = WGS.SHADOWMAP_INCOMPLETE;
    avp.SHADOWMAP_VALID = WGS.SHADOWMAP_VALID;
    avp.ShadowConfig = WGS.ShadowConfig;
    avp.ShadowRender = WGS.ShadowRender;
    avp.ShadowMaps = WGS.ShadowMaps;

    avp.FrustumIntersector = WGS.FrustumIntersector;
    avp.OUTSIDE = WGS.OUTSIDE;
    avp.INTERSECTS = WGS.INTERSECTS;
    avp.CONTAINS = WGS.CONTAINS;

    avp.VBIntersector = WGS.VBIntersector;
    avp.VertexEnumerator = WGS.VertexEnumerator;

    avp.GPU_MEMORY_LIMIT = WGS.GPU_MEMORY_LIMIT;
    avp.GPU_OBJECT_LIMIT = WGS.GPU_OBJECT_LIMIT;

    avp.PAGEOUT_SUCCESS = WGS.PAGEOUT_SUCCESS;
    avp.PAGEOUT_FAIL = WGS.PAGEOUT_FAIL;
    avp.PAGEOUT_NONE = WGS.PAGEOUT_NONE;

    avp.GeometryList = WGS.GeometryList;

    avp.MESH_VISIBLE = WGS.MESH_VISIBLE;
    avp.MESH_HIGHLIGHTED = WGS.MESH_HIGHLIGHTED;
    avp.MESH_HIDE = WGS.MESH_HIDE;
    avp.MESH_ISLINE = WGS.MESH_ISLINE;
    avp.MESH_ISWIDELINE = WGS.MESH_ISWIDELINE;
    avp.MESH_ISPOINT = WGS.MESH_ISPOINT;
    avp.MESH_MOVED = WGS.MESH_MOVED;
    avp.MESH_TRAVERSED = WGS.MESH_TRAVERSED;
    avp.MESH_DRAWN = WGS.MESH_DRAWN;
    avp.MESH_RENDERFLAG = WGS.MESH_RENDERFLAG;
    avp.FragmentPointer = WGS.FragmentPointer;
    avp.FragmentList = WGS.FragmentList;

    avp.RENDER_NORMAL = WGS.RENDER_NORMAL;
    avp.RENDER_HIGHLIGHTED = WGS.RENDER_HIGHLIGHTED;
    avp.RENDER_HIDDEN = WGS.RENDER_HIDDEN;
    avp.RENDER_SHADOWMAP = WGS.RENDER_SHADOWMAP;
    avp.RENDER_FINISHED = WGS.RENDER_FINISHED;

    avp.GROUND_UNFINISHED = WGS.GROUND_UNFINISHED;
    avp.GROUND_FINISHED = WGS.GROUND_FINISHED;
    avp.GROUND_RENDERED = WGS.GROUND_RENDERED;

    avp.RenderBatch = WGS.RenderBatch;

    av.rescueFromPolymer = WGS.rescueFromPolymer;

    avp.FireflyWebGLRenderer = WGS.WebGLRenderer;

    avp.ModelIteratorLinear = WGS.ModelIteratorLinear;
    avp.ModelIteratorBVH = WGS.ModelIteratorBVH;

    avp.BufferGeometryUtils = WGS.BufferGeometryUtils;

    avp.RenderScene = WGS.RenderScene;

    avp.SortedList = WGS.SortedList;

    avp.ModelIteratorTexQuad = WGS.ModelIteratorTexQuad;
    avp.TexQuadConfig = WGS.TexQuadConfig;

    avp.InstanceTree = WGS.InstanceTree;
    av.SelectionMode = WGS.SelectionMode;

    avp.MaterialConverter = WGS.MaterialConverter;
};


function getGlobal() {
    return (typeof window !== "undefined" && window !== null)
            ? window
            : (typeof self !== "undefined" && self !== null)
                ? self
                : global;
}

var av = Autodesk.Viewing,
    avp = av.Private;

av.getGlobal = getGlobal;

var isBrowser = av.isBrowser = (typeof navigator !== "undefined");

var isIE11 = av.isIE11 = isBrowser && !!navigator.userAgent.match(/Edge|Trident\/7\./);

// fix IE events
if(typeof window !== "undefined" && isIE11){
    (function () {
        function CustomEvent ( event, params ) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            var evt = document.createEvent( 'CustomEvent' );
            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
            return evt;
        }

        CustomEvent.prototype = window.CustomEvent.prototype;

        window.CustomEvent = CustomEvent;
    })();
}

// IE does not implement ArrayBuffer slice. Handy!
if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function(start, end) {
        // Normalize start/end values
        if (!end || end > this.byteLength) {
            end = this.byteLength;
        }
        else if (end < 0) {
            end = this.byteLength + end;
            if (end < 0) end = 0;
        }
        if (start < 0) {
            start = this.byteLength + start;
            if (start < 0) start = 0;
        }

        if (end <= start) {
            return new ArrayBuffer();
        }

        // Bytewise copy- this will not be fast, but what choice do we have?
        var len = end - start;
        var view = new Uint8Array(this, start, len);
        var out = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            out[i] = view[i];
        }
        return out.buffer;
    };
}

// IE doesn't implement Math.log2
(function(){
    Math.log2 = Math.log2 || function(x) {
        return Math.log(x) / Math.LN2;
    };
})();

//The BlobBuilder object
if (typeof window !== "undefined")
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;


// Launch full screen on the given element with the available method
var launchFullscreen = av.launchFullscreen = function(element, options) {
    if (element.requestFullscreen) {
        element.requestFullscreen(options);
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen(options);
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen(options);
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen(options);
    }
};

// Exit full screen with the available method
var exitFullscreen = av.exitFullscreen = function() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
    }
};

// Determines if the browser is in full screen
var inFullscreen = av.inFullscreen = function(){

    // Special case for Ms-Edge that has webkitIsFullScreen with correct value
    // and fullscreenEnabled with wrong value (thanks MS)

    if ("webkitIsFullScreen" in document) return !!(document.webkitIsFullScreen);
    if ("fullscreenElement" in document) return !!(document.fullscreenElement);
    if ("mozFullScreenElement" in document) return !!(document.mozFullScreenElement);
    if ("msFullscreenElement" in document) return !!(document.msFullscreenElement);

    return !!(document.querySelector(".viewer-fill-browser")); // Fallback for iPad
};

var fullscreenElement = av.fullscreenElement = function() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
};

var isFullscreenAvailable = av.isFullscreenAvailable = function(element) {
    return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
};

// Get the version of the android device through user agent.
// Return the version string of android device, e.g. 4.4, 5.0...
var getAndroidVersion = av.getAndroidVersion = function(ua) {
    ua = ua || navigator.userAgent;
    var match = ua.match(/Android\s([0-9\.]*)/);
    return match ? match[1] : false;
};

// Determine if this is a touch or notouch device.
var isTouchDevice = av.isTouchDevice = function() {
    /*
    // Temporarily disable touch support through hammer on Android 5, to debug
    // some specific gesture issue with Chromium WebView when loading viewer3D.js.
    if (parseInt(getAndroidVersion()) == 5) {
        return false;
    }
    */

    return (typeof window !== "undefined" &&  "ontouchstart" in window);
};

av.isIOSDevice = function() {
    if (!isBrowser) return false;
    return /ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase());
};

av.isAndroidDevice = function() {
    if (!isBrowser) return false;
    return (navigator.userAgent.toLowerCase().indexOf('android') !== -1);
};

av.isMobileDevice = function() {
    if (!isBrowser) return false;
    return av.isIOSDevice() || av.isAndroidDevice();
};

av.isSafari = function() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return (_ua.indexOf("safari") !== -1) && (_ua.indexOf("chrome") === -1);
};

av.isFirefox = function() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return (_ua.indexOf("firefox") !== -1);
};

av.isChrome = function() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return (_ua.indexOf("chrome") !== -1);
};

av.isMac = function() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return  (_ua.indexOf("mac os") !== -1);
};

av.isWindows = function() {
    if (!isBrowser) return false;
    var _ua = navigator.userAgent.toLowerCase();
    return  (_ua.indexOf("win32") !== -1 || _ua.indexOf("windows") !== -1);
};

av.ObjectAssign = function(des, src) {
    for (var key in src) {
        if (src.hasOwnProperty(key))
            des[key] = src[key];
    }
    return des;
};


// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
avp.disableTouchSafari = function(event) {
    var xOff = window.hasOwnProperty("pageXOffset") ? window.pageXOffset : document.documentElement.scrollLeft;
    var yOff = window.hasOwnProperty("pageYOffset") ? window.pageYOffset : document.documentElement.scrollTop;
    // If we aren't inside the canvas, then allow default propagation of the event
    var element = document.elementFromPoint(event.pageX - xOff, event.pageY - yOff);
    if (!element || element.nodeName !== 'CANVAS')
        return true;
    // If it's a CANVAS, check that it's owned by us
    if (element.getAttribute('data-viewer-canvas' !== 'true'))
        return true;
    // Inside the canvas, prevent the event from propagating to Safari'safely
    // standard handlers, which will pan and zoom the page.
    event.preventDefault();
    return false;
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
avp.disableDocumentTouchSafari = function() {
    if (av.isMobileDevice() && av.isSafari()) {
        // Safari mobile disable default touch handling inside viewer canvas
        // Use capture to make sure Safari doesn't capture the touches and prevent
        // us from disabling them.
        document.documentElement.addEventListener('touchstart', avp.disableTouchSafari, true);
        document.documentElement.addEventListener('touchmove', avp.disableTouchSafari, true);
        document.documentElement.addEventListener('touchcanceled', avp.disableTouchSafari, true);
        document.documentElement.addEventListener('touchend', avp.disableTouchSafari, true);
    }
};

// Hack to work around Safari's use of pinch and pan inside the viewer canvas.
// This method is not being invoked explicitly.
avp.enableDocumentTouchSafari = function() {
    if (av.isMobileDevice() && av.isSafari()) {
        // Safari mobile disable default touch handling inside viewer canvas
        // Use capture to make sure Safari doesn't capture the touches and prevent
        // us from disabling them.
        document.documentElement.removeEventListener('touchstart', avp.disableTouchSafari, true);
        document.documentElement.removeEventListener('touchmove', avp.disableTouchSafari, true);
        document.documentElement.removeEventListener('touchcanceled', avp.disableTouchSafari, true);
        document.documentElement.removeEventListener('touchend', avp.disableTouchSafari, true);
    }
};

/**
 * Detects if WebGL is enabled.
 *
 * @return { number } -1 for not Supported,
 *                    0 for disabled
 *                    1 for enabled
 */
var detectWebGL = av.detectWebGL = function()
{
    // Check for the webgl rendering context
    if ( !! window.WebGLRenderingContext) {
        var canvas = document.createElement("canvas"),
            names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"],
            context = false;

        for (var i = 0; i < 4; i++) {
            try {
                context = canvas.getContext(names[i]);
                context = rescueFromPolymer(context);
                if (context && typeof context.getParameter === "function") {
                    // WebGL is enabled.
                    //
                    return 1;
                }
            } catch (e) {}
        }

        // WebGL is supported, but disabled.
        //
        return 0;
    }

    // WebGL not supported.
    //
    return -1;
};


// Convert touchstart event to click to remove the delay between the touch and
// the click event which is sent after touchstart with about 300ms deley.
// Should be used in UI elements on touch devices.
var touchStartToClick = av.touchStartToClick = function(e) {
    // Buttons that activate fullscreen are a special case. The HTML5 fullscreen spec
    // requires the original user gesture signal to avoid a security issue.  See LMV-2396 and LMV-2326
    if ((e.target.className.indexOf("fullscreen")>-1) || (e.target.className.indexOf("webvr")>-1))
        return;
    e.preventDefault();  // Stops the firing of delayed click event.
    e.stopPropagation();
    e.target.click();    // Maps to immediate click.
};

//Safari doesn't have the Performance object
//We only need the now() function, so that's easy to emulate.
(function() {
    var global = getGlobal();
    if (!global.performance)
        global.performance = Date;
})();

// Polyfill for IE and Safari
// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger = Number.isInteger || function(value) {
    return typeof value === "number" &&
        isFinite(value) &&
        Math.floor(value) === value;
};

// Polyfill for IE
String.prototype.repeat = String.prototype.repeat || function(count) {
    if (count < 1) return '';
    var result = '', pattern = this.valueOf();
    while (count > 1) {
        if (count & 1) result += pattern;
        count >>= 1, pattern += pattern;
    }
    return result + pattern;
};

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
Array.prototype.fill = Array.prototype.fill || function(value, start, end) {

    start = (start === undefined) ? 0 : start;
    end = (end === undefined) ? this.length : end;
    for (var i=start; i<end; ++i) 
        this[i] = value;
};

// Polyfill for IE
Int32Array.prototype.lastIndexOf = Int32Array.prototype.lastIndexOf || function(searchElement, fromIndex) {
    return Array.prototype.lastIndexOf.call(this, searchElement, fromIndex);
};

// Polyfill for IE
// It doesn't support negative values for start and end; it complicates the code using this function.
Array.prototype.find = Array.prototype.find || function(callback, _this) {

    var len = this.length;
    for (var i=0; i<len; ++i) {
        var item = this[i];
        if (callback.call(_this, item, i, this))
            return item;
    }
    return undefined;
};



//This file is the first one when creating minified build
//and is used to set certain flags that are needed
//for the concatenated build.

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

//avp.IS_CONCAT_BUILD = true; // Debugging source files without concatenation is no longer supported

/** @define {string} */
avp.BUILD_LMV_WORKER_URL = "lmvworker.js";
avp.LMV_WORKER_URL = avp.BUILD_LMV_WORKER_URL;

avp.ENABLE_DEBUG = avp.ENABLE_DEBUG || false;
//avp.DEBUG_SHADERS = avp.DEBUG_SHADERS || false; // will be moved to wgs.js
avp.ENABLE_INLINE_WORKER = true;	// try changing to false for IE model load problems


(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

/**
 * Logging levels. Higher number means more verbose logs,
 * for example, with level 3, `info`, `warn`, or `error`
 * logs will show up in the console but `debug` and `log` won't.
 *
 * Semantics of specific levels:
 *  - debug: low-level debugging logs
 *  - log: common, higher-level debugging logs
 *  - info: helpful runtime information (even for stag/prod environments)
 *  - warn: potentially problematic situations; handled exceptions
 *  - error: definitely problematic situations; unhandled exceptions
 * @readonly
 * @enum {number}
 */
avp.LogLevels = {
    DEBUG: 5,
    LOG: 4,
    INFO: 3,
    WARNING: 2,
    ERROR: 1,
    NONE: 0
};

function Logger() {
    this.adp = null;
    this.runtimeStats = {};
    this.level = -1;
    this.setLevel(avp.LogLevels.ERROR);
}

Logger.prototype.initialize = function(options) {

    if (options.eventCallback)
        this.callback = options.eventCallback;

    this.sessionId = options.sessionId;
    if (!this.sessionId) {
        var now = Date.now() + "";
        this.sessionId = parseFloat(((Math.random() * 10000) | 0) + "" + now.substring(4));
    }

    // Initialize log level is passed in
    var logLevel = options.logLevel || options.loglevel; // typo-support
    if (typeof logLevel === 'number' && this.level !== logLevel) {
        this.setLevel(logLevel);
    }

    this.environmentInfo = {
        touch: av.isTouchDevice(),
        env: avp.env,
        referer: getReferer(),
        version: LMV_VIEWER_VERSION,
        patch: LMV_VIEWER_PATCH,
        build_type: LMV_BUILD_TYPE
    };

    //Kick off with a viewer start event
    var startEvent = {
        category: "viewer_start",
        touch: this.environmentInfo.touch,
        env: this.environmentInfo.env,
        referer: this.environmentInfo.referer,
        version: this.environmentInfo.version,
        patch: this.environmentInfo.patch,
        build_type: this.environmentInfo.build_type
    };
    this.track(startEvent);

    var _this = this;
    this.interval = setInterval(function() {
        _this.reportRuntimeStats();
    }, 60000);
};

Logger.prototype.shutdown = function() {
    clearInterval(this.interval);
    this.interval = undefined;
};

Logger.prototype.track = function (entry) {
    this.updateRuntimeStats(entry);

    if (avp.offline || !this.sessionId) {
        return;
    }

    entry.timestamp = Date.now();
    entry.sessionId = this.sessionId;

    var sent = this.logToADP(entry);

    if (this.callback) {
        this.callback(entry, {
            adp: sent
        });
    }
};

Logger.prototype.logToADP = function(entry) {
    if (!this.adp) {
        return false;
    }

    // Map & log legacy events to ADP
    // TODO: move away from the legacy naming and avoid the awkward switch below
    var evType = '';
    var opType = '';
    switch (entry.category) {
        case 'tool_changed':
        case 'pref_changed':
            evType = 'CLICK_OPERATION';
            opType = entry.category + '/' + entry.name;
            break;
        case 'screen_mode':
            evType = 'CLICK_OPERATION';
            opType = 'pref_changed/' + entry.category;
            break;
        case 'metadata_load_stats':
            evType = 'DOCUMENT_START';
            opType = 'stats';
            entry.full_url = getReferer();
            break;
        case 'model_load_stats':
            evType = 'DOCUMENT_FULL';
            opType = 'stats';
            break;
        case 'tool_used':
            evType = 'BACKGROUND_CALL';
            opType = entry.category + '/' + entry.name;
            break;
        case 'settingOptionsStatus':
            evType = 'BACKGROUND_CALL';
            opType = entry.category + '/' + entry.list;
            break;
        case 'node_selected':
        case 'search_node':
            evType = 'CLICK_OPERATION';
            opType = entry.category + '/' + entry.name;
            break;
        case 'error':
            evType = 'BACKGROUND_CALL';
            opType = 'error';
            break;
    }

    if (!evType)
        return false;

    this.adp.trackEvent(evType, {
        operation: {
            id: entry.sessionId,
            type: opType,
            stage: '',
            status: 'C',
            meta: entry
        }
    });
    return true;
};

Logger.prototype.updateRuntimeStats = function(entry) {
    if (entry.hasOwnProperty('aggregate')) {
        switch (entry.aggregate) {
            case 'count':
                if (this.runtimeStats[entry.name] > 0) {
                    this.runtimeStats[entry.name]++;
                } else {
                    this.runtimeStats[entry.name] = 1;
                }
                this.runtimeStats._nonempty = true;
                break;
            case 'last':
                this.runtimeStats[entry.name] = entry.value;
                this.runtimeStats._nonempty = true;
                break;
            default:
                this.warn('unknown log aggregate type');
        }
    }
};

Logger.prototype.reportRuntimeStats = function() {
    if (this.runtimeStats._nonempty) {
        delete this.runtimeStats._nonempty;

        if (this.adp) {
            this.adp.trackEvent('BACKGROUND_CALL', {
                operation: {
                    id: this.sessionId,
                    type: 'stats',
                    stage: '',
                    status: 'C',
                    meta: this.runtimeStats
                }
            });
        }

        this.runtimeStats.category = 'misc_stats';
        this.track(this.runtimeStats);
        this.runtimeStats = {};
    }
};

Logger.prototype.setLevel = function(level) {
    if (this.level === level)
        return;

    this.level = level;

    var nullFn = function(){};
    var avpl = avp.LogLevels;
    var self = this;

    var reportError = function() {
        if (self.callback) {
            var msg = Array.prototype.slice.call(arguments).join(' ');
            self.callback({ category: 'error', message: msg }, { adp: false });
        }
        console.error.apply(console, arguments);
    };

    // Bind to console
    this.debug = level >= avpl.DEBUG   ? console.log.bind(console) : nullFn;
    this.log   = level >= avpl.LOG     ? console.log.bind(console)   : nullFn;
    this.info  = level >= avpl.INFO    ? console.info.bind(console)  : nullFn;
    this.warn  = level >= avpl.WARNING ? console.warn.bind(console)  : nullFn;
    this.error = level >= avpl.ERROR   ? reportError : nullFn;
};

/**
 * @private
 */
function getReferer(){
    // Wrapping href retrieval due to Fortify complains
    if (typeof window !== 'undefined') {
        return encodeURI(window.location.href);
    }
    return '';
}

Autodesk.Viewing.Private.logger = new Logger();

})();

// WebRTC adapter (adapter.js) from Google

if (typeof window !== 'undefined')
{

    var RTCPeerConnection = null;
    var getUserMedia = null;
    var attachMediaStream = null;
    var reattachMediaStream = null;
    var webrtcDetectedBrowser = null;
    var webrtcDetectedVersion = null;

    function trace(text) {
        // This function is used for logging.
        if (text[text.length - 1] == '\n') {
            text = text.substring(0, text.length - 1);
        }
        console.log((performance.now() / 1000).toFixed(3) + ": " + text);
    }

    if (navigator.mozGetUserMedia) {
        //console.log("This appears to be Firefox");

        webrtcDetectedBrowser = "firefox";

        webrtcDetectedVersion =
            parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]);

        // The RTCPeerConnection object.
        RTCPeerConnection = mozRTCPeerConnection;

        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription;

        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.mozGetUserMedia.bind(navigator);

        // Creates iceServer from the url for FF.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0 &&
                (url.indexOf('transport=udp') !== -1 ||
                    url.indexOf('?transport') === -1)) {
                // Create iceServer with turn url.
                // Ignore the transport parameter from TURN url.
                var turn_url_parts = url.split("?");
                iceServer = { 'url': turn_url_parts[0],
                    'credential': password,
                    'username': username };
            }
            return iceServer;
        };

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            console.log("Attaching media stream");
            element.mozSrcObject = stream;
            element.play();
        };

        reattachMediaStream = function (to, from) {
            console.log("Reattaching media stream");
            to.mozSrcObject = from.mozSrcObject;
            to.play();
        };

        // Fake get{Video,Audio}Tracks
        MediaStream.prototype.getVideoTracks = function () {
            return [];
        };

        MediaStream.prototype.getAudioTracks = function () {
            return [];
        };
    } else if (navigator.webkitGetUserMedia) {
        //console.log("This appears to be Chrome");

        var match = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);

        webrtcDetectedBrowser = "chrome";

        // need to check because this crashes on Chrome mobile emulation
        // 40 is an arbitrary version which the feature is available
        webrtcDetectedVersion = match ?
            parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]) : 40;

        // Creates iceServer from the url for Chrome.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0) {
                if (webrtcDetectedVersion < 28) {
                    // For pre-M28 chrome versions use old TURN format.
                    var url_turn_parts = url.split("turn:");
                    iceServer = { 'url': 'turn:' + username + '@' + url_turn_parts[1],
                        'credential': password };
                } else {
                    // For Chrome M28 & above use new TURN format.
                    iceServer = { 'url': url,
                        'credential': password,
                        'username': username };
                }
            }
            return iceServer;
        };

        // The RTCPeerConnection object.
        RTCPeerConnection = webkitRTCPeerConnection;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = URL.createObjectURL(stream);
            } else {
                console.log('Error attaching stream to element.');
            }
        };

        reattachMediaStream = function (to, from) {
            to.src = from.src;
        };

        // The representation of tracks in a stream is changed in M26.
        // Unify them for earlier Chrome versions in the coexisting period.
        if (!webkitMediaStream.prototype.getVideoTracks) {
            webkitMediaStream.prototype.getVideoTracks = function () {
                return this.videoTracks;
            };
            webkitMediaStream.prototype.getAudioTracks = function () {
                return this.audioTracks;
            };
        }

        // New syntax of getXXXStreams method in M26.
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
            webkitRTCPeerConnection.prototype.getLocalStreams = function () {
                return this.localStreams;
            };
            webkitRTCPeerConnection.prototype.getRemoteStreams = function () {
                return this.remoteStreams;
            };
        }
    } else {
        console.log("Browser does not appear to be WebRTC-capable");
    }

}


/*
 * Internet explorer generates pointer events by default for all input types like mouse, pen or touch (finger).
 * Touchr is generating touch events only for touch type by default but it can be overwritten by
 * window.Touchr_ALLOWED_POINTER_TYPE bitmask property. It can have values:
 * 1 for touch
 * 2 for mouse
 * 4 for pen
 * and their combinations.
 */

(function(window) {
    var IE_10		= !!window.navigator.msPointerEnabled,
        // Check below can mark as IE11+ also other browsers which implements pointer events in future
        // that is not issue, because touch capability is tested in IF statement bellow.
        IE_11_PLUS	= !!window.navigator.pointerEnabled;

    // Only pointer enabled browsers without touch capability.
    if (IE_10 || (IE_11_PLUS && !('ontouchstart' in window))) {
        var document = window.document,
            POINTER_DOWN		= IE_11_PLUS ? "pointerdown"	: "MSPointerDown",
            POINTER_UP 			= IE_11_PLUS ? "pointerup"		: "MSPointerUp",
            POINTER_MOVE		= IE_11_PLUS ? "pointermove"	: "MSPointerMove",
            POINTER_TYPE_TOUCH 	= IE_11_PLUS ? "touch"	: MSPointerEvent.MSPOINTER_TYPE_TOUCH,
            POINTER_TYPE_MOUSE 	= IE_11_PLUS ? "mouse"	: MSPointerEvent.MSPOINTER_TYPE_MOUSE,
            POINTER_TYPE_PEN 	= IE_11_PLUS ? "pen"	: MSPointerEvent.MSPOINTER_TYPE_PEN, //IE11+ has also unknown type which Touchr doesn't support
            GESTURE_START		= "MSGestureStart",
            GESTURE_CHANGE		= "MSGestureChange",
            GESTURE_END			= "MSGestureEnd",
            TOUCH_ACTION		= IE_11_PLUS ? "touchAction" : "msTouchAction",
            _180_OVER_PI		= 180/Math.PI,
            // Which pointer types will be used for generating touch events: 1 - touch, 2 - mouse, 4 - pen or their combination
            ALLOWED_POINTER_TYPE = window.Touchr_ALLOWED_POINTER_TYPE || 1,
            createEvent = function (eventName, target, params) {
                var k,
                    event = document.createEvent("Event");

                event.initEvent(eventName, true, true);
                for (k in params) {
                    event[k] = params[k];
                }
                target.dispatchEvent(event);
            },
            /**
             * ECMAScript 5 accessors to the rescue
             * @see http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/
             */
            makeSubArray = (function() {
                var MAX_SIGNED_INT_VALUE = Math.pow(2, 32) - 1,
                    hasOwnProperty = Object.prototype.hasOwnProperty;

                function ToUint32(value) {
                    return value >>> 0;
                }

                function getMaxIndexProperty(object) {
                    var maxIndex = -1,
                        isValidProperty,
                        prop;

                    for (prop in object) {

                        isValidProperty = (
                            String(ToUint32(prop)) === prop &&
                            ToUint32(prop) !== MAX_SIGNED_INT_VALUE &&
                            hasOwnProperty.call(object, prop));

                        if (isValidProperty && prop > maxIndex) {
                            maxIndex = prop;
                        }
                    }
                    return maxIndex;
                }

                return function(methods) {
                    var length = 0;
                    methods = methods || { };

                    methods.length = {
                        get: function() {
                            var maxIndexProperty = +getMaxIndexProperty(this);
                            return Math.max(length, maxIndexProperty + 1);
                        },
                        set: function(value) {
                            var constrainedValue = ToUint32(value);
                            if (constrainedValue !== +value) {
                                throw new RangeError();
                            }
                            for (var i = constrainedValue, len = this.length; i < len; i++) {
                                delete this[i];
                            }
                            length = constrainedValue;
                        }
                    };
                    methods.toString = {
                        value: Array.prototype.join
                    };
                    return Object.create(Array.prototype, methods);
                };
            })(),
            // methods passed to TouchList closure method to extend Array
            touchListMethods = {
                /**
                 * Returns touch by id. This method fulfill the TouchList interface.
                 * @param {Number} id
                 * @returns {Touch}
                 */
                identifiedTouch: {
                    value: function (id) {
                        var length = this.length;
                        while (length--) {
                            if (this[length].identifier === id) return this[length];
                        }
                        return undefined;
                    }
                },
                /**
                 * Returns touch by index. This method fulfill the TouchList interface.
                 * @param {Number} index
                 * @returns {Touch}
                 */
                item: {
                    value: function (index) {
                        return this[index];
                    }
                },
                /**
                 * Returns touch index
                 * @param {Touch} touch
                 * @returns {Number}
                 */
                _touchIndex: {
                    value: function (touch) {
                        var length = this.length;
                        while (length--) {
                            if (this[length].pointerId == touch.pointerId) return length;
                        }
                        return -1;
                    }
                },

                /**
                 * Add all events and convert them to touches
                 * @param {Event[]} events
                 */
                _addAll: {
                    value: function(events) {
                        var i = 0,
                            length = events.length;

                        for (; i < length; i++) {
                            this._add(events[i]);
                        }
                    }
                },

                /**
                 * Add and MSPointer event and convert it to Touch like object
                 * @param {Event} event
                 */
                _add: {
                    value: function(event) {
                        var index = this._touchIndex(event);

                        index = index < 0 ? this.length : index;

                        //normalizing Pointer to Touch
                        event.type = POINTER_MOVE;
                        event.identifier = event.pointerId;
                        //in DOC is mentioned that it is 0..255 but actually it returns 0..1 value
                        //returns 0.5 for mouse down buttons in IE11, should it be issue?
                        event.force = event.pressure;
                        //default values for Touch which we cannot obtain from Pointer
                        event.radiusX = event.radiusY = 1;
                        event.rotationAngle = 0;

                        this[index] = event;
                    }
                },

                /**
                 * Removes an event from this touch list.
                 * @param {Event} event
                 */
                _remove: {
                    value: function(event) {
                        var index = this._touchIndex(event);

                        if (index >= 0) {
                            this.splice(index,1);
                        }
                    }
                }
            },

            /**
             * This class store touches in an list which can be also accessible as array which is
             * little bit bad because TouchList have to extend Array. Because we are aiming on
             * IE10+ we can use ECMAScript5 solution.
             * @extends Array
             * @see http://www.w3.org/TR/2011/WD-touch-events-20110913/#touchlist-interface
             * @see https://developer.mozilla.org/en-US/docs/DOM/TouchList
             */
            TouchList = (function(methods) {
                return function() {
                    var arr = makeSubArray(methods);
                    if (arguments.length === 1) {
                        arr.length = arguments[0];
                    }
                    else {
                        arr.push.apply(arr, arguments);
                    }
                    return arr;
                };
            })(touchListMethods),

            /**
             * list of all touches running during life cycle
             * @type TouchList
             */
            generalTouchesHolder,

            /**
             * Storage of link between pointer {id} and original target
             * @type Object
             */
            pointerToTarget = {},

            /**
             * General gesture object which fires MSGesture events whenever any associated MSPointer event changed.
             */
            gesture = window.MSGesture ? new MSGesture() : null,

            gestureScale = 1,
            gestureRotation = 0,

            /**
             * Storage of targets and anonymous MSPointerStart handlers for later
             * unregistering
             * @type Array
             */
            attachedPointerStartMethods = [],

            /**
             * Checks if node is some of parent children or sub-children
             * @param {HTMLElement|Document} parent
             * @param {HTMLElement} node
             * @returns {Boolean}
             */
            checkSameTarget = function (parent, node) {
                if (node) {
                    if (parent === node) {
                        return true;
                    } else {
                        return checkSameTarget(parent, node.parentNode);
                    }
                } else {
                    return false;
                }
            },

            /**
             * Returns bitmask type of pointer to compare with allowed pointer types
             * @param {Number|String} pointerType
             * @returns {Number}
             */
            pointerTypeToBitmask = function (pointerType) {
                if (pointerType == POINTER_TYPE_TOUCH) {
                    return 1;
                } else if (pointerType == POINTER_TYPE_MOUSE) {
                    return 2;
                } else {
                    return 4;
                }
            },

            /**
             * Main function which is rewriting the MSPointer event to touch event
             * and preparing all the necessary lists of touches.
             * @param {Event} evt
             */
            pointerListener = function (evt) {
                var type,
                    i,
                    target = evt.target,
                    originalTarget,
                    changedTouches,
                    targetTouches;

                // Skip pointers which are not allowed by users:
                if (!(pointerTypeToBitmask(evt.pointerType) & ALLOWED_POINTER_TYPE)) {
                    return;
                }

                if (evt.type === POINTER_DOWN) {
                    generalTouchesHolder._add(evt);
                    pointerToTarget[evt.pointerId] = evt.target;

                    type = "touchstart";

                    // Fires MSGesture event when we have at least two pointers in our holder
                    // (adding pointers to gesture object immediately fires Gesture event)
                    if (generalTouchesHolder.length > 1) {
                        gesture.target = evt.target;
                        for (i = 0; i < generalTouchesHolder.length; i++) {
                            // Adds to gesture only touches
                            // It is not necessary to create separate gesture for mouse or pen pointers
                            // because they cannot be present more than by 1 pointer.
                            if (generalTouchesHolder[i].pointerType === POINTER_TYPE_TOUCH) {
                                gesture.addPointer(generalTouchesHolder[i].pointerId);
                            }
                        }
                    }
                }

                if (evt.type === POINTER_MOVE && generalTouchesHolder.identifiedTouch(evt.pointerId)) {
                    generalTouchesHolder._add(evt);

                    type = "touchmove";
                }

                //Preparation of touch lists have to be done before pointerup/MSPointerUp where we delete some information

                //Which touch fired this event, because we know that MSPointer event is fired for every
                //changed pointer than we create a list only with actual pointer
                changedTouches = document.createTouchList(evt);
                //Target touches is list of touches which started on (touchstart) on target element, they
                //are in this array even if these touches have coordinates outside target elements
                targetTouches = document.createTouchList();
                for (i = 0; i < generalTouchesHolder.length; i++) {
                    //targetTouches._add(generalTouchesHolder[i]);
                    //check if the pointerTarget is in the target
                    if (checkSameTarget(target, pointerToTarget[generalTouchesHolder[i].identifier])) {
                        targetTouches._add(generalTouchesHolder[i]);
                    }
                }
                originalTarget = pointerToTarget[evt.pointerId];

                if (evt.type === POINTER_UP) {
                    generalTouchesHolder._remove(evt);
                    pointerToTarget[evt.pointerId] = null;

                    delete pointerToTarget[evt.pointerId];
                    type = "touchend";

                    // Fires MSGestureEnd event when there is only one ore zero touches:
                    if (generalTouchesHolder.length <= 1) {
                        gesture.stop();
                    }
                }

                //console.log("+", evt.type, evt.pointerType, generalTouchesHolder.length, evt.target.nodeName+"#"+evt.target.id);
                if (type && originalTarget) {
                    createEvent(type, originalTarget, {touches: generalTouchesHolder, changedTouches: changedTouches, targetTouches: targetTouches});
                }
            },

            /**
             * Main function which is rewriting the MSGesture event to gesture event.
             * @param {Event} evt
             */
            gestureListener = function (evt) {
                //TODO: check first, other than IE (FF?), browser which implements pointer events how to make gestures from pointers. Maybe it would be mix of pointer/gesture events.
                var type, scale, rotation;
                if (evt.type === GESTURE_START) {type = "gesturestart"}
                else if (evt.type === GESTURE_CHANGE) {type = "gesturechange"}
                else if (evt.type === GESTURE_END) {type = "gestureend"}

                // -------- SCALE ---------
                //MSGesture:
                //Scale values represent the difference in scale from the last MSGestureEvent that was fired.
                //Apple:
                //The distance between two fingers since the start of an event, as a multiplier of the initial distance. The initial value is 1.0.

                // ------- ROTATION -------
                //MSGesture:
                //Clockwise rotation of the cursor around its own major axis expressed as a value in radians from the last MSGestureEvent of the interaction.
                //Apple:
                //The delta rotation since the start of an event, in degrees, where clockwise is positive and counter-clockwise is negative. The initial value is 0.0
                if (evt.type === GESTURE_START) {
                    scale = gestureScale = 1;
                    rotation = gestureRotation = 0;
                } else {
                    scale = gestureScale = gestureScale + (evt.scale - 1); //* evt.scale;
                    rotation = gestureRotation = gestureRotation + evt.rotation * _180_OVER_PI;
                }

                createEvent(type, evt.target, {scale: scale, rotation: rotation, screenX: evt.screenX, screenY: evt.screenY});
            },

            /**
             * This method augments event listener methods on given class to call
             * our own method which attach/detach the MSPointer events handlers
             * when user tries to attach touch events.
             * @param {Function} elementClass Element class like HTMLElement or Document
             */
            augmentEventListener = function(elementClass) {
                var customAddEventListener = attachTouchEvents,
                    customRemoveEventListener = removeTouchEvents,
                    oldAddEventListener = elementClass.prototype.addEventListener,
                    oldRemoveEventListener = elementClass.prototype.removeEventListener;

                elementClass.prototype.addEventListener = function(type, listener, useCapture) {
                    //"this" is HTML element
                    if ((type.indexOf("gesture") === 0 || type.indexOf("touch") === 0)) {
                        customAddEventListener.call(this, type, listener, useCapture);
                    }
                    oldAddEventListener.call(this, type, listener, useCapture);
                };

                elementClass.prototype.removeEventListener = function(type, listener, useCapture) {
                    if ((type.indexOf("gesture") === 0 || type.indexOf("touch") === 0)) {
                        customRemoveEventListener.call(this, type, listener, useCapture);
                    }
                    oldRemoveEventListener.call(this, type, listener, useCapture);
                };
            },
            /**
             * This method attach event handler for MSPointer / MSGesture events when user
             * tries to attach touch / gesture events.
             * @param {String} type
             * @param {Function} listener
             * @param {Boolean} useCapture
             */
            attachTouchEvents = function (type, listener, useCapture) {
                //element owner document or document itself
                var doc = this.nodeType == 9 ?  this : this.ownerDocument;

                // Because we are listening only on document, it is not necessary to
                // attach events on one document more times
                if (attachedPointerStartMethods.indexOf(doc) < 0) {
                    //TODO: reference on node, listen on DOM removal to clean the ref?
                    attachedPointerStartMethods.push(doc);
                    doc.addEventListener(POINTER_DOWN, pointerListener, useCapture);
                    doc.addEventListener(POINTER_MOVE, pointerListener, useCapture);
                    doc.addEventListener(POINTER_UP, pointerListener, useCapture);
                    doc.addEventListener(GESTURE_START, gestureListener, useCapture);
                    doc.addEventListener(GESTURE_CHANGE, gestureListener, useCapture);
                    doc.addEventListener(GESTURE_END, gestureListener, useCapture);
                }

                // e.g. Document has no style
                if (this.style && (typeof this.style[TOUCH_ACTION] == "undefined" || !this.style[TOUCH_ACTION])) {
                    this.style[TOUCH_ACTION] = "none";
                }
            },
            /**
             * This method detach event handler for MSPointer / MSGesture events when user
             * tries to detach touch / gesture events.
             * @param {String} type
             * @param {Function} listener
             * @param {Boolean} useCapture
             */
            removeTouchEvents = function (type, listener, useCapture) {
                //todo: are we able to understand when all listeners are unregistered and shall be removed?
            };


        /*
         * Adding DocumentTouch interface
         * @see http://www.w3.org/TR/2011/WD-touch-events-20110505/#idl-def-DocumentTouch
         */

        /**
         * Create touches list from array or touches or given touch
         * @param {Touch[]|Touch} touches
         * @returns {TouchList}
         */
        document.createTouchList = function(touches) {
            var touchList = new TouchList();
            if (touches) {
                if (touches.length) {
                    touchList._addAll(touches);
                } else {
                    touchList._add(touches);
                }
            }
            return touchList;
        };

        /*******  Fakes which persuade other code to use touch events ********/

        /**
         * AbstractView is class for document.defaultView === window
         * @param {AbstractView} view
         * @param {EventTarget} target
         * @param {Number} identifier
         * @param {Number} pageX
         * @param {Number} pageY
         * @param {Number} screenX
         * @param {Number} screenY
         * @return {Touch}
         */
        document.createTouch = function(view, target, identifier, pageX, pageY, screenX, screenY) {
            return {
                identifier: identifier,
                screenX: screenX,
                screenY: screenY,
                //clientX: clientX,
                //clientY: clientY,
                pageX: pageX,
                pageY: pageY,
                target: target
            };
        };
        //Fake Modernizer touch test
        //http://modernizr.github.com/Modernizr/touch.html
        if (!window.ontouchstart) window.ontouchstart = 1;

        /*******  End of fakes ***********************************/

        generalTouchesHolder = document.createTouchList();

        // Overriding HTMLElement and HTMLDocument to hand over touch handler to MSPointer event handler
        augmentEventListener(HTMLElement);
        augmentEventListener(Document);
    }
}(window));
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
typeof window!=="undefined"&&(!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),/*Workaround for 'define' being overridden in A360 */ false && typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports && false /* Workaround for 'module' being defined by Angular.js in Columbus. */ ?module.exports=eb:a[c]=eb}(window,document,"Hammer"));


(function() {

"use strict";

var av = Autodesk.Viewing;

av.EventDispatcher = function() {
};


av.EventDispatcher.prototype = {

    constructor: av.EventDispatcher,


    apply: function(object) {

		object.addEventListener = av.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = av.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = av.EventDispatcher.prototype.removeEventListener;
		object.fireEvent = av.EventDispatcher.prototype.fireEvent;
		object.dispatchEvent = av.EventDispatcher.prototype.fireEvent;
    },

    /**
     * Adds an event listener.
     * @param {(string | type)} type
     * @param {function} listener
     */
    addEventListener : function(type, listener)
    {
        if (!type) return;
        if ( this.listeners === undefined ) this.listeners = {};

        if (typeof this.listeners[type] == "undefined"){
            this.listeners[type] = [];
        }

        this.listeners[type].push(listener);
    },

    /**
     * Returns true if the specified listener already exists, false otherwise.
     * @param {(string)} type
     * @param {function} listener
     */
    hasEventListener : function (type, listener) {

        if (!type) return false;
        if (this.listeners === undefined) return false;
        var listeners = this.listeners;
        if (listeners[ type ] !== undefined && listeners[ type ].indexOf(listener) !== -1) {
            return true;
        }

        return false;
    },


    /**
     * @param {(string)} type
     * @param {function} listener
     */
    removeEventListener : function(type, listener)
    {
        if (!type) return;
        if ( this.listeners === undefined ) this.listeners = {};

        if (this.listeners[type] instanceof Array){
            var li = this.listeners[type];
            for (var i=0, len=li.length; i < len; i++){
                if (li[i] === listener){
                    li.splice(i, 1);
                    break;
                }
            }
        }
    },


    /**
     * @param {(string | type)} event
     */
    dispatchEvent : function(event)
    {
		if ( this.listeners === undefined ) this.listeners = {};

        if (typeof event == "string"){
            event = { type: event };
        }
        if (!event.target){
            try {
                event.target = this;
            } catch (e) {}
        }

        if (!event.type){
            throw new Error("event type unknown.");
        }

        if (this.listeners[event.type] instanceof Array) {
            var typeListeners = this.listeners[event.type].slice();
            for (var i=0; i < typeListeners.length; i++) {
                    typeListeners[i].call(this, event);
            }
        }
    }

};

// Legacy event routine needs to be deprecated.
av.EventDispatcher.prototype.fireEvent = av.EventDispatcher.prototype.dispatchEvent; 

})();

(function(){ 'use strict';

var avp = Autodesk.Viewing.Private;
var _supported = isLocalStorageSupported();

/**
 * Helper function that detects whether localStorage is available.
 * @private
 */
function isLocalStorageSupported() {
    if (typeof window === "undefined")
        return false;

    try {
        var TEST_KEY = 'lmv_viewer_test_localStorage';
        var storage = window.localStorage; // This may assert if browsers disallow sites from setting data.
        if (!storage)
            return false;

        storage.setItem(TEST_KEY, '1');
        storage.removeItem(TEST_KEY);
        return true;

    } catch (error) {
        return false;
    }
}

function LocalStorage() {
    // nothing //
}

/**
 * Get an item from localStorage.
 * Returns null localStorage is not available.
 */
LocalStorage.prototype.getItem = function(key) {
    if (!_supported) return null;
    return window.localStorage.getItem(key);
};

/**
 * Set an item into localStorage.
 * Does nothing if localStorage is not available OR if
 * the max quota is exceeded.
 */
LocalStorage.prototype.setItem = function(key, value) {
    if (!_supported) return;
    try {
        window.localStorage.setItem(key, value);
    } catch (eee) {
        avp.logger.debug('avp.LocalStorage: Failed to setItem()');
    }
};

/**
 * Removes an item from localStorage.
 * Does nothing if localStorage is not available.
 */
LocalStorage.prototype.removeItem = function(key) {
    if (!_supported) return;
    window.localStorage.removeItem(key);
};

/**
 * Returns true is localStorage is supported.
 */
LocalStorage.prototype.isSupported = function() {
    return _supported;
};

/**
 * Global instance for interacting with localStorage.
 */
Autodesk.Viewing.Private.LocalStorage = new LocalStorage();

})();


/**
 * Base class for file loaders.
 *
 * It is highly recommended that file loaders use worker threads to perform the actual loading in order to keep the
 * UI thread free. Once loading is complete, the loader should call viewer.impl.onLoadComplete(). During loading,
 * the loader can use viewer.impl.signalProgress(int) to indicate how far along the process is.
 *
 * To add geometry to the viewer, `viewer.impl.addMeshInstance(geometry, meshId, materialId, matrix)` should be used.
 * Geometry must be THREE.BufferGeometry, meshId is a number, materialId is a string, and matrix is the THREE.Matrix4
 * transformation matrix to be applied to the geometry.
 *
 * Remember to add draw calls to the BufferGeometry if the geometry has more than 65535 faces.
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer - The viewer instance.
 * @constructor
 * @abstract
 * @category Core
 */
Autodesk.Viewing.FileLoader = function(viewer) {
    this.viewer = viewer;
};

Autodesk.Viewing.FileLoader.prototype.constructor = Autodesk.Viewing.FileLoader;

/**
 * Initiates the loading of a file from the given URL.
 *
 * This method must be overridden.
 *
 * @param {string} url - The url for the file.
 * @param {object=} options - An optional dictionary of options.
 * @param {string=} options.ids - A list of object id to load.
 * @param {string=} options.sharedPropertyDbPath - Optional path to shared property database.
 * @param {function=} onSuccess - Callback function when the file begins loading successfully. Takes no arguments.
 * @param {function=} onError - Callback function when an error occurs. Passed an integer error code and a string description of the error.
 */
Autodesk.Viewing.FileLoader.prototype.loadFile = function(url, options, onSuccess, onError) {
    return false;
};

/**
 * Returns true only for a 3D models FileLoader implementation.
 */
Autodesk.Viewing.FileLoader.prototype.is3d = function() {
	return false;
};

(function() {

"use strict";

/**
 * The FileLoaderManager manages a set of file loaders available to the viewer.
 * Register, retrieve, and unregister your file loaders using the singleton theFileLoader.
 *
 * @constructor
 */
var FileLoaderManager = function () {
    var fileLoaders = {};

    /**
     * Registers a new file loader with the given id.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @param {String[]} fileExtensions - The array of supported file extensions. Ex: ['stl', 'obj']
     * @param {Function} fileLoaderClass - The file loader constructor.
     * @returns {Boolean} - True if the file loader was successfully registered.
     */
    function registerFileLoader(fileLoaderId, fileExtensions, fileLoaderClass) {
        if (!fileLoaders[fileLoaderId]) {
            fileLoaders[fileLoaderId] = {
                loader: fileLoaderClass,
                extensions: fileExtensions
            };
            return true;
        }
        return false;
    }

    /**
     * Returns the file loader for a given ID.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @returns {Function?} - The file loader constructor if one was registered; null otherwise.
     */
    function getFileLoader(fileLoaderId) {
        if (fileLoaders[fileLoaderId]) {
            return fileLoaders[fileLoaderId].loader;
        }
        return null;
    }

    /**
     * Unregisters an existing file loader with the given id.
     *
     * @param {String} fileLoaderId - The string id of the file loader.
     * @returns {Boolean} - True if the file loader was successfully unregistered.
     */
    function unregisterFileLoader(fileLoaderId) {
        if (fileLoaders[fileLoaderId]) {
            delete fileLoaders[fileLoaderId];
            return true;
        }
        return false;
    }

    /**
     * Returns a file loader that supports the given extension.
     *
     * @param {String} fileExtension - The file extension.
     *
     * @returns {Function?} - The file loader constructor if one is found; null otherwise.
     */
    function getFileLoaderForExtension(fileExtension) {
        fileExtension = fileExtension ? fileExtension.toLowerCase() : "";
        for (var fileLoaderId in fileLoaders) {
            var fileLoader = fileLoaders[fileLoaderId];
            if (fileLoader) {
                for (var i = 0; i < fileLoader.extensions.length; i++) {
                    if (fileLoader.extensions[i].toLowerCase() === fileExtension) {
                        return fileLoader.loader;
                    }
                }
            }
        }

        return null;
    }

    return {
        registerFileLoader: registerFileLoader,
        getFileLoader: getFileLoader,
        getFileLoaderForExtension: getFileLoaderForExtension,
        unregisterFileLoader: unregisterFileLoader
    };
};

var av = Autodesk.Viewing;
av.FileLoaderManager = new FileLoaderManager();

})();

(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.config = {
      userName : ""
    };

    avp.setUserName = function(name) {
      avp.config.userName = name;
    };

    var myio; //delay initialized pointer to socket.io library

    /** @constructor
     *
     *  MessageClient
     *  Constructs a message client object, used for server-mediate publish/subscribe
     *  message passing between connected users.
     *
     */
    function MessageClient(serverUrls, serverPath) {

        //Maps web socket commands to event types
        var MESSAGE_MAP = {
            "camera" :      "cameraChange",
            "pointer":      "pointerMove",
            "joystick" :    "joystick",
            "state" :       "viewerState",
            "txt":          "chatReceived",
            "joinok" :      "userListChange",
            "sessionId" :   "connectSucceeded",
            "joined" :      "userListChange",
            "left" :        "userListChange",
            "private" :     "privateMessage",
            "join_error":   "socketError"
        };


        var _socket;
        var _myID = null;

        var _serverURL = Array.isArray(serverUrls) ? serverUrls : [serverUrls];
        var _currentServer = 0;
        
        var _pendingJoins = {};

        var _channels = {
        };

        var _this = this;

        function getUserName() {
            if (avp.config.userName && avp.config.userName.length)
                return avp.config.userName;

            if (_myID)
                return _myID.slice(0,5);

            return "Unknown";
        }



        function onRecv(msg) {

            //See if the message requires internal processing
            switch(msg.type) {

				case "txt":     onChat(msg);
								break;

				case "joinok":  onJoinOK(msg);
								break;
								
				case "join_error": break;

				case "sessionId":
                                avp.logger.info("Connect successful, your id is: " + msg.id);
								_myID = msg.id;
								break;

				case "joined":  msg.userStatus = "joined";
                                onJoined(msg);
                                break;
                case "left":    msg.userStatus = "left";
                                onLeft(msg);
                                break;
                case "camera":
                case "pointer": break;
                default: avp.logger.log(msg);
                        break;
            }

            //Determine what channel we are receiving the event on.
            //For example, a user list change can occur on either the collaboration channel (users in current session)
            //or on the presence channel (all users logged in), and the various GUI event handlers have to make decisions based
            //on that.
            var channelId = msg.roomId;

            //And send it to all listeners
            var evt = { type: MESSAGE_MAP[msg.type], data:msg, channelId:channelId };
            _this.dispatchEvent(evt);
        }

        function onJoined(evt) {
            if (!evt.user.name || !evt.user.name.length)
                evt.user.name = evt.user.id.slice(0,5);

            if (evt.roomId) {
                var channel = _channels[evt.roomId];
                if (channel) {
                    channel.users.push(evt.user);
                    avp.logger.info(evt.user + " joined room " + evt.roomId);
                } else {
                    avp.logger.warn("Channel " + evt.roomId + " does not exist for socket " + _myID);
                }
            }
        }

        function onLeft(evt) {
            avp.logger.info(evt.user + " left room " + evt.room);
            for (var channelId in _channels) {
                var users = _channels[channelId].users;

                var idx = -1;
                for (var i=0; i<users.length; i++) {
                    if (users[i].id == evt.user) {
                        idx = i;
                        break;
                    }
                }

                if (idx != -1)
                    users.splice(idx, 1);

                delete _channels[channelId].userSet[evt.user];
            }
        }

        function onJoinOK(evt) {

            var channel = _channels[evt.roomId];

            avp.logger.info("joined channel " + evt.roomId);

            if (evt.users && evt.users.length) {
                channel.users = evt.users;
            } else {
                channel.users = [];
            }

            for (var i=0; i<channel.users.length; i++) {

                //Make up a user name if one is not known
                if (!channel.users[i].name || !channel.users[i].name.length) {
                    channel.users[i].name = channel.users[i].id.slice(0,5);
                }
            }

            var name = getUserName();
            var you = Autodesk.Viewing.i18n.translate("you");
            var me = { id:_myID, name: name + " (" + you + ")", isSelf : true, status:0 };
            if (!channel.userSet[_myID]) {
                channel.users.push(me);
                channel.userSet[_myID] = me;
            }

            //In case user name is already known, update the server.
            if (me.id.indexOf(name) != 0) {
                _this.sendChatMessage("/nick " + name, evt.roomId);
            }
        }


        function onChat(evt) {
            if (evt.msg.indexOf("/nick ") == 0) {
                var user = _this.getUserById(evt.from, evt.roomId);
                var newname = evt.msg.slice(6);

                if (newname.length) {
                    user.name = newname;
                    if (user.id == _myID) {
                        var you = Autodesk.Viewing.i18n.translate("you");
                        user.name += " (" + you + ")";
                    }
                }

                _this.dispatchEvent({ type: "userListChange", data: evt, channelId: evt.roomId });
            }
        }
        
        function onConnectError(evt) {

            //Attempt to connect to another server in case
            //the primary fails. If they all fail, then we give up.
            if (_currentServer < _serverURL.length) {
                
                avp.logger.info("Connect failed, trying another server...");
                
                _socket.disconnect();
                _socket = null;
                _currentServer++;
                _this.connect(_this.sessionID);
            
            } else {

                _this.dispatchEvent({ type: "socketError", data: evt });

            }
        }
        
        function onError(evt) {

            _this.dispatchEvent({ type: "socketError", data: evt });

        }
        
        function onConnect(evt) {
            _currentServer = 0;
            
            //Join any channels that were delayed while the
            //connection is established.
            for (var p in _pendingJoins) {
                _this.join(p);
            }
        }

        /**
         * Establish initial connection to the server specified when constructing the message client.
         */
        this.connect = function (sessionID) {

            //TODO: Maintain multiple sockets to the same server, identifier by sessionID.

            if (_socket)
                return; //already connected to socket server.

            if (typeof window.WebSocket !== "undefined") {

                if (!myio)
                    myio = (typeof lmv_io !== "undefined") ? lmv_io : io;

                this.sessionID = sessionID;

                _socket = myio.connect(_serverURL[_currentServer] + "?sessionID=" + sessionID, {path: serverPath, forceNew:true});
                _socket.on("connect", onConnect);
                _socket.on("message", onRecv);
                _socket.on("connect_error", onConnectError);
                _socket.on("error", onError);

                return true;
            }
            else {
                return false;
            }
        };

        /**
         * Subscribe to a messaging channel. Requires connection to be active (i.e. connect() called before join()).
         */
		this.join = function(channelId) {

            if (!_socket || !_socket.connected) {
                _pendingJoins[channelId] = 1;
                return;
            }
            
            delete _pendingJoins[channelId];

            _channels[channelId] = {
                    id : channelId,
                    users: [],
                    userSet: {}
                };

            _socket.emit('join', { roomId : channelId, name : getUserName() });
		};

        /**
         * Disconnect from message server.
         */
        this.disconnect = function () {
            if (_socket) {
                _socket.disconnect();
                //_socket.close();
                _socket = null;
                _channels = {};
                _myID = null;
            }
        };


        /**
         * Send a message of a specific type, containing given data object to a channel.
         * Subscription (listening) to that channel is not required.
         */
        this.sendMessage = function(type, data, channelId) {

            var evt = { type:type, from:_myID, msg: data, roomId: channelId };

            _socket.emit("message", evt);
        };

        /**
         * Send a message object to an individual user.
         */
        this.sendPrivateMessage = function(targetId, msg) {

            var evt = { type: "private", target: targetId, from:_myID, msg: msg };

            _socket.emit("message", evt);
        };

        /**
         * A convenience wrapper of sendMessage to send a simple text chat message to a channel.
         */
        this.sendChatMessage = function(msg, channelId) {

            var evt = { type:"txt", from: _myID, msg: msg, roomId: channelId };

            _socket.emit("message", evt);

            //This is done to handle /nick commands
            onRecv(evt);
        };

        /**
         * Returns the user info object for a given user on a specific channel.
         * User lists are maintained per channel.
         */
        this.getUserById = function(id, channelId) {
            var users = _channels[channelId].users;
            for (var i=0; i<users.length; i++) {
                if (users[i].id == id)
                    return users[i];
            }
            return null;
        };

        /**
         * Returns the local user's (randomly assigned) connection ID. Can be used to
         * maintain hashmaps of users, since it's unique per server.
         */
        this.getLocalId = function() { return _myID; };

        /**
         * Returns a channel's info object.
         */
        this.getChannelInfo = function(channelId) { return _channels[channelId]; };

        this.isConnected = function() { return _socket; };
    };

    MessageClient.prototype.constructor = MessageClient;
    av.EventDispatcher.prototype.apply( MessageClient.prototype );

    var _activeClients = {};

    MessageClient.GetInstance = function(serverUrls, path) {

        if (!serverUrls)
            serverUrls = avp.EnvironmentConfigurations[avp.env].LMV.RTC;

        if (!Array.isArray(serverUrls))
            serverUrls = [serverUrls];
        
        var mc = _activeClients[serverUrls[0]];
        if (mc)
            return mc;

        mc = new avp.MessageClient(serverUrls, path);
        _activeClients[serverUrls[0]] = mc;
        return mc;
    };


    Autodesk.Viewing.Private.MessageClient = MessageClient;

})();

AutodeskNamespace('Autodesk.Viewing.Private');

(function() {

    var av = Autodesk.Viewing,
        avp = av.Private;

    //==================================================================================

    avp.P2PClient = function(signalClient) {

        var _this = this;

        var _signalClient = signalClient;
        var _pc;
        var _isStarted = false;
        var _targetId;
        var _localStream;
        var _remoteStream;

        var _dataChannel;

        var _iceCandidates = [];

        var pc_config = {'iceServers': [{'url': 'stun:stun.l.google.com:19302'}]};

        var pc_constraints = {'optional': [{'DtlsSrtpKeyAgreement': true}]};

        // Set up audio and video regardless of what devices are present.

        var sdpConstraintsAll = {'mandatory': {
          'OfferToReceiveAudio':true,
          'OfferToReceiveVideo':true }
        };

        var sdpConstraintsNone = {'mandatory': {
          'OfferToReceiveAudio':false,
          'OfferToReceiveVideo':false }
        };


        _signalClient.addEventListener("privateMessage", onMessage);



        function createPeerConnection(wantDataChannel) {
          try {

            _pc = new RTCPeerConnection(pc_config);

            _pc.onicecandidate = function(event) {
                  if (event.candidate) {
                    _signalClient.sendPrivateMessage(_targetId, {
                      type: 'candidate',
                      label: event.candidate.sdpMLineIndex,
                      id: event.candidate.sdpMid,
                      candidate: event.candidate.candidate});
                  } else {
                    avp.logger.log('End of candidates.');
                  }
            };

            _pc.ondatachannel = function(event) {
                avp.logger.log('Data channel added.');
                _dataChannel = event.channel;
                _dataChannel.onmessage = onDataMessage;
                _this.dispatchEvent({type:"dataChannelAdded", data:event.channel});
            };

            _pc.onaddstream = function(event) {
                avp.logger.log('Remote stream added.');
                _remoteStream = event.stream;
                _this.dispatchEvent({type:"remoteStreamAdded", data:event.stream});
            };

            _pc.onremovestream = function(event) {
                avp.logger.log('Remote stream removed. Event: ', event);
                _remoteStream = null;
                _this.dispatchEvent({type:"remoteStreamRemoved", data:event.stream});
            };

            if (wantDataChannel) {
                _dataChannel = _pc.createDataChannel("sendDataChannel", {reliable: false, ordered:false});
                _dataChannel.onmessage = onDataMessage;
            }
          } catch (e) {
            avp.logger.error('Failed to create PeerConnection, exception: ' + e.message, av.errorCodeString(av.ErrorCodes.NETWORK_FAILURE));
            alert('Cannot create RTCPeerConnection object.');
              return;
          }
        }


        function handleCreateOfferError(event){
            avp.logger.error('createOffer() error: ', e, av.errorCodeString(av.ErrorCodes.UNKNOWN_FAILURE));
        }

        function setLocalAndSendMessage(sessionDescription) {
            // Set Opus as the preferred codec in SDP if Opus is present.
            //sessionDescription.sdp = preferOpus(sessionDescription.sdp);
            _pc.setLocalDescription(sessionDescription);
            //avp.logger.log('setLocalAndSendMessage sending message' , sessionDescription);
            _signalClient.sendPrivateMessage(_targetId, sessionDescription);

            if (_iceCandidates.length) {
                for  (var i=0; i<_iceCandidates.length; i++)
                    _pc.addIceCandidate(_iceCandidates[i]);
                _iceCandidates = [];
            }
        }
/*
        function requestTurn(turn_url) {
          var turnExists = false;
          for (var i in pc_config.iceServers) {
            if (pc_config.iceServers[i].url.substr(0, 5) === 'turn:') {
              turnExists = true;
              turnReady = true;
              break;
            }
          }
          if (!turnExists) {
            avp.logger.log('Getting TURN server from ', turn_url);
            // No TURN server. Get one from computeengineondemand.appspot.com:
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
              if (xhr.readyState === 4 && xhr.status === 200) {
                var turnServer = JSON.parse(xhr.responseText);
                avp.logger.log('Got TURN server: ', turnServer);
                pc_config.iceServers.push({
                  'url': 'turn:' + turnServer.username + '@' + turnServer.turn,
                  'credential': turnServer.password
                });
                turnReady = true;
              }
            };
            xhr.open('GET', turn_url, true);
            xhr.send();
          }
        }
*/

        this.hangup = function() {
          avp.logger.log('Hanging up.');
          if (_isStarted) {
              _signalClient.sendPrivateMessage(_targetId, 'bye');
              stop();
          }
        };


        this.initUserMedia = function(createConnectionCB) {
            function handleUserMedia(stream) {
                avp.logger.log('Adding local stream.');
                if (createConnectionCB)
                    createConnectionCB(stream);
                _this.dispatchEvent({type:"localStreamAdded", data:stream});
            }

            function handleUserMediaError(error){
                avp.logger.error('getUserMedia error: ', error, av.errorCodeString(av.ErrorCodes.NETWORK_SERVER_ERROR));
            }

            var constraints = {video: true, audio:true};
            window.getUserMedia(constraints, handleUserMedia, handleUserMediaError);

            avp.logger.log('Getting user media with constraints', constraints);
        };

        this.callUser = function(userId, dataOnly) {
            if (_targetId) {
                avp.logger.warn("Already in a call. Ignoring call request.");
                return;
            }

            _targetId = userId;

            avp.logger.info("Calling user " + _targetId);

            if (dataOnly) {
                createPeerConnection(true);

                _isStarted = true;
                avp.logger.log('Sending data channel offer to peer');
                _pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
            }
            else {
                this.initUserMedia(function(stream) {
                    _localStream = stream;
                    if (!_isStarted && typeof _localStream != 'undefined') {
                        createPeerConnection(false);

                        _pc.addStream(_localStream);
                        _isStarted = true;
                        avp.logger.log('Sending audio/video offer to peer');
                        _pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
                    }
                });
            }
        };

        function isSDPDataOnly(sdp) {
            var lines = sdp.split("\n");
            var haveData = false;
            var haveAudio = false;
            var haveVideo = false;
            for (var i=0; i<lines.length; i++) {
                if (lines[i].indexOf("a=mid:data") == 0) {
                    haveData = true;
                }
                if (lines[i].indexOf("a=mid:video") == 0) {
                    haveVideo = true;
                }
                if (lines[i].indexOf("a=mid:audio") == 0) {
                    haveAudio = true;
                }
            }

            return haveData && !haveVideo && !haveAudio;
        }

        this.receiveCall = function(msg) {
            _targetId = msg.from;
            if (!_targetId)
                _targetId = msg.senderId;

            //Check if the caller wants audio/videio
            var sdp = msg.msg.sdp;
            if (isSDPDataOnly(sdp)) {
                createPeerConnection(true);
                _isStarted = true;

                _pc.setRemoteDescription(new RTCSessionDescription(msg.msg));
                avp.logger.log('Sending data-only answer to peer.');
                _pc.createAnswer(setLocalAndSendMessage, null , sdpConstraintsNone);

            } else {
                this.initUserMedia(function(stream) {
                    _localStream = stream;

                    if (!_isStarted && typeof _localStream != 'undefined') {
                        createPeerConnection(false);
                        _pc.addStream(_localStream);
                        _isStarted = true;
                    }

                    _pc.setRemoteDescription(new RTCSessionDescription(msg.msg));
                    avp.logger.log('Sending audio+video answer to peer.');
                    _pc.createAnswer(setLocalAndSendMessage, null , sdpConstraintsAll);
                });
            }
        };

        function onDataMessage(evt) {
            var data = JSON.parse(evt.data);

            switch(data.type) {
                case "camera":                  _this.dispatchEvent({ type: "cameraChange",   data: data}); break;
                case "joystick":                _this.dispatchEvent({ type: "joystick",       data: data}); break;
                case "state":                   _this.dispatchEvent({ type: "viewerState",    data: data}); break;
                default: break;
            }
        }


        function onMessage(evt) {
            var message = evt.data.msg;
            avp.logger.debug('Client received message:' + JSON.stringify(message));
            if (message.type == 'offer' && !_isStarted) {

                avp.logger.log("Received offer. Accepting.");
                _this.receiveCall(evt.data);

            } else if (message.type === 'answer' && _isStarted) {

                _pc.setRemoteDescription(new RTCSessionDescription(message));

            } else if (message.type === 'candidate') {

                var candidate = new RTCIceCandidate({
                sdpMLineIndex: message.label,
                candidate: message.candidate
                });

                //If we receive ICE candidates before the local
                //session is started, we have to hold them in a temp list until
                //we create the answer
                if (_isStarted)
                    _pc.addIceCandidate(candidate);
                else
                    _iceCandidates.push(candidate);

            } else if (message === 'bye' && _isStarted) {

               _this.dispatchEvent({type:"remoteHangup", data:null});
                avp.logger.info('Session terminated.');
               stop();
              // isInitiator = false;

            }
        }

        function stop() {
          _isStarted = false;
          // isAudioMuted = false;
          // isVideoMuted = false;
          _pc.close();
          _pc = null;
          _localStream = null;
          _remoteStream = null;
          _targetId = null;
        }

        this.getCurrentCallTarget = function() { return _targetId; }

        this.dataChannel = function() { return _dataChannel; }
    };

    avp.P2PClient.prototype.constructor = avp.P2PClient;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avp.P2PClient.prototype );

})();

(function(){

    var avp = Autodesk.Viewing.Private;

    Autodesk.Viewing.Private.LiveReviewClient = function (viewer) {

        this.viewer = viewer;
        this.messageClient = null;
        this.presenceChannelId = null;
        this.p2p = null;
        this.viewtx = null;
        this.interceptor = null;
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.destroy = function() {
        this.leaveLiveReviewSession();
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.joinLiveReviewSession = function (sessionId) {

        if (!this.messageClient)
            this.messageClient = avp.MessageClient.GetInstance();
        if (!this.presenceChannelId)
            this.presenceChannelId = window.location.host;
        if (!this.messageClient.isConnected()) {
            this.messageClient.connect(sessionId);
        }

        if (!this.viewtx)
            this.viewtx = new avp.ViewTransceiver(this.messageClient);
        this.viewtx.channelId = sessionId;
        this.viewtx.attach(this.viewer);

        if (!this.p2p)
            this.p2p = new avp.P2PClient(this.messageClient);

        this.messageClient.join(this.viewtx.channelId);

        if (!this.interceptor)
            this.interceptor = new avp.InteractionInterceptor(this.viewtx);
        this.viewer.toolController.registerTool(this.interceptor);
        this.viewer.toolController.activateTool(this.interceptor.getName());
    };

    Autodesk.Viewing.Private.LiveReviewClient.prototype.leaveLiveReviewSession = function () {
        this.p2p && this.p2p.hangup();
        this.viewtx && this.viewtx.detach(this.viewer);
        this.messageClient && this.messageClient.disconnect();
        if (this.interceptor) {
            this.viewer.toolController.deactivateTool(this.interceptor.getName());
        }

        this.p2p = null;
        this.viewtx = null;
        this.messageClient = null;
        this.interceptor = null;
    };




    var av = Autodesk.Viewing,
        avp = av.Private;

    avp.InteractionInterceptor = function(viewtx) {

        this.getNames = function() {
            return ["intercept"];
        };

        this.getName = function() {
            return "intercept";
        };

        this.activate = function(name) { };
        this.deactivate = function(name) { };
        this.update = function(timeStamp) { return false; };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};

        this.handleWheelInput = function(delta) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonDown = function(event, button) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {
            viewtx.updatePointer(event);
            return false;
        };

        this.handleGesture = function(event) {
            viewtx.takeControl();
            return false;
        };

        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};
    };

    avp.ViewTransceiver = function(client) {

        var _this = this;
        var _viewer = this.viewer = null;
        var _blockEvents = false;
        var _haveControl = false;
        var _isDisconnected = false;
        var _lastInControl;
        var _client = this.client = client;
        var _ray = new THREE.Ray();
        var _pointer = null;
        var _pointerOn = false;

        this.channelId = null;

        var _viewerState;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: false,
            cutplanes: true,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };


        function onViewerState(evt) {
            _blockEvents = true;
            var state = JSON.parse(evt.data.msg);
            _viewerState.restoreState(state);
            _viewer.impl.invalidate(true, false, true);
            _blockEvents = false;
        }

        function reduceBits(v) {
            return Math.round(v * 1000) / 1000;
        }

        function reduceBitsV(v) {
            for (var i=0; i< v.length; i++)
                v[i] = reduceBits(v[i]);
        }

        function onCamera(e) {
            var v = e.data.msg;

            if (v[1] === true || _isDisconnected)
            {
                return;
            }

            if (v[0] != _lastInControl)
            {
                _lastInControl = v[0];
                e.data.lastInControl = v[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: e.data });
            }

            //For now, automatically relinquish camera control if we receive a remote command to move the camera
            _haveControl = false;

            /*
             viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
             new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
             _viewer.navigation.getCamera().fov,
             new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
             */

            _viewer.navigation.setView(new THREE.Vector3().set(v[2+0],v[2+1],v[2+2]),
                new THREE.Vector3().set(v[2+3],v[2+4],v[2+5]));
            _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[2+6],v[2+7],v[2+8]));
        }

        function sendCamera(evt) {
            if (!_haveControl && !_isDisconnected)
                return;

            var c = evt.camera;
            var camParams = [ c.position.x, c.position.y, c.position.z,
                c.target.x, c.target.y, c.target.z,
                c.up.x, c.up.y, c.up.z
            ];

            reduceBitsV(camParams);
            camParams.unshift(_isDisconnected);
            camParams.unshift(client.getLocalId());

            _client.sendMessage("camera", camParams, _this.channelId);

            if (_lastInControl != camParams[0]) {
                _lastInControl = camParams[0];
                _this.dispatchEvent({type: "controlChange", channelId: _this.channelId, data: { lastInControl: _lastInControl } });
            }
        }


        function showPointer(show, x, y) {

            if (show && !_pointer) {
                _pointer = document.createElement("div");
                _pointer.classList.add("collabPointer");
            }

            if (show && !_pointerOn) {
                _viewer.container.appendChild(_pointer);
                _pointerOn = true;
            }
            else if (!show && _pointerOn) {
                _viewer.container.removeChild(_pointer);
                _pointerOn = false;
            }

            if (show) {
                //Note the 4px is half the width/height specified in the CSS,
                //so that the pointer is centered.
                _pointer.style.left = (x-6) + "px";
                _pointer.style.top = (y-6) + "px";
            }

        }

        function onPointer(e) {

            if (_haveControl)
                return; //shouldn't get here in theory, but let's check just in case

            if (_isDisconnected)
                return; //we can't show the pointer if the views don't match

            var v = e.data.msg;
            _ray.origin.set(v[1], v[2], v[3]);
            _ray.direction.set(v[4], v[5], v[6]);

            var pt = _ray.at(_viewer.getCamera().near);
            pt.project(_viewer.getCamera());

            pt = _viewer.impl.viewportToClient(pt.x, pt.y);

            //avp.logger.log(pt.x + " " + pt.y);
            showPointer(true, pt.x, pt.y);
        }


        function sendPointer(evt) {
            if (!_haveControl)
                return;

            //Note canvasX/Y are set by the ToolController to clientX/Y - canvas left/top.
            var vpVec = _viewer.impl.clientToViewport(evt.canvasX, evt.canvasY);
            _viewer.impl.viewportToRay(vpVec, _ray);

            var rayParams = [ _ray.origin.x, _ray.origin.y, _ray.origin.z,
                _ray.direction.x, _ray.direction.y, _ray.direction.z ];

            reduceBitsV(rayParams);
            rayParams.unshift(client.getLocalId());

            _client.sendMessage("pointer", rayParams, _this.channelId);
        }


        function sendViewerState(e) {
            //if (!_haveControl)
            //    return;
            if (_blockEvents)
                return;

            var state = _viewerState.getState(VIEWER_STATE_FILTER);

            // TODO: if we kill the socket.io code path, this could be optimized
            // too by removing the JSON.stringify of the state. Pubnub automatically
            // does JSON serialization for us, with optimizations accordingly to their manual.
            client.sendMessage("state", JSON.stringify(state), _this.channelId);
        }


        this.takeControl = function() {
            _haveControl = true;
            showPointer(false);
        };

        this.updatePointer = function(e) {
            sendPointer(e);
        };

        this.connectCamera = function(set) {
            _isDisconnected = !set;
        };

        this.attach = function(viewer, skipStateTracking) {

            if (_viewer)
                this.detach();

            this.viewer = _viewer = viewer;
            _viewerState = new avp.ViewerState(_viewer);

            _client.addEventListener("cameraChange", onCamera);
            _client.addEventListener("pointerMove", onPointer);

            if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
                _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

            if (!skipStateTracking) {
                _client.addEventListener("viewerState", onViewerState);

                if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
                    _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                    _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
                    _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
                    _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
                    _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                    _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                    _viewer.addEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);
                }
            }
        };


        this.detach = function() {

            showPointer(false);

            if (_client) {
                _client.removeEventListener("cameraChange", onCamera);
                _client.removeEventListener("viewerState", onViewerState);
            }

            if (_viewer) {
                _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

                _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);

                this.viewer = _viewer = null;
                _viewerState = null;
            }
        };

    };

    avp.ViewTransceiver.prototype.constructor = avp.ViewTransceiver;
    Autodesk.Viewing.EventDispatcher.prototype.apply( avp.ViewTransceiver.prototype );


})();

!function(e){/*if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else*/{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.lmv_poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.5"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;



},{}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":11}],5:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":11}],6:[function(_dereq_,module,exports){
(function (global){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/**
 * Public API for poly2tri.js
 * @module poly2tri
 */


/**
 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
 * @name poly2tri
 * @global
 * @public
 * @type {module:poly2tri}
 */
var previousPoly2tri = global.poly2tri;
/**
 * For Browser + &lt;script&gt; :
 * reverts the {@linkcode poly2tri} global object to its previous value,
 * and returns a reference to the instance called.
 *
 * @example
 *              var p = poly2tri.noConflict();
 * @public
 * @return {module:poly2tri} instance called
 */
// (this feature is not automatically provided by browserify).
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

/**
 * poly2tri library version
 * @public
 * @const {string}
 */
exports.VERSION = _dereq_('../dist/version.json').version;

/**
 * Exports the {@linkcode PointError} class.
 * @public
 * @typedef {PointError} module:poly2tri.PointError
 * @function
 */
exports.PointError = _dereq_('./pointerror');
/**
 * Exports the {@linkcode Point} class.
 * @public
 * @typedef {Point} module:poly2tri.Point
 * @function
 */
exports.Point = _dereq_('./point');
/**
 * Exports the {@linkcode Triangle} class.
 * @public
 * @typedef {Triangle} module:poly2tri.Triangle
 * @function
 */
exports.Triangle = _dereq_('./triangle');
/**
 * Exports the {@linkcode SweepContext} class.
 * @public
 * @typedef {SweepContext} module:poly2tri.SweepContext
 * @function
 */
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
/**
 * @function
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 */
exports.triangulate = sweep.triangulate;
/**
 * @deprecated use {@linkcode SweepContext#triangulate} instead
 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
 */
exports.sweep = {Triangulate: sweep.triangulate};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";

/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = _dereq_('./assert');
var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline, isOpen) {
    var i, len = polyline.length, iEnd = isOpen ? polyline.length-1 : polyline.length;
    for (i = 0; i < iEnd; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":11}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;


},{}],11:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[6])
(6)
});
/**
 * Created by stanevt on 5/8/2015.
 */
function init_three_triangulator() {

"use strict";

if (Autodesk.Viewing.Private.Triangulator)
    return;

Autodesk.Viewing.Private.Triangulator = (function() {

    var avp = Autodesk.Viewing.Private;

    var TOL = 1e-10;

    function isZero(f) {
        return Math.abs(f) < TOL;
    }
    
    function isEqual(a, b) {
        return isZero(a - b);
    }


    function makePointId(idFrom, idTo, meshId) {
        var tmp = idFrom < idTo ? (idFrom + ":" + idTo) : (idTo + ":" + idFrom);
        return meshId + ":" + tmp;
    }

    function Edge(pt1, pt2, id1From, id1To, id2From, id2To, meshId) {

        this.pt1 = pt1;
        this.pt2 = pt2;

        this.p1 = -1;
        this.p2 = -1;

        //Use the triangle edges that created the two planar edge points
        //as IDs for those points.
        this.eid1 = makePointId(id1From, id1To, meshId);
        this.eid2 = makePointId(id2From, id2To, meshId);
    }


    function IntervalNode() {
        
        this.bbox = new THREE.Box2();
        this.left = null;
        this.right = null;
        this.node_edges = [];
    }

    //Acceleration structure for point-in-polygon checking
    function IntervalTree(pts, edges, bbox) {

        this.pts = pts;
        this.edges = edges;
        this.bbox = bbox;
        this.pipResult = false;

    }
    


    IntervalTree.prototype.splitNode = function(node) {
    
        if (node.bbox.min.y >= node.bbox.max.y)
            return;
            
        if (node.node_edges.length < 3)
            return;
    
        var split = 0.5 * (node.bbox.min.y + node.bbox.max.y);
        
        //node.bbox.makeEmpty();

        node.left = new IntervalNode();
        node.right = new IntervalNode();
        
        var pts = this.pts;
        var ne = node.node_edges;
        var remaining_node_edges = [];
        var tmpPt = new THREE.Vector2();
        
        for (var i=0; i<ne.length; i++) {

            var e = this.edges[ne[i]];

            var p1y = pts[e.p1].y;
            var p2y = pts[e.p2].y;

            if (p1y > p2y) {
                var tmp = p1y;
                p1y = p2y;
                p2y = tmp;
            }
            
            var boxPtr = null;
            
            if (p2y < split) {
                node.left.node_edges.push(ne[i]);
                boxPtr = node.left.bbox;
            } else if (p1y > split) {
                node.right.node_edges.push(ne[i]);
                boxPtr = node.right.bbox;
            } else {
                remaining_node_edges.push(ne[i]);
                //boxPtr = node.bbox;
            }
            
            if (boxPtr) {
                tmpPt.set(pts[e.p1].x, pts[e.p1].y);
                boxPtr.expandByPoint(tmpPt);
                tmpPt.set(pts[e.p2].x, pts[e.p2].y);
                boxPtr.expandByPoint(tmpPt);
            }
        }
        
        node.node_edges = remaining_node_edges;
        
        if (node.left.node_edges.length)
            this.splitNode(node.left);
        if (node.right.node_edges.length)
            this.splitNode(node.right);
    };
    

    IntervalTree.prototype.build = function() {

        this.root = new IntervalNode();

        var edge_indices = this.root.node_edges;
        for (var i=0; i<this.edges.length; i++)
            edge_indices.push(i);

        this.root.bbox.copy(this.bbox);

        //split recursively
        this.splitNode(this.root);
    };




    IntervalTree.prototype.pointInPolygonRec = function(node, x, y) {
    
        if (node.bbox.min.y <= y && node.bbox.max.y >= y) {
        
            var pts = this.pts;
            var ne = node.node_edges;
        
            for (var i=0, iEnd=ne.length; i<iEnd; i++) {
            
                var e = this.edges[ne[i]];

                // get the last point in the polygon
                var p1 = pts[e.p1];
                var vtx0X = p1.x;
                var vtx0Y = p1.y;

                // get test bit for above/below X axis
                var yflag0 = (vtx0Y >= y);

                var p2 = pts[e.p2];
                var vtx1X = p2.x;
                var vtx1Y = p2.y;

                var yflag1 = (vtx1Y >= y);

                // Check if endpoints straddle (are on opposite sides) of X axis
                // (i.e. the Y's differ); if so, +X ray could intersect this edge.
                // The old test also checked whether the endpoints are both to the
                // right or to the left of the test point.  However, given the faster
                // intersection point computation used below, this test was found to
                // be a break-even proposition for most polygons and a loser for
                // triangles (where 50% or more of the edges which survive this test
                // will cross quadrants and so have to have the X intersection computed
                // anyway).  I credit Joseph Samosky with inspiring me to try dropping
                // the "both left or both right" part of my code.
                if (yflag0 != yflag1)
                {
                    // Check intersection of pgon segment with +X ray.
                    // Note if >= point's X; if so, the ray hits it.
                    // The division operation is avoided for the ">=" test by checking
                    // the sign of the first vertex wrto the test point; idea inspired
                    // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                    // polygon inclusion tests.
                    if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                            (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                    {
                        this.pipResult = !this.pipResult;
                    }
                }

            }
        
        }
        
        var nl = node.left;
        if (nl && nl.bbox.min.y <= y && nl.bbox.max.y >= y) {
            this.pointInPolygonRec(nl, x, y);
        }
        
        var nr = node.right;
        if (nr && nr.bbox.min.y <= y && nr.bbox.max.y >= y) {
            this.pointInPolygonRec(nr, x, y);
        }

    };
    
    IntervalTree.prototype.pointInPolygon = function(x, y) {
    
          this.pipResult = false;
          
          this.pointInPolygonRec(this.root, x, y);
          
          return this.pipResult;
    
    };



    
    //Functionality for converting a list of two point segments into a connected
    //set of (hopefully) closed contour lines. The contour set is then used
    //for triangulation
    function ContourSet(edges, bbox) {
    
        this.edges = edges;
        this.bbox = bbox;
    
        this.pts = [];
        this.idmap = {};
        this.xymap = {};
        this.contours = [];

        this.scale = (1e6) / this.bbox.size().length();
    }
    
    
    
    ContourSet.prototype.getPointIndex = function(px, py, eid) {
        var findByEdgeId = this.idmap[eid];
        if (findByEdgeId !== undefined) {
            return findByEdgeId;
        }
/*
        findByEdgeId = this.idmap[eid] = this.pts.length;
        pts.push({x: px, y: py, id: eid});
        return findByEdgeId;
*/

        var x = 0 | (px * this.scale);
        var y = 0 | (py * this.scale);

        var mx = this.xymap[x];
        var my;

        if (mx === undefined) {
            this.xymap[x] = mx = {};
            my = undefined;
        } else {
            my = mx[y];
        }

        if (my === undefined) {
            mx[y] = my = this.pts.length;
            this.idmap[eid] = my;
            this.pts.push({x: px, y: py /*, id : eid*/});
        }

        return my;
    };
    
    ContourSet.prototype.snapEdges = function() {
        
        for (var i=0; i<this.edges.length; i++) {

            var e = this.edges[i];

            e.p1 = this.getPointIndex(e.pt1.x, e.pt1.y, e.eid1);
            e.p2 = this.getPointIndex(e.pt2.x, e.pt2.y, e.eid2);
        }
    };

    ContourSet.prototype.sanitizeEdges = function() {
        var edgeSet = {};
        var sanitizedEdges = [];

        for (var i = 0, len = this.edges.length; i < len; i++) {
            var e = this.edges[i];
            if (e.p1 === e.p2) {
                continue;
            }

            var key = Math.min(e.p1, e.p2) + ':' + Math.max(e.p1, e.p2);
            if (edgeSet[key] !== true) {
                edgeSet[key] = true;
                sanitizedEdges.push(e);
            }
        }

        this.edges = sanitizedEdges;
    };

    ContourSet.prototype.stitchContours = function() {
        
        //Create jump table from edge to edge
        //and back
        var edge_table = {};
        
        for (var i=0; i<this.edges.length; i++) {
            var e = this.edges[i];
            
            if (e.p1 === e.p2)
                continue;
            
            if (edge_table[e.p1] !== undefined)
                edge_table[e.p1].push(e.p2);
            else                
                edge_table[e.p1] = [e.p2];
            
            if (edge_table[e.p2] !== undefined)
                edge_table[e.p2].push(e.p1);
            else
                edge_table[e.p2] = [e.p1];
        }
        
        var cur_cntr = [];
        
        for (var p in edge_table) {
            if (edge_table[p].length !== 2) {
                avp.logger.warn("Incomplete edge table");
                break;
            }
        }
        
        //Start with the first edge, and stitch until we can no longer
        while (true) {
        
            var sfrom = undefined;
        
            //Look for doubly connected point first
            for (var p in edge_table) {
                if (edge_table[p].length > 1) {
                    sfrom = p;
                    break;
                }
            }

            //If no double-connected point found, we know
            //the it will be an open contour, but stitch as much 
            //as we can anyway.
            if (!sfrom) {            
                for (var p in edge_table) {
                    if (edge_table[p].length > 0) {
                        sfrom = p;
                        break;
                    }
                }
            }

            if (!sfrom)
                break;

            var prev = -1;
            var cur = parseInt(sfrom);
            var cur_segs = edge_table[sfrom];

            //start a new contour
            cur_cntr.push(cur);

            while (cur_segs && cur_segs.length) {
                
                var toPt = cur_segs.shift();
                
                //skip backpointer if we hit it
                if (toPt === prev)
                    toPt = cur_segs.shift();

                if (toPt === undefined) {
                    delete edge_table[cur];
                    break;
                }
                        
                cur_cntr.push(toPt);
                
                if (cur_segs.length == 0)
                    delete edge_table[cur];
                else if (cur_segs[0] === prev)
                    delete edge_table[cur];
                
                prev = cur;
                cur = toPt;
                cur_segs = edge_table[toPt];
            }
            
            if (cur_cntr.length) {
                this.contours.push(cur_cntr);
                cur_cntr = [];
            }
        }

        var openCntrs = [];
        for (var i=0; i<this.contours.length; i++) {
            var cntr = this.contours[i];
            if (cntr[0] !== cntr[cntr.length-1])
                openCntrs.push(cntr);
        }


        if (openCntrs.length) {
            //avp.logger.warn("Incomplete stitch");
            
            var didSomething = true;
            while (didSomething) {
                
                didSomething = false;

                //Try to combine contours
                var cntr_edge_table = {};
                var contours = this.contours;
                
                for (var i=0; i<contours.length; i++) {
                    var cntr = contours[i];
                    var start = cntr[0];
                    var end = cntr[cntr.length-1];
                    
                    if (start === end)
                        continue;
                    
                    if (!cntr_edge_table[start])
                        cntr_edge_table[start] = [-i-1];
                    else
                        cntr_edge_table[start].push(-i-1);
                        
                    
                    if (!cntr_edge_table[end])
                        cntr_edge_table[end] = [i];
                    else
                        cntr_edge_table[end].push(i);
                }

                for (var p in cntr_edge_table) {
                    var entry = cntr_edge_table[p];

                    if (entry.length == 2) {
                        var toerase = undefined;

                        if (entry[0] < 0 && entry[1] < 0) {
                            var c1 = -entry[0]-1; var c2 = -entry[1]-1;
                            //join start point to startpoint
                            contours[c2].shift();
                            Array.prototype.push.apply(contours[c1].reverse(),contours[c2]);
                            toerase = c2;
                        }

                        if (entry[0] < 0 && entry[1] > 0) {
                            var c1 = -entry[0]-1; var c2 = entry[1];
                            //join start point to endpoint
                            contours[c2].pop();
                            Array.prototype.push.apply(contours[c2], contours[c1]);
                            toerase = c1;
                        }

                        if (entry[0] > 0 && entry[1] < 0) {
                            var c1 = entry[0]; var c2 = -entry[1]-1;
                            //join end point to startpoint
                            contours[c1].pop();
                            Array.prototype.push.apply(contours[c1], contours[c2]);
                            toerase = c2;
                        }

                        if (entry[0] > 0 && entry[1] > 0) {
                            var c1 = entry[0]; var c2 = entry[1];
                            //join end point to endpoint
                            contours[c1].pop();
                            Array.prototype.push.apply(contours[c1], contours[c2].reverse());
                            toerase = c2;
                        }
                        
                        if (toerase !== undefined) {
                            contours.splice(toerase, 1);
                            didSomething = true;
                        }
                        break;
                    }
                }

            }
            
        }


    };




    

    function TriangulatedSurface(cset) {

        this.indices = [];

        this.cset = cset;
        var _pts = this.pts = cset.pts;
        
        this.intervalTree = new IntervalTree(cset.pts, cset.edges, cset.bbox);
        this.intervalTree.build();


        for (var i=0; i<_pts.length; i++) {
            _pts[i].id = i;
        }
        
        var sweepCtx = new lmv_poly2tri.SweepContext([]);
        
        sweepCtx.points_  = _pts.slice();



        if (cset.contours) {
        
            var contours = this.cset.contours;
            
            for (var j=0; j<contours.length; j++) {
            
                var cntr = contours[j];
                
                //Contour is not closed
                var isOpen = (cntr[0] !== cntr[cntr.length-1]);
                
                //if (isOpen)
                //    continue;
                
                var edge = [];
                
                for (var k=0; k<cntr.length-1; k++) {
                    edge.push(_pts[cntr[k]]);
                }
                
                sweepCtx.initEdges(edge, isOpen);
            }

        } else {
        
            var edges = this.cset.edges;
        
            for (var i=0; i<edges.length; i++) {
                
                var e = edges[i];
                
                if (e.p1 == e.p2)
                    continue;
                
                var triedge = [_pts[e.p1], _pts[e.p2]];
                sweepCtx.initEdges(triedge, true);
            }
            
        }
        
        this.triangulate(sweepCtx);
        this.processResult(sweepCtx);
    }
    
    
    TriangulatedSurface.prototype.triangulate = function(sweepCtx) {
    
        try {
            sweepCtx.triangulate();
        } catch (e) {
        }
    };
    
    
    TriangulatedSurface.prototype.processResult = function(sweepCtx) {
        for (var i=0; i<sweepCtx.map_.length; i++) {
            var t = sweepCtx.map_[i];
            var p0 = t.points_[0];
            var p1 = t.points_[1];
            var p2 = t.points_[2];

            if (p0.id !== undefined && p1.id !== undefined && p2.id !== undefined)
                this.filterFace(p0.id, p1.id, p2.id);

        }
    };
    
    
    
    TriangulatedSurface.prototype.pointInEdgeList = function(x, y) {
        var yflag0, yflag1;
        var vtx0X, vtx0Y, vtx1X, vtx1Y;

        var pts = this.cset.pts;
        var edges = this.cset.edges;

        var inside_flag = false;


        for (var j= 0, jEnd = edges.length; j<jEnd; ++j)
        {
            var e = edges[j];

            // get the last point in the polygon
            vtx0X = pts[e.p1].x;
            vtx0Y = pts[e.p1].y;

            // get test bit for above/below X axis
            yflag0 = (vtx0Y >= y);


            vtx1X = pts[e.p2].x;
            vtx1Y = pts[e.p2].y;

            yflag1 = (vtx1Y >= y);

            // Check if endpoints straddle (are on opposite sides) of X axis
            // (i.e. the Y's differ); if so, +X ray could intersect this edge.
            // The old test also checked whether the endpoints are both to the
            // right or to the left of the test point.  However, given the faster
            // intersection point computation used below, this test was found to
            // be a break-even proposition for most polygons and a loser for
            // triangles (where 50% or more of the edges which survive this test
            // will cross quadrants and so have to have the X intersection computed
            // anyway).  I credit Joseph Samosky with inspiring me to try dropping
            // the "both left or both right" part of my code.
            if (yflag0 != yflag1)
            {
                // Check intersection of pgon segment with +X ray.
                // Note if >= point's X; if so, the ray hits it.
                // The division operation is avoided for the ">=" test by checking
                // the sign of the first vertex wrto the test point; idea inspired
                // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                // polygon inclusion tests.
                if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                        (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                {
                    inside_flag = !inside_flag;
                }
            }
        }

        return inside_flag;
    };

    
    
    TriangulatedSurface.prototype.pointInContour = function(x, y, cntr) {
        var yflag0, yflag1;
        var vtx0X, vtx0Y, vtx1X, vtx1Y;

        var inside_flag = false;
        
        var pts = this.cset.pts;

        // get the last point in the polygon
        vtx0X = pts[cntr[cntr.length-1]].x;
        vtx0Y = pts[cntr[cntr.length-1]].y;

        // get test bit for above/below X axis
        yflag0 = (vtx0Y >= y);

        for (var j= 0, jEnd=cntr.length; j<jEnd; ++j)
        {
            vtx1X = pts[cntr[j]].x;
            vtx1Y = pts[cntr[j]].y;

            yflag1 = (vtx1Y >= y);

            // Check if endpoints straddle (are on opposite sides) of X axis
            // (i.e. the Y's differ); if so, +X ray could intersect this edge.
            // The old test also checked whether the endpoints are both to the
            // right or to the left of the test point.  However, given the faster
            // intersection point computation used below, this test was found to
            // be a break-even proposition for most polygons and a loser for
            // triangles (where 50% or more of the edges which survive this test
            // will cross quadrants and so have to have the X intersection computed
            // anyway).  I credit Joseph Samosky with inspiring me to try dropping
            // the "both left or both right" part of my code.
            if (yflag0 != yflag1)
            {
                // Check intersection of pgon segment with +X ray.
                // Note if >= point's X; if so, the ray hits it.
                // The division operation is avoided for the ">=" test by checking
                // the sign of the first vertex wrto the test point; idea inspired
                // by Joseph Samosky's and Mark Haigh-Hutchinson's different
                // polygon inclusion tests.
                if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                        (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
                {
                    inside_flag = !inside_flag;
                }
            }

            // move to the next pair of vertices, retaining info as possible
            yflag0 = yflag1;
            vtx0X = vtx1X;
            vtx0Y = vtx1Y;
        }

        return inside_flag;
    };


    TriangulatedSurface.prototype.pointInPolygon = function(x, y) {
        var inside = false;

        for (var i=0; i<this.cset.contours.length; i++) {

            if (this.pointInContour(x, y, this.cset.contours[i]))
                inside = !inside;
        }

        return inside;
    };

    
    TriangulatedSurface.prototype.filterFace = function(i0, i1, i2) {

        var p0 = this.pts[i0];
        var p1 = this.pts[i1];
        var p2 = this.pts[i2];

        var cx = (p0.x + p1.x + p2.x) / 3;
        var cy = (p0.y + p1.y + p2.y) / 3;

        if (this.intervalTree.pointInPolygon(cx, cy)) {
       // if (this.pointInEdgeList(cx, cy)) {
       // if (pointInPolygon(cx, cy)) {

            var e1x = p1.x - p0.x;
            var e1y = p1.y - p0.y;
            var e2x = p2.x - p0.x;
            var e2y = p2.y - p0.y;

            var cross = e1x * e2y - e2x * e1y;

            if (cross > 0) {
                this.indices.push(i0, i1, i2);
            } else {
                this.indices.push(i0, i2, i1);
            }

        }
    };
    
    


    return {

        TriangulatedSurface : TriangulatedSurface,
        ContourSet : ContourSet,
        Edge: Edge

    };


})();

}


function init_three_intersector() {

"use strict";

if (Autodesk.Viewing.Private.Intersector)
    return;

Autodesk.Viewing.Private.Intersector = (function() {

    var avp = Autodesk.Viewing.Private;

    var TOL = 1e-10;
    var Edge = Autodesk.Viewing.Private.Triangulator.Edge;

    function isZero(f) {
        return Math.abs(f) < TOL;
    }

    function isEqual(a, b) {
        return isZero(a - b);
    }


	var v1 = new THREE.Vector3();

    function xPlaneSegment(plane, pt0, pt1, res1, res2) {

        var direction = v1.subVectors(pt1, pt0);

        var denominator = plane.normal.dot( direction );

        if ( isZero(denominator) ) {

            res1.copy(pt0);
            res2.copy(pt1);

            // line is coplanar
            return 2;
        }
        
        denominator = 1.0 / denominator;

        var t = - ( pt0.dot( plane.normal ) * denominator + plane.constant * denominator);

        if ( t < -TOL || t > 1 + TOL ) {

            return 0;

        }

        var pt = direction.multiplyScalar( t ).add( pt0 );

        res1.copy(pt);

        return 1;
    }


    var res1 = new THREE.Vector3();
    var res2 = new THREE.Vector3();

    // res is array containing result segments.
    // returns number of intersection point on the plane (0, 1, or 2) with the values of the points stored in the res array
    function xTrianglePlane(plane, pt0, pt1, pt2, i0, i1, i2, res, meshId) {

        var d0 = plane.distanceToPoint(pt0);
        var d1 = plane.distanceToPoint(pt1);
        var d2 = plane.distanceToPoint(pt2);

        // Check if all points are to one side of the plane
        if (d0 < -TOL && d1 < -TOL && d2 < -TOL) {
            return null;
        }
        if (d0 > TOL && d1 > TOL && d2 > TOL) {
            return null;
        }

        var s0 = Math.sign(d0);
        var s1 = Math.sign(d1);
        var s2 = Math.sign(d2);

        // Skip coplanar triangles (leave it to the neighbouring triangles to contribute their edges)
        if (s0 === 0 && s1 === 0 && s2 === 0) {
            return null;
        }

        var tmp1, tmp2;
        var i1From, i1To, i2From, i2To;

        //There is intersection, compute it
        if (s0 !== s1) {
            var numInts = xPlaneSegment(plane, pt0, pt1, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt0.clone(), pt1.clone(), i0, i0, i1, i1, meshId));
                return;
            } else if (numInts == 1) {
                i1From = i0; 
                i1To = i1;
                tmp1 = res1.clone();
            } else {
                avp.logger.warn("Unexpected zero intersections where at least one was expected");
            }
        }

        if (s1 !== s2) {
            var numInts = xPlaneSegment(plane, pt1, pt2, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt1.clone(), pt2.clone(), i1, i1, i2, i2, meshId));
                return;
            } else if (numInts == 1) {
                if (tmp1) {
                    // Avoid the singular scenario where the signs are 0, -1 and +1
                    if (res1.distanceTo(tmp1) > TOL) {
                        i2From = i1;
                        i2To = i2;    
                        tmp2 = res1.clone();
                    }
                }
                else {
                    i1From = i1;
                    i1To = i2;
                    tmp1 = res1.clone();
                }
            } else {
                avp.logger.warn("Unexpected zero intersections where at least one was expected");
            }
        }

        if (s2 !== s0) {
            var numInts = xPlaneSegment(plane, pt2, pt0, res1, res2);
            if (numInts == 2) {
                res.push(new Edge(pt2.clone(), pt0.clone(), i2, i2, i0, i0, meshId));
                return;
            } else if (numInts == 1) {
                if (tmp1) {
                    // Avoid the singular scenario where the signs are 0, -1 and +1
                    if (res1.distanceTo(tmp1) > TOL) {
                        i2From = i2;
                        i2To = i0;
                        tmp2 = res1.clone();
                    }
                } else {
                    avp.logger.warn("Unexpected single intersection point");
                }
            } else {
                avp.logger.warn("Unexpected zero intersections where at least one was expected");
            }
        }


        if (tmp1 && tmp2) {
            res.push(new Edge(tmp1, tmp2, i1From, i1To, i2From, i2To, meshId));
        } else {
            avp.logger.warn("Unexpected one intersection where two were expected");
        }

    }
    
    var point = new THREE.Vector3();
    
    function xBoxPlane(plane, box) {
    
        point.set( box.min.x, box.min.y, box.min.z ); // 000
        var d = plane.distanceToPoint(point);
        var s = Math.sign(d);
        
        point.set( box.min.x, box.min.y, box.max.z ); // 001
        var d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;
        
        point.set( box.min.x, box.max.y, box.min.z ); // 010
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.min.x, box.max.y, box.max.z ); // 011
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.min.y, box.min.z ); // 100
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.min.y, box.max.z ); // 101
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.max.y, box.min.z ); // 110
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        point.set( box.max.x, box.max.y, box.max.z ); // 111        
        d2 = plane.distanceToPoint(point);
        if (Math.sign(d2) !== s)
            return true;

        return false;
    }

    var mi = new THREE.Matrix4();
    var pi = new THREE.Plane();

    function xMeshPlane( plane, mesh, intersects ) {

        var geometry = mesh.geometry;
        var baseIndex = intersects.length;

        var matrixWorld = mesh.matrixWorld;
        mi.getInverse(matrixWorld);
        pi.copy(plane).applyMatrix4(mi);

        avp.VertexEnumerator.enumMeshTriangles(geometry, function(vA, vB, vC, a, b, c) {

            xTrianglePlane(pi, vA, vB, vC, a, b, c, intersects, mesh.fragId);

        });

        //Put the points into world space. It should actually be possible to do
        //the entire math in object space -- but we have to check if all fragments
        //that belong to the same dbId have the same world transform.
        for (var i=baseIndex; i<intersects.length; i++) {
            intersects[i].pt1.applyMatrix4(matrixWorld);
            intersects[i].pt2.applyMatrix4(matrixWorld);
        }

    }


	function makeRotationAxis( axis, cosa, m ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = cosa;
		var s = Math.sqrt(1.0 - c*c);
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		m.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

	}


	function makePlaneBasis(plane) {

        //var origin = plane.coplanarPoint();

        var sceneUp = new THREE.Vector3(0,0,1);
        var cross = plane.normal.clone().cross(sceneUp);
        cross = cross.normalize();
        var dot = sceneUp.dot(plane.normal);

        //We are ignoring the translation here, since
        //we will drop the Z coord for the 2D processing steps anyway.
        var planeBasis = new THREE.Matrix4();

        if (!(isZero(cross.x) && isZero(cross.y) && isZero(cross.z))) {
            makeRotationAxis(cross, dot, planeBasis);
            planeBasis.elements[14] = plane.constant;
        } else {
            planeBasis.elements[14] = dot * plane.constant;
        }

        return planeBasis;
    }


    function convertToPlaneCoords(planeBasis, edges3d, bbox) {

        for (var i=0; i<edges3d.length; i++) {
            var e = edges3d[i];

            e.pt1.applyMatrix4(planeBasis);
            e.pt2.applyMatrix4(planeBasis);

            bbox.expandByPoint(e.pt1);
            bbox.expandByPoint(e.pt2);
        }
    }


    return {

        makePlaneBasis: makePlaneBasis,
        convertToPlaneCoords: convertToPlaneCoords,

        intersectTrianglePlane : xTrianglePlane,
        intersectMeshPlane : xMeshPlane,
        intersectBoxPlane : xBoxPlane

    };

})();

}


(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var TAU = Math.PI * 2;

var VBB_GT_TRIANGLE_INDEXED = 0,
    VBB_GT_LINE_SEGMENT     = 1,
    VBB_GT_ARC_CIRCULAR     = 2,
    VBB_GT_ARC_ELLIPTICAL   = 3,
    VBB_GT_TEX_QUAD         = 4,
    VBB_GT_ONE_TRIANGLE     = 5;

var VBB_INSTANCED_FLAG  = 0, // this is intentionally 0 for the instancing case!
    VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
    VBB_SEG_START_LEFT  = 1,
    VBB_SEG_END_RIGHT   = 2,
    VBB_SEG_END_LEFT    = 3;

var VBB_COLOR_OFFSET    = 6,
    VBB_DBID_OFFSET     = 7,
    VBB_FLAGS_OFFSET    = 8,
    VBB_LAYER_VP_OFFSET = 9;

var QUAD_TRIANGLE_INDICES = [ 0,1,3, 0,3,2 ];

function VertexBufferBuilder(useInstancing, allocSize, fullCount)
{
    var MAX_VCOUNT = allocSize || 65536;
    this.FULL_COUNT = (fullCount || 32767) | 0;

    this.useInstancing = useInstancing;

    //TODO: Temporarily expand the stride to the full one, in order to work around new
    //more strict WebGL validation which complains when a shader addresses attributes outside
    //the vertex buffer, even when it does not actually access them. We would need separate shader
    //configurations for each of the two possible vertex strides for the selection shader, which is
    //currently shared between all 2d geometries.
    //this.stride = 10;
    this.stride = 12;

    this.vb  = new ArrayBuffer(this.stride * 4 * (this.useInstancing ? MAX_VCOUNT / 4 : MAX_VCOUNT));
    this.vbf = new Float32Array(this.vb);
    this.vbi = new Int32Array(this.vb);
    this.ib = this.useInstancing ? null : new Uint16Array(MAX_VCOUNT);
    this.reset(0);
}

VertexBufferBuilder.prototype.reset = function(vcount) {
    // This is used to restore the vcount when restoring stream state as well as at init time.
    this.vcount = vcount;

    this.icount = 0;

    this.minx = this.miny =  Infinity;
    this.maxx = this.maxy = -Infinity;

    //Keeps track of objectIds referenced by geometry in the VB
    this.dbIds = {};

    this.numEllipticals   = 0;
    this.numCirculars     = 0;
    this.numTriangleGeoms = 0;
}

VertexBufferBuilder.prototype.expandStride = function()
{
    // since we already set the stride to the current max value of 12 in the
    // constructor above, we don't need to do anything here right now...
    return;

/*
    //Currently hardcoded to expand by 4 floats.
    var expandBy = 2;

    var stride = this.stride;

    if (stride >= 12)
        return;

    var nstride = this.stride + expandBy;

    var nvb = new ArrayBuffer(nstride * (this.vb.byteLength / stride));

    var src = new Uint8Array(this.vb);
    var dst = new Uint8Array(nvb);

    for (var i = 0, iEnd = this.vcount; i<iEnd; i++) {
        var os = i * stride * 4;
        var od = i * nstride * 4;

        for (var j=0; j<stride * 4; j++)
            dst[od+j] = src[os+j];
    }

    this.vb = nvb;
    this.vbf = new Float32Array(nvb);
    this.vbi = new Int32Array(nvb);
    this.stride = nstride;
*/
};

VertexBufferBuilder.prototype.addToBounds = function(x, y)
{
    if (x < this.minx) this.minx = x;
    if (x > this.maxx) this.maxx = x;
    if (y < this.miny) this.miny = y;
    if (y > this.maxy) this.maxy = y;
};

VertexBufferBuilder.prototype.setCommonVertexAttribs = function(offset, vertexId, geomType, color, dbId, layerId, vpId, linePattern)
{
    // align changes here with the "decodeCommonAttribs()" function in LineShader.js and VertexBufferReader.js!!!
    vertexId    = (vertexId    &   0xff); //  8 bit
    geomType    = (geomType    &   0xff); //  8 bit
    linePattern = (linePattern &   0xff); //  8 bit
    layerId     = (layerId     & 0xffff); // 16 bit
    vpId        = (vpId        & 0xffff); // 16 bit

    this.vbi[offset + VBB_FLAGS_OFFSET]    = vertexId | (geomType << 8) | (linePattern << 16); // vertexId: int8; geomType: int8; linePattern: int8; ghostingFlag: int8
    this.vbi[offset + VBB_COLOR_OFFSET]    = color;
    this.vbi[offset + VBB_DBID_OFFSET]     = dbId;
    this.vbi[offset + VBB_LAYER_VP_OFFSET] = layerId | (vpId << 16); // layerId: int16; vpId: int16

    this.dbIds[dbId] = 1; // mark this feature as used
}

//Creates a non-indexed triangle geometry vertex (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addVertexTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi+i) * this.stride;

        // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
        vbf[offset]   = x1;
        vbf[offset+1] = y1;
        vbf[offset+2] = x2;

        vbf[offset+3] = y2;
        vbf[offset+4] = x3;
        vbf[offset+5] = y3;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_ONE_TRIANGLE, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexLine = function(x, y, angle, distanceAlong, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi + i) * this.stride;

        // align changes here with the "decodeSegmentData()" function in LineShader.js!!!
        vbf[offset]   = x;
        vbf[offset+1] = y;
        vbf[offset+2] = angle;

        vbf[offset+3] = distanceAlong;
        vbf[offset+4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
        vbf[offset+5] = totalDistance;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_LINE_SEGMENT, color, dbId, layerId, vpId, lineType);
        this.vcount++;
    }

    return vi;
};

VertexBufferBuilder.prototype.addVertexTexQuad = function(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi + i) * this.stride;

        // align changes here with the "decodeTexQuadData()" function in LineShader.js!!!
        vbf[offset]   = centerX;
        vbf[offset+1] = centerY;
        vbf[offset+2] = rotation;

        vbf[offset+3] = width;
        vbf[offset+4] = height;

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, VBB_GT_TEX_QUAD, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexArc = function(x, y, startAngle, endAngle, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
    var vi  = this.vcount;
    var vbf = this.vbf;

    var geomType = (major == minor) ? VBB_GT_ARC_CIRCULAR : VBB_GT_ARC_ELLIPTICAL;

    var repeat = this.useInstancing ? 1 : 4;
    for (var i=0; i<repeat; i++) {
        var offset = (vi+i) * this.stride;

        // align changes here with the "decodeArcData()" function in LineShader.js!!!
        vbf[offset]   = x;
        vbf[offset+1] = y;
        vbf[offset+2] = startAngle;

        vbf[offset+3] = endAngle;
        vbf[offset+4] = lineWidth * 0.5; // we are storing only the half width (i.e., the radius)
        vbf[offset+5] = major; // = radius for circular arcs

        if (geomType === VBB_GT_ARC_ELLIPTICAL) {
            vbf[offset+10] = minor;
            vbf[offset+11] = tilt;
        }

        this.setCommonVertexAttribs(offset, VBB_SEG_START_RIGHT + i, geomType, color, dbId, layerId, vpId, /*linePattern*/0);
        this.vcount++;
    }

    return vi;
};




//====================================================================================================
//====================================================================================================
// Indexed triangle code path can only be used when hardware instancing is not in use.
// Otherwise, the addTriangleGeom operation should be used to add simple triangles to the buffer.
//====================================================================================================
//====================================================================================================

VertexBufferBuilder.prototype.addVertex = function(x, y, color, dbId, layerId, vpId)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    var vi     = this.vcount;
    var offset = this.stride * vi;
    var vbf    = this.vbf;

    // align changes here with the "decodeTriangleData()" function in LineShader.js!!!
    vbf[offset]   = x;
    vbf[offset+1] = y;

    this.setCommonVertexAttribs(offset, /*vertexId*/0, VBB_GT_TRIANGLE_INDEXED, color, dbId, layerId, vpId, /*linePattern*/0);
    this.vcount++;

    return vi;
};


VertexBufferBuilder.prototype.addVertexPolytriangle = function(x, y, color, dbId, layerId, vpId)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    this.addVertex(x, y, color, dbId, layerId, vpId);

    this.addToBounds(x, y);
};

VertexBufferBuilder.prototype.addIndices = function(indices, vindex) {

    if (this.useInstancing)
        return; //not supported if instancing is used.

    var ib = this.ib;
    var ii = this.icount;

    if (ii + indices.length >= ib.length) {
        var ibnew = new Uint16Array(Math.max(indices.length, ib.length) * 2);
        for (var i=0; i<ii; ++i) {
            ibnew[i] = ib[i];
        }
        this.ib = ib = ibnew;
    }

    for(var i=0; i<indices.length; ++i) {
        ib[ii+i] = vindex + indices[i];
    }

    this.icount += indices.length;
};

//====================================================================================================
//====================================================================================================
// End indexed triangle code path.
//====================================================================================================
//====================================================================================================


VertexBufferBuilder.prototype.finalizeQuad = function(vindex)
{
    if (!this.useInstancing) {
        this.addIndices(QUAD_TRIANGLE_INDICES, vindex);
    }
};


VertexBufferBuilder.prototype.addSegment = function(x1, y1, x2, y2, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType)
{
    var dx = x2 - x1;
    var dy = y2 - y1;
    var angle  = (dx || dy) ? Math.atan2(dy, dx)       : 0.0;
    var segLen = (dx || dy) ? Math.sqrt(dx*dx + dy*dy) : 0.0;

    //Add four vertices for the bbox of this line segment
    //This call sets the stuff that's common for all four
    var v = this.addVertexLine(x1, y1, angle, segLen, totalDistance, lineWidth, color, dbId, layerId, vpId, lineType);

    this.finalizeQuad(v);
    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
};


//Creates a non-indexed triangle geometry (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId)
{
    this.numTriangleGeoms++;

    var v = this.addVertexTriangleGeom(x1, y1, x2, y2, x3, y3, color, dbId, layerId, vpId);

    this.finalizeQuad(v);
    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
    this.addToBounds(x3, y3);
};

VertexBufferBuilder.prototype.addArc = function(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId)
{
    if(major == minor)  {
        this.numCirculars++;
    } else {
        this.numEllipticals++;
    }

    // This is a workaround, when the circular arc has rotation, the extractor cannot handle it.
    // After the fix is deployed in extractor, this can be removed.
    var result = fixUglyArc(start, end);
    start = result.start;
    end   = result.end;

    //If both start and end angles are exactly 0, it's a complete ellipse/circle
    //This is working around a bug in the F2D writer, where an fmod operation will potentially.
    //convert 2pi to 0.
    if (start == 0 && end == 0)
        end = TAU;

    //Add two zero length segments as round caps at the end points
    {
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (range > 0.0001 && Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);
            this.addSegment(sx, sy, sx, sy, 0, lineWidth, color, dbId, layerId, vpId);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);
            this.addSegment(ex, ey, ex, ey, 0, lineWidth, color, dbId, layerId, vpId);

            //TODO: also must add all the vertices at all multiples of PI/2 in the start-end range to get exact bounds
        }
        else
        {
            this.addToBounds(cx - major, cy - minor);
            this.addToBounds(cx + major, cy + minor);
        }
        
        // Add the center of the circle / ellipse as a single transparent dot - So it wil be snappable.
        var c = this.addVertexLine(cx, cy, 0, 0.0001, 0, 0, 1, dbId, layerId, vpId);
        this.finalizeQuad(c);
    }

    var v = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layerId, vpId);

    this.finalizeQuad(v);

    //Testing caps
    if(false) {
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);
            this.addSegment(sx, sy, sx, sy, 0, lineWidth, 0xff00ffff, dbId, layerId, vpId);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);
            this.addSegment(ex, ey, ex, ey, 0, lineWidth, 0xff00ffff, dbId, layerId, vpId);
        }
    }
}


VertexBufferBuilder.prototype.addTexturedQuad = function(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId)
{
    //Height is specified using the line weight field.
    //This will result in height being clamped to at least one pixel
    //but that's ok (zero height for an image would be rare).
    var v = this.addVertexTexQuad(centerX, centerY, width, height, rotation, color, dbId, layerId, vpId);

    this.finalizeQuad(v);

    var cos = 0.5 * Math.cos(rotation);
    var sin = 0.5 * Math.sin(rotation);
    var w = Math.abs(width * cos) + Math.abs(height * sin);
    var h = Math.abs(width * sin) + Math.abs(height * cos);
    this.addToBounds(centerX - w, centerY - h);
    this.addToBounds(centerX + w, centerY + h);
};

VertexBufferBuilder.prototype.isFull = function(addCount)
{
    addCount = addCount || 3;
    var mult = this.useInstancing ? 4 : 1;

    return (this.vcount * mult + addCount > this.FULL_COUNT);
};

VertexBufferBuilder.prototype.toMesh = function()
{
    var mesh = {};

    mesh.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
    mesh.vbstride = this.stride;

    var d = this.useInstancing ? 1 : 0;

    mesh.vblayout = {
        "fields1" :    { offset: 0,                   itemSize: 3, bytesPerItem: 4, divisor: d, normalize: false },
        "fields2" :    { offset: 3,                   itemSize: 3, bytesPerItem: 4, divisor: d, normalize: false },
        "color4b":     { offset: VBB_COLOR_OFFSET,    itemSize: 4, bytesPerItem: 1, divisor: d, normalize: true  },
        "dbId4b":      { offset: VBB_DBID_OFFSET,     itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false },
        "flags4b":     { offset: VBB_FLAGS_OFFSET,    itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false },
        "layerVp4b":   { offset: VBB_LAYER_VP_OFFSET, itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false }
    };

    //Are we using an expanded vertex layout -- then add the extra attribute to the layout
    if (this.stride > 10) {
        mesh.vblayout["extraParams"] = { offset: 10, itemSize: 2, bytesPerItem: 4, divisor: d, normalize: false };
    }

    if (this.useInstancing) {
        mesh.numInstances = this.vcount;

        //Set up trivial vertexId and index attributes

        var instFlags = new Int32Array([ VBB_SEG_START_RIGHT, VBB_SEG_START_LEFT, VBB_SEG_END_RIGHT, VBB_SEG_END_LEFT ]);
        mesh.vblayout.instFlags4b = { offset: 0, itemSize: 4, bytesPerItem: 1, divisor: 0, normalize: false };
        mesh.vblayout.instFlags4b.array = instFlags.buffer;

        var idx = mesh.indices = new Uint16Array(QUAD_TRIANGLE_INDICES);
    } else {
        mesh.indices = new Uint16Array(this.ib.buffer.slice(0, 2 * this.icount));
    }

    mesh.dbIds = this.dbIds;

    var w  = this.maxx - this.minx;
    var h  = this.maxy - this.miny;
    var sz = Math.max(w, h);

    mesh.boundingBox = {
        min: { x: this.minx, y: this.miny, z: -sz * 1e-3 },
        max: { x: this.maxx, y: this.maxy, z:  sz * 1e-3 }
    };

    //Also compute a rough bounding sphere
    var bs = mesh.boundingSphere = {
        center: {
            x: 0.5 * (this.minx + this.maxx),
            y: 0.5 * (this.miny + this.maxy),
            z: 0.0
        },
        radius: 0.5 * Math.sqrt(w*w + h*h)
    };

    return mesh;
};

// The following logic attempts to "fix" imprecisions in arc definitions introduced
// by Heidi's fixed point math, in case that the extractor doesn't handle it correctly.

var fixUglyArc = function (start, end)
{
    //Snap critical angles exactly
    function snapCritical() {
        function fuzzyEquals(a, b) { return (Math.abs(a - b) < 1e-3); }

        if (fuzzyEquals(start, 0))   start = 0.0;
        if (fuzzyEquals(end,   0))   end   = 0.0;
        if (fuzzyEquals(start, TAU)) start = TAU;
        if (fuzzyEquals(end,   TAU)) end   = TAU;
    }

    snapCritical();

    //OK, in some cases the angles are both over-rotated...
    if (start > end) {
        while (start > TAU) {
            start -= TAU;
            end   -= TAU;
        }
    } else {
        while (end > TAU) {
            start -= TAU;
            end   -= TAU;
        }
    }

    //Snap critical angles exactly -- again
    snapCritical();

    //If the arc crosses the x axis, we have to make it clockwise...
    //This is a side effect of bringing over-rotated arcs in range above.
    //For example start = 5.0, end = 7.0 will result in start < 0 and end > 0,
    //so we have to make start > end in order to indicate we are crossing angle = 0.
    if (start < 0 && end > 0) {
        start += TAU;
    }

    return {start: start, end: end};
};

avp.VertexBufferBuilder = VertexBufferBuilder;

})();


(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = av.Private;

var ModelUnits = {
    METER       : 'm',
    CENTIMETER  : 'cm',
    MILLIMETER  : 'mm',
    FOOT        : 'ft',
    INCH        : 'in'
};

av.ModelUnits = ModelUnits;

/**
 * Core class representing the geometry.
 *
 * @constructor
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.Model
 * @category Core
 */
var Model = function( modelData )
{
    WGS.RenderModel.call(this, modelData);
    this.topology = null;
    this.topologyPromise = null;
    this.svfUUID = null;
    this.defaultCameraHash = null;
    var HOMEVIEW_KEY = "Autodesk.Viewing.Private.HomeViewPFs.";


    // RenderModel overrides

    /**
     * @returns {boolean} Whether the model is 3D.
     */
    this.is3d = function() {
        return !this.is2d();
    };

    /**
     * helper functions for fastLoad
     */
    this.getFastLoadList = function() {
        if (!this.svfUUID && avp.LocalStorage.isSupported()) return;
        return JSON.parse(avp.LocalStorage.getItem( HOMEVIEW_KEY + this.svfUUID ) );
    };

    this.setFastLoadList = function(vizFragIds, camera) {
        if (!avp.LocalStorage.isSupported() || avp.LocalStorage.getItem( HOMEVIEW_KEY + this.svfUUID))
            return;
        var homeCam = this.getDefaultCamera();
        if ((camera.position.x + camera.position.z) == (homeCam.position.x + homeCam.position.z))
            avp.LocalStorage.setItem( HOMEVIEW_KEY + this.svfUUID, JSON.stringify(vizFragIds));        
    };
};

/*
 * Don't set Model's prototype to RenderModel. It's not needed for now,
 * and we would also have to defer the initialization of the prototype
 * until WGS (an external dependency) is ready.
 */
//Model.prototype = Object.create(WGS.RenderModel.prototype);

av.EventDispatcher.prototype.apply( Model.prototype );
Model.prototype.constructor = Model;

/**
 * Set a UUID to identify the SVF model
 * @param {string} urn - Data that represents the geometry.
 */
Model.prototype.setUUID = function( urn )
{
    this.svfUUID = btoa(WGS.pathToURL(urn));
};

/**
 * Returns an object wrapping the bubble/manifest entry for the
 * loaded geometry. Contains data such as the viewableID, guid, role...
 */
Model.prototype.getDocumentNode = function() {
    var data = this.getData();
    if (data.loadOptions) {
        return data.loadOptions.bubbleNode || null;
    }
    return null;
};

/**
 * Returns the root of the geometry node graph.
 * @returns {object} The root of the geometry node graph. Null if it doesn't exist.
 */
Model.prototype.getRoot = function()
{
    var data = this.getData();
    if (data && data.instanceTree)
        return data.instanceTree.root;
    return null;
};

/**
 * Returns the root of the geometry node graph.
 * @returns {number} The ID of the root or null if it doesn't exist.
 */
Model.prototype.getRootId = function()
{
    var data = this.getData();
    if (data) {
        if (data.instanceTree)
            return data.instanceTree.getRootId();
        if (data.fragmentMap)
            return data.fragmentMap.getRootId();
    }
    return 0;
};

/**
 * Returns an object that contains the standard unit string (unitString) and the scale value (unitScale).
 * @param {string} unit - Unit name from the metadata
 * @returns {object} this object contains the standardized unit string (unitString) and a unit scaling value (unitScale)
 */
Model.prototype.getUnitData = function(unit)
{
    var returnValue = {
        unitString: null,
        unitScale: 1.0
    };
    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'meters'     :
        case 'm'          :
            returnValue.unitString = ModelUnits.METER;
            returnValue.unitScale = 1.0;
            return returnValue;
        case 'foot'       :
        case 'feet'       :
        case 'ft'         :
            returnValue.unitString = ModelUnits.FOOT;
            returnValue.unitScale = 0.3048;
            return returnValue;
        case 'feet and inches':
        case 'inch'       :
        case 'inches'     :
        case 'in'         :
            returnValue.unitString = ModelUnits.INCH;
            returnValue.unitScale = 0.0254;
            return returnValue;
        case 'centimeter' :
        case 'centimeters':
        case 'cm'         :
            returnValue.unitString = ModelUnits.CENTIMETER;
            returnValue.unitScale = 0.01;
            return returnValue;
        case 'millimeter' :
        case 'millimeters':
        case 'mm'         :
            returnValue.unitString = ModelUnits.MILLIMETER;
            returnValue.unitScale = 0.001;
            return returnValue;
        default:
            return returnValue;
    }
};

/**
 * Returns the scale factor of model's distance unit to meters.
 * @returns {number} The scale factor of the model's distance unit to meters or unity if the units aren't known.
 */
Model.prototype.getUnitScale = function()
{
    var unit;

    if (!this.is2d()) {
        var data = this.getData();
        if (data && data.overriddenUnits) {
            // explicit override trumps all
            unit = data.overriddenUnits;
        } else if(data && data.scalingUnit) {
            unit = data.scalingUnit; // only using if scaling was actually applied
        } else {
            unit = this.getMetadata('distance unit', 'value', null);
        }
    }
    else {
        unit = this.getMetadata('page_dimensions', 'page_units', null);
    }

    if (unit)
        unit = unit.toLowerCase();

    return this.getUnitData(unit).unitScale;
};

/**
 * Returns a standard string representation of the model's distance unit.
 * @returns {string} Standard representation of model's unit distance or null if it is not known.
 */
Model.prototype.getUnitString = function() {

    var unit;

    if (!this.is2d()) {
        // Check if there's an overridden model units in bubble.json (this happens in Revit 3D files)
        var data = this.getData();
        if (data && data.overriddenUnits) {
            // explicit override trumps all
            unit = data.overriddenUnits;
        } else if(data && data.scalingUnit) {
            unit = data.scalingUnit; // only using if scaling was actually applied
        } else {
            unit = this.getMetadata('distance unit', 'value', null);
        }
    }
    else {
        // Model units will be used for calculating the initial distance.
        unit = this.getMetadata('page_dimensions', 'model_units', null) || this.getMetadata('page_dimensions', 'page_units', null);
    }

    if (unit)
        unit = unit.toLowerCase();

    return this.getUnitData(unit).unitString;
};

/**
 * Returns a standard string representation of the model's display unit.
 * @returns {string} Standard representation of model's display unit or null if it is not known.
*/
Model.prototype.getDisplayUnit = function() {
    var unit;

    if (!this.is2d()) {
        var data = this.getData();
        if(data && data.scalingUnit) {
             unit = data.scalingUnit; // only using if scaling was actually applied
        } else {
            unit = this.getMetadata('distance unit', 'value', null);
        }
    }
    else {

        // When model units is not set, it should be assumed to be the same as paper units.
        unit = this.getMetadata('page_dimensions', 'model_units', null) || this.getMetadata('page_dimensions', 'page_units', null);
    }

    if (unit)
        unit = unit.toLowerCase();

    return this.getUnitData(unit).unitString;
};

/**
 * Return metadata value.
 * @param {string} itemName - Metadata item name.
 * @param {string} [subitemName] - Metadata subitem name.
 * @param {*} [defaultValue] - Default value.
 * @returns {*} Metadata value, or defaultValue if no metadata or metadata item/subitem does not exist.
 */
Model.prototype.getMetadata = function (itemName, subitemName, defaultValue) {
    var data = this.getData();
    if (data) {
        var metadata = data.metadata;
        if (metadata) {
            var item = metadata[itemName];
            if (item !== undefined) {
                if (subitemName) {
                    var subitem = item[subitemName];
                    if (subitem !== undefined) {
                        return subitem;
                    }
                } else {
                    return item;
                }
            }
        }
    }
    return defaultValue;
};

/*
Model.prototype.displayMetadata = function () {
    avp.logger.log('metadata:');
    var data = this.getData();
    if (data) {
        var metadata = data.metadata;
        if (metadata) {
            for (itemName in metadata) {
                if (metadata.hasOwnProperty(itemName)) {
                    avp.logger.log('  ' + itemName);
                    var item = metadata[itemName];
                    if (item) {
                        for (subItemName in item) {
                            if (item.hasOwnProperty(subItemName)) {
                                avp.logger.log('    ' + subItemName + '=' + JSON.stringify(item[subItemName]));
                            }
                        }
                    }
                }
            }
        }
    }
};
*/

/**
 * Returns the default camera.
 */
Model.prototype.getDefaultCamera = function() {

    var myData = this.getData();

    if (!myData)
        return null;

    var defaultCamera = null;
    var numCameras = myData.cameras ? myData.cameras.length : 0;
    if (0 < numCameras) {
        // Choose a camera.
        // Use the default camera if specified by metadata.
        //
        var defaultCameraIndex = this.getMetadata('default camera', 'index', null);
        if (defaultCameraIndex !== null && myData.cameras[defaultCameraIndex]) {
            defaultCamera = myData.cameras[defaultCameraIndex];

        } else {

            // No default camera. Choose a perspective camera, if any.
            //
            for (var i = 0; i < numCameras; i++) {
                var camera = myData.cameras[i];
                if (camera.isPerspective) {
                    defaultCamera = camera;
                    break;
                }
            }

            // No perspective cameras, either. Choose the first camera.
            //
            if (!defaultCamera) {
                defaultCamera = myData.cameras[0];
            }
        }
    }

    return defaultCamera;
};

/**
 * Returns whether the "AEC" loader settings were used when loading the model
 */
Model.prototype.isAEC = function() {
    return !!this.getData().loadOptions.isAEC;
};

/**
 * Returns up vector as an array of 3.
 */
Model.prototype.getUpVector = function() {
    return this.getMetadata('world up vector', 'XYZ', null);
};

/**
 * Returns the polygon count.
 * @returns {number}
 */
Model.prototype.geomPolyCount = function() {

    var geomList = this.getGeometryList();
    if (!geomList) {
        return null;
    }

    return geomList.geomPolyCount;
};

/**
 * Returns the instanced polygon count.
 * @returns {number}
 */
Model.prototype.instancePolyCount = function() {

    var geomList = this.getGeometryList();
    if (!geomList) {
        return null;
    }

    return geomList.instancePolyCount;
};


/**
 * Returns the root of the layers tree.
 *
 * Not yet implemented in 3D.
 *
 * @returns {object} The root of the layers tree or null if it doesn't exist.
 */
Model.prototype.getLayersRoot = function () {
    if (!this.is2d()) {
        avp.logger.warn("Autodesk.Viewing.Model.getLayersRoot is not yet implemented for 3D");
        return null;
    }

    var data = this.getData();
    return data ? data.layersRoot : null;
};

/**
 * Returns true if the model with all its geometries has loaded.
 * @returns {boolean}
 */
Model.prototype.isLoadDone = function() {
    var data = this.getData();
    return !!(data && data.loadDone);
};

/**
 * Returns true if the frag to node id mapping is done.
 * @returns {boolean}
 */
Model.prototype.isObjectTreeCreated = function() {

    return !!(this.getData().instanceTree);

};


Model.prototype.getPropertyDb = function() {
    var data = this.getData();
    return data && data.propDbLoader;
};

/**
 * Returns object properties.
 * @param {int} dbId - ID of the node to return the properties for.
 * @param {function} onSuccessCallback - This method is called when request for property db succeeds.
 * @param {function} onErrorCallback - This method is called when request for property db fails.
 */
Model.prototype.getProperties = function( dbId, onSuccessCallback, onErrorCallback )
{
    var pdb = this.getPropertyDb();

    // Negative dbIds will not have properties.
    // Negative dbIds are either paper (-1) or generated ids for 2d-texts
    // dbIds start at 1, so 0 can be skipped as well.
    if (!pdb || dbId <= 0) {
        onErrorCallback && onErrorCallback();
        return;
    }

    pdb.getProperties( dbId, onSuccessCallback, onErrorCallback );
};

/**
 * Returns properties for multiple objects with an optional filter on which properties to retrieve.
 *
 * @param {int[]} dbIds - IDs of the nodes to return the properties for.
 * @param {object|undefined} options - Dictionary with options.
 * @param {string[]} [options.propFilter] - Array of property names to return values for. Use null for no filtering.
 * Filter applies to "name" and "externalId" fields also.
 * @param {boolean} [options.ignoreHidden] - Ignore hidden properties
 * @param {function} onSuccessCallback - This method is called when request for property db succeeds.
 * @param {function} onErrorCallback - This method is called when request for property db fails.
 */
Model.prototype.getBulkProperties = function( dbIds, options, onSuccessCallback, onErrorCallback )
{
    if (Array.isArray(options)) {
        // backwards compatibility for when options was actually propFilter.
        options = { propFilter: options };
    }

    options = options || {};
    var propFilter = options.propFilter || null;
    var ignoreHidden = options.ignoreHidden || false;

    var pdb = this.getPropertyDb();
    if (!pdb) {
        onErrorCallback && onErrorCallback();
        return;
    }

    pdb.getBulkProperties( dbIds, propFilter, onSuccessCallback, onErrorCallback, ignoreHidden );
};


/**
 * Returns an object with key values being dbNodeIds and values externalIds.
 * Useful to map LMV node ids to Fusion node ids.
 *
 * @param {function} onSuccessCallback - This method is called when request for property db succeeds.
 * @param {function} onErrorCallback - This method is called when request for property db fails.
 */
Model.prototype.getExternalIdMapping = function( onSuccessCallback, onErrorCallback )
{
    var pdb = this.getPropertyDb();

    if (!pdb) {
        onErrorCallback && onErrorCallback();
        return;
    }

    pdb.getExternalIdMapping( onSuccessCallback, onErrorCallback );
};

/**
 * Returns object tree.
 *
 * @param {function} onSuccessCallback - This method is called when request for object tree succeeds.
 * @param {function} onErrorCallback - This method is called when request for object tree fails.
 */
Model.prototype.getObjectTree = function( onSuccessCallback, onErrorCallback )
{
    var pdb = this.getPropertyDb();

    if (!pdb) {
        onErrorCallback && onErrorCallback();
        return;
    }

    pdb.getObjectTree( onSuccessCallback, onErrorCallback );
};

/**
 * Returns ``true`` only when the object tree is loaded into memory.
 * Will return ``false`` while the object tree is still loading,
 * or when the object tree fails to load.
 *
 *
 * @returns {boolean}
 */
Model.prototype.isObjectTreeLoaded = function()
{
    var pdb = this.getPropertyDb();

    if (!pdb) {
        return false;
    }

    return pdb.isObjectTreeLoaded();
};


/**
 * Searches the object property database.
 *
 * @param {string} text - The search term (not case sensitive).
 * @param {function} onSuccessCallback - This method is called when request for search succeeds.
 * @param {function} onErrorCallback - This method is called when request for search fails.
 * @param {string[]} [attributeNames] - Restricts search to specific attribute names.
 */
Model.prototype.search = function(text, onSuccessCallback, onErrorCallback, attributeNames, completeInfo)
{
    var pdb = this.getPropertyDb();

    if (!pdb) {
        onErrorCallback && onErrorCallback();
        return;
    }

    pdb.searchProperties(text, attributeNames, onSuccessCallback, onErrorCallback, completeInfo);
};


//========================================================
// Utility functions used by page->model conversions below

var repairViewportMatrix = function(elements) {
    // Sometimes the rows of matrix are swapped
    var precision = 1e-3;
    var e = elements;
    if (Math.abs(e[0]) < precision) {
        if (Math.abs(e[4]) > precision) {
            // swap row 1 and row 2
            for (var i = 0; i < 4; i++) {
                var temp = e[i];
                e[i] = e[i + 4];
                e[i + 4] = temp;
            }
        }
        else {
            // swap row 1 and row 3
            for (var i = 0; i < 4; i++) {
                var temp = e[i];
                e[i] = e[i + 8];
                e[i + 8] = temp;
            }
        }
    }
    if (Math.abs(e[5]) < precision) {
        // swap row 2 and row 3
        for (var i = 4; i < 8; i++) {
            var temp = e[i];
            e[i] = e[i + 4];
            e[i + 4] = temp;
        }
    }
};


var pointInContour = function(x, y, cntr, pts) {
    var yflag0, yflag1;
    var vtx0X, vtx0Y, vtx1X, vtx1Y;

    var inside_flag = false;

    // get the last point in the polygon
    vtx0X = pts[cntr[cntr.length-1]].x;
    vtx0Y = pts[cntr[cntr.length-1]].y;

    // get test bit for above/below X axis
    yflag0 = (vtx0Y >= y);

    for (var j= 0, jEnd=cntr.length; j<jEnd; ++j)
    {
        vtx1X = pts[cntr[j]].x;
        vtx1Y = pts[cntr[j]].y;

        yflag1 = (vtx1Y >= y);

        // Check if endpoints straddle (are on opposite sides) of X axis
        // (i.e. the Y's differ); if so, +X ray could intersect this edge.
        // The old test also checked whether the endpoints are both to the
        // right or to the left of the test point.  However, given the faster
        // intersection point computation used below, this test was found to
        // be a break-even proposition for most polygons and a loser for
        // triangles (where 50% or more of the edges which survive this test
        // will cross quadrants and so have to have the X intersection computed
        // anyway).  I credit Joseph Samosky with inspiring me to try dropping
        // the "both left or both right" part of my code.
        if (yflag0 != yflag1)
        {
            // Check intersection of pgon segment with +X ray.
            // Note if >= point's X; if so, the ray hits it.
            // The division operation is avoided for the ">=" test by checking
            // the sign of the first vertex wrto the test point; idea inspired
            // by Joseph Samosky's and Mark Haigh-Hutchinson's different
            // polygon inclusion tests.
            if (((vtx1Y-y)*(vtx0X-vtx1X) >=
                (vtx1X-x)*(vtx0Y-vtx1Y)) == yflag1)
            {
                    inside_flag = !inside_flag;
            }
        }

        // move to the next pair of vertices, retaining info as possible
        yflag0 = yflag1;
        vtx0X = vtx1X;
        vtx0Y = vtx1Y;
    }

    return inside_flag;
};

Model.prototype.pointInPolygon = function(x, y, contours, points) {
    var inside = false;

    for (var i=0; i<contours.length; i++) {

        if (pointInContour(x, y, contours[i], points))
            inside = !inside;
    }

    return inside;
};




Model.prototype.getPageToModelTransform = function(vpId) {

    var data = this.getData();
    if (data.pageToModelTransform) {
        return data.pageToModelTransform;
    }

    var f2d = data;
    var metadata = f2d.metadata;
    var pd = metadata.page_dimensions;

    var vp = f2d.viewports[vpId];
    if (!vp) {
      return new THREE.Matrix4();
    }

    if (!f2d.viewportTransforms)
        f2d.viewportTransforms = new Array(f2d.viewports.length);

    //See if we already cached the matrix
    var cached = f2d.viewportTransforms[vpId];
    if (cached)
        return cached;

    //Do the matrix composition in double precision using LmvMatrix,
    //which supports that optionally
    var pageToLogical = new WGS.LmvMatrix4(true).set(
      pd.logical_width/pd.page_width, 0, 0, pd.logical_offset_x,
      0, pd.logical_height/pd.page_height, 0, pd.logical_offset_y,
      0, 0, 1, 0,
      0, 0, 0, 1
    );

    var modelToLogicalArray = vp.transform.slice();

    repairViewportMatrix(modelToLogicalArray);

    var modelToLogical = new WGS.LmvMatrix4(true);
    modelToLogical.elements.set(modelToLogicalArray);

    var logicalToModel = new WGS.LmvMatrix4(true);
    logicalToModel.getInverse(modelToLogical);

    logicalToModel.multiply(pageToLogical);

    //Cache for future use
    f2d.viewportTransforms[vpId] = logicalToModel;

    return logicalToModel;
};


/**
 * Paper coordinates to Model coordinates
*/
Model.prototype.pageToModel = function( point1, point2, vpId ) {

    var vpXform = this.getPageToModelTransform(vpId);

    function applyToPoint(point) {
        if (point) {
            var modelPt = new THREE.Vector3().set(point.x, point.y, 0).applyMatrix4(vpXform);
            point.x = modelPt.x;
            point.y = modelPt.y;
        }
    }

    applyToPoint(point1);
    applyToPoint(point2);
};


/**
 * Find the viewports that point lies in its bounds.
*/
Model.prototype.pointInClip = function(point, vpId) {

    var clips = this.getData().clips;
    var clipIds = []; // This will store ids of clip where point lies in

    // clip index starts at 1
    for (var i = 1; i < clips.length; i++) {
        // Don't need to check the point's own viewport's clip, it must be in that clip.
        if (i === vpId)
            continue;

        var contour = [];
        var contours = [];
        var contourCounts = clips[i].contourCounts;
        var points = clips[i].points;
        var index = 0;
        var pts = [];

        // Reorganize contour data
        for (var j = 0; j < contourCounts.length; j++) {
            for (var k = 0; k < contourCounts[j]; k++) {
                contour.push(index);
                index++;
            }
            contours.push(contour);
            contour = [];
        }
        for (var j = 0; j < points.length; j += 2) {
            var pt = {x: points[j], y: points[j+1]};
            pts.push(pt);
        }

        var inside = this.pointInPolygon(point.x, point.y, contours, pts);
        if (inside)
            clipIds.push(i);
    }

    return clipIds;
};

Model.prototype.getClip = function(vpId) {

    var clips = this.getData().clips;

    var contour = [];
    var contours = [];
    var contourCounts = clips[vpId].contourCounts;
    var points = clips[vpId].points;
    var index = 0;
    var pts = [];

    // Reorganize contour data
    for (var j = 0; j < contourCounts.length; j++) {
        for (var k = 0; k < contourCounts[j]; k++) {
            contour.push(index);
            index++;
        }
        contours.push(contour);
        contour = [];
    }
    for (var j = 0; j < points.length; j += 2) {
        var pt = {x: points[j], y: points[j+1]};
        pts.push(pt);
    }

    return { "contours" : contours, "points" : pts };
};


/**
 * Return topology index of the fragment.
 * @param {number} fragId - Fragment ID.
 * @returns {number} Topology index.
 */
Model.prototype.getTopoIndex = function( fragId ) {
    var data = this.getData();
    if (data && data.fragments) {
        var topoIndexes = data.fragments.topoIndexes;
        if (topoIndexes) {
            return topoIndexes[fragId];
        }
    }
};

/**
 * Return topology data of one fragment.
 * 
 * Requires topology data to have been fetched with  
 * [fetchTopology()]{@link Autodesk.Viewing.Model#fetchTopology}.
 * 
 * @param {number} index - Topology index.
 * @returns {object} Topology data.
 */
Model.prototype.getTopology = function( index ) {
    if (this.topology) {
        return this.topology[index];
    }
    return null;
};

/**
 * See also [fetchTopology()]{@link Autodesk.Viewing.Model#fetchTopology}.
 * @returns {boolean} true if topology data has been downloaded and is available in memory
 */
Model.prototype.hasTopology = function() {
    return !!this.topology;
};

/**
 * Downloads the topology file, if one is available.
 * The file may not get downloaded if the topology content size in memory is bigger
 * than a specified limit (100 MB by default, 20 MB for mobile).
 * 
 * @param {number} maxSizeMB - Maximum uncompressed topology size allowed (in MegaBytes).
 * 
 * @returns {Promise} that resolves with the topology object.
 */
Model.prototype.fetchTopology = function(maxSizeMB) {

    // Debugging
   /*return new Promise(function(resolve, reject){
        function aaa() {
            if (avp.debug_topo_yes) {
                resolve([]);
                return;
            }
            if (avp.debug_topo_no) {
                reject('Buuuu');
                return;
            }
            requestAnimationFrame(aaa);
        }
        aaa();
    });
   // */
    // Debugging end
    
    if (this.topology)  // Already downloaded
        return Promise.resolve(this.topology);

    var data = this.getData();
    if (!data.topologyPath) // No path from where to download it
        return Promise.reject({ error: "no-topology" });

    var maxTopologyFileSizeMB = maxSizeMB || (av.isMobileDevice() ? 20 :  100); // MegaBytes; Non-gzipped
    if (data.topologySizeMB > maxTopologyFileSizeMB) // File is too big to download.
        return Promise.reject({ error: "topology-too-big", limitMB: maxTopologyFileSizeMB, topologyMB: data.topologySizeMB }); 

    if (!this.topologyPromise) // Fetch it!
    {
        var that = this;        
        this.topologyPromise = new Promise(function(resolve, reject){
            that.loader.fetchTopologyFile( that.getData().topologyPath, function onComplete( topoData ) {
                if (topoData && topoData.topology) {
                    that.topology = topoData.topology;
                    resolve(topoData.topology);
                } else {
                    reject(topoData);
                }
            });
        });
    }

    return this.topologyPromise;
};

Model.prototype.hasGeometry = function() {
    var data = this.getData();
    if (data){
        if (data.isLeaflet) { // see LeafletLoader.js
            return true;
        }
        return data.fragments.length > 0;
    }
    return false;
};


av.Model = Model;

})();



(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private;

var TAU = Math.PI * 2;

//Constants duplicated from src/lmvtk/VertexBufferBuilder.js
var VBB_GT_TRIANGLE_INDEXED = 0,
    VBB_GT_LINE_SEGMENT     = 1,
    VBB_GT_ARC_CIRCULAR     = 2,
    VBB_GT_ARC_ELLIPTICAL   = 3,
    VBB_GT_TEX_QUAD         = 4,
    VBB_GT_ONE_TRIANGLE     = 5;

var VBB_INSTANCED_FLAG  = 0, // this is intentionally 0 for the instancing case!
    VBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!
    VBB_SEG_START_LEFT  = 1,
    VBB_SEG_END_RIGHT   = 2,
    VBB_SEG_END_LEFT    = 3;

var VBB_COLOR_OFFSET    = 6,
    VBB_DBID_OFFSET     = 7,
    VBB_FLAGS_OFFSET    = 8,
    VBB_LAYER_VP_OFFSET = 9;

/**
 * Initializes a "view" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.
 * See src/lmvtk/VertexBufferBuilder.js for more details.
 */
avp.VertexBufferReader = function(geometry, useInstancing)
{
    this.vb  = geometry.vb.buffer;
    this.vbf = new Float32Array(this.vb);
    this.vbi = new Int32Array(this.vb);

    this.ib = geometry.ib;

    this.stride = geometry.vbstride;
    this.vcount = this.vbf.length / this.stride;

    this.useInstancing = !!useInstancing;
};

avp.VertexBufferReader.prototype.getDbIdAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_DBID_OFFSET];
};

avp.VertexBufferReader.prototype.getVertexFlagsAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_FLAGS_OFFSET];
};

avp.VertexBufferReader.prototype.getLayerIndexAt = function(vindex) {
    return this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;
};

avp.VertexBufferReader.prototype.getViewportIndexAt = function(vindex) {
    return (this.vbi[vindex*this.stride + VBB_LAYER_VP_OFFSET] >> 16) & 0xffff;
};

avp.VertexBufferReader.prototype.decodeLineAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onLineSegment) { return; }

    var baseOffset = this.stride * vindex;
    var x0         = this.vbf[baseOffset];
    var y0         = this.vbf[baseOffset+1];
    var angle      = this.vbf[baseOffset+2];
    var distAlong  = this.vbf[baseOffset+3];

    var x1 = x0 + distAlong * Math.cos(angle);
    var y1 = y0 + distAlong * Math.sin(angle);

    callback.onLineSegment(x0, y0, x1, y1, vpId);
};

avp.VertexBufferReader.prototype.decodeCircularArcAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onCircularArc) { return; }

    var baseOffset = this.stride * vindex;
    var cx         = this.vbf[baseOffset];
    var cy         = this.vbf[baseOffset+1];
    var start      = this.vbf[baseOffset+2];
    var end        = this.vbf[baseOffset+3];
    var radius     = this.vbf[baseOffset+5];

    callback.onCircularArc(cx, cy, start, end, radius, vpId);
};

avp.VertexBufferReader.prototype.decodeEllipticalArcAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onEllipticalArc) { return; }

    var baseOffset = this.stride * vindex;
    var cx         = this.vbf[baseOffset];
    var cy         = this.vbf[baseOffset+1];
    var start      = this.vbf[baseOffset+2];
    var end        = this.vbf[baseOffset+3];
    var major      = this.vbf[baseOffset+5];
    var minor      = this.vbf[baseOffset+10];
    var tilt       = this.vbf[baseOffset+11];

    callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);
};

avp.VertexBufferReader.prototype.decodeTexQuadAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onTexQuad) { return; }

    var baseOffset = this.stride * vindex;
    var centerX    = this.vbf[baseOffset];
    var centerY    = this.vbf[baseOffset+1];
    // yes, this is in a different order than output, following VertexBufferBuilder's order
    var rotation   = this.vbf[baseOffset+2];
    var width      = this.vbf[baseOffset+3];
    var height     = this.vbf[baseOffset+4];

    callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);
};

avp.VertexBufferReader.prototype.decodeOneTriangleAt = function(vindex, layer, vpId, callback)
{
    if (!callback.onOneTriangle) { return; }

    var baseOffset = this.stride * vindex;
    var x1         = this.vbf[baseOffset];
    var y1         = this.vbf[baseOffset+1];
    var x2         = this.vbf[baseOffset+2];
    var y2         = this.vbf[baseOffset+3];
    var x3         = this.vbf[baseOffset+4];
    var y3         = this.vbf[baseOffset+5];

    callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);
};


avp.VertexBufferReader.prototype.decodeTriangleIndexed = function(vi0, vi1, vi2, layer, vpId, callback)
{
    if (!callback.onOneTriangle) { return; }

    var baseOffset = this.stride * vi0;
    var x1         = this.vbf[baseOffset];
    var y1         = this.vbf[baseOffset+1];

    baseOffset = this.stride * vi1;
    var x2         = this.vbf[baseOffset];
    var y2         = this.vbf[baseOffset+1];

    baseOffset = this.stride * vi2;
    var x3         = this.vbf[baseOffset];
    var y3         = this.vbf[baseOffset+1];

    callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);
};


// used by the snapper and by the bounds finder
avp.VertexBufferReader.prototype.enumGeomsForObject = function(dbId, callback)
{
    if (this.useInstancing) {

        //When instancing is used, each geometry primitive is encoded into a single vertex
        //and there is no index buffer.

        var i = 0;
        while (i < this.vcount) {
            var flag = this.getVertexFlagsAt(i);

            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
            var geomType    = (flag >>  8) & 0xff;        //  8 bit
            //var linePattern = (flag >> 16) & 0xff;        //  8 bit
            var layerId     = this.getLayerIndexAt(i);    // 16 bit
            var vpId        = this.getViewportIndexAt(i); // 16 bit

            var visible = this.getDbIdAt(i) === dbId;
            if (visible) {
                switch (geomType) {
                    case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         i, layerId, vpId, callback); break;
                    case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  i, layerId, vpId, callback); break;
                    case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(i, layerId, vpId, callback); break;
                    case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      i, layerId, vpId, callback); break;
                    case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  i, layerId, vpId, callback); break;
                    default:                         break;
                }
            }

            //In the case of instancing, there is no vertex duplication and no index buffer, we just
            //move to the next vertex
            i += 1;
        }
    } else {

        var i = 0;
        while (i < this.ib.length) {
            var vi = this.ib[i];
            var flag = this.getVertexFlagsAt(vi);

            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
            var geomType    = (flag >>  8) & 0xff;        //  8 bit
            //var linePattern = (flag >> 16) & 0xff;        //  8 bit
            var layerId     = this.getLayerIndexAt(vi);    // 16 bit
            var vpId        = this.getViewportIndexAt(vi); // 16 bit

            var visible = this.getDbIdAt(vi) === dbId;

            if (geomType === VBB_GT_TRIANGLE_INDEXED) {

                //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else

                if (visible) {
                    this.decodeTriangleIndexed(this.ib[i], this.ib[i+1], this.ib[i+2], layerId, vpId, callback);
                }

                //Advance to the next primitive
                i += 3;

            } else {

                if (visible) {
                    switch (geomType) {
                        case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         vi, layerId, vpId, callback); break;
                        case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  vi, layerId, vpId, callback); break;
                        case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(vi, layerId, vpId, callback); break;
                        case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      vi, layerId, vpId, callback); break;
                        case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  vi, layerId, vpId, callback); break;
                        default:                         break;
                    }
                }

                //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,
                //each vertex is listed four times with a different vertexId flag
                i += 6;
            }


        }
    }

};


/**
 * Used by the bounds finder.
 * @param {array[number]} layerIdsVisible - list of layer ids that are visible
 * @param {function} callback
 * @private
 */
avp.VertexBufferReader.prototype.enumGeomsForVisibleLayer = function(layerIdsVisible, callback)
{
    if (this.useInstancing) {

        //When instancing is used, each geometry primitive is encoded into a single vertex
        //and there is no index buffer.

        var i = 0;
        while (i < this.vcount) {
            var flag = this.getVertexFlagsAt(i);

            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
            var geomType    = (flag >>  8) & 0xff;        //  8 bit
            //var linePattern = (flag >> 16) & 0xff;        //  8 bit
            var layerId     = this.getLayerIndexAt(i);    // 16 bit
            var vpId        = this.getViewportIndexAt(i); // 16 bit

            // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.
            // If layerId visibility is not set, consider the layer visible.
            var visible = !layerIdsVisible || (layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1);
            if (visible) {
                switch (geomType) {
                    case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         i, layerId, vpId, callback); break;
                    case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  i, layerId, vpId, callback); break;
                    case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(i, layerId, vpId, callback); break;
                    case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      i, layerId, vpId, callback); break;
                    case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  i, layerId, vpId, callback); break;
                    default:                         break;
                }
            }

            //In the case of instancing, there is no vertex duplication and no index buffer, we just
            //move to the next vertex
            i += 1;
        }
    } else {

        var i = 0;
        while (i < this.ib.length) {
            var vi = this.ib[i];
            var flag = this.getVertexFlagsAt(vi);

            //var vertexId    = (flag >>  0) & 0xff;        //  8 bit
            var geomType    = (flag >>  8) & 0xff;        //  8 bit
            //var linePattern = (flag >> 16) & 0xff;        //  8 bit
            var layerId     = this.getLayerIndexAt(vi);    // 16 bit
            var vpId        = this.getViewportIndexAt(vi); // 16 bit

            // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.
            // If layerId visibility is not set, consider the layer visible.
            var visible = !layerIdsVisible || (layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1);

            if (geomType === VBB_GT_TRIANGLE_INDEXED) {

                //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else

                if (visible) {
                    this.decodeTriangleIndexed(this.ib[i], this.ib[i+1], this.ib[i+2], layerId, vpId, callback);
                }

                //Advance to the next primitive
                i += 3;

            } else {

                if (visible) {
                    switch (geomType) {
                        case VBB_GT_LINE_SEGMENT:        this.decodeLineAt(         vi, layerId, vpId, callback); break;
                        case VBB_GT_ARC_CIRCULAR:        this.decodeCircularArcAt(  vi, layerId, vpId, callback); break;
                        case VBB_GT_ARC_ELLIPTICAL:      this.decodeEllipticalArcAt(vi, layerId, vpId, callback); break;
                        case VBB_GT_TEX_QUAD:            this.decodeTexQuadAt(      vi, layerId, vpId, callback); break;
                        case VBB_GT_ONE_TRIANGLE:        this.decodeOneTriangleAt(  vi, layerId, vpId, callback); break;
                        default:                         break;
                    }
                }

                //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,
                //each vertex is listed four times with a different vertexId flag
                i += 6;
            }

        }
    }

};



/**
 * Callback class for calculating bounds of 2D objects via VertexBufferReader
 * @private
 */
function BoundsCallback(bounds) {
    this.bounds = bounds;
    // workspace, so we don't reallocate this each time
    this.point = new THREE.Vector4();
    this.point.z = 0.0;
    this.point.w = 1.0; // it's a point, not a vector
}

BoundsCallback.prototype.onVertex = function(cx, cy, vpId) {
    this.point.x = cx;
    this.point.y = cy;
    this.bounds.expandByPoint( this.point );
};

BoundsCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {
    this.onVertex( x1, y1 );
    this.onVertex( x2, y2 );
};

BoundsCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {
    this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);
};

BoundsCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {
    if ( tilt == 0.0 ) {
        // does start and end make a full ellipse?
        if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {
            // full way around, simply treat it like a rectangle
            this.onTexQuad(cx, cy, 2*major, 2*minor, tilt, vpId);
        } else {
            // Not a full ellipse. We take the start and end points and also figure
            // out the four "compass rose" points that are between these two locations.
            // The start and end locations often exist as separate vertices so would
            // already be included, but for some line types they may not exist, so we
            // include them here.
            this.point.x = cx + Math.cos(start)*major;
            this.point.y = cy + Math.sin(start)*minor;
            this.bounds.expandByPoint( this.point );
            this.point.x = cx + Math.cos(end)*major;
            this.point.y = cy + Math.sin(end)*minor;
            this.bounds.expandByPoint( this.point );

            // now check each NESW compass point, i.e., middle of each edge
            if ( start > end ) {
                // add right edge
                this.point.x = cx + major;
                this.point.y = cy ;
                this.bounds.expandByPoint( this.point );
                // make start < end for the rest of the tests
                start -= 2.0 * Math.PI;
            }
            if ( start < 0.5 * Math.PI && end > 0.5 * Math.PI ) {
                // add top edge
                this.point.x = cx ;
                this.point.y = cy + minor;
                this.bounds.expandByPoint( this.point );
            }
            if ( start < Math.PI && end > Math.PI ) {
                // add left edge
                this.point.x = cx - major;
                this.point.y = cy;
                this.bounds.expandByPoint( this.point );
            }
            if ( start < 1.5 * Math.PI && end > 1.5 * Math.PI ) {
                // add bottom edge
                this.point.x = cx ;
                this.point.y = cy - minor;
                this.bounds.expandByPoint( this.point );
            }
        }
    } else {
        // Has a tilt.
        // From what we see, you should never reach here, as tilted ellipses are actually
        // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.
        // This call will be a pretty good approximation, putting a rotated bounding box
        // around the whole ellipse. For more accuracy you would need to tessellate the
        // ellipse and get its points (especially if you don't have a full ellipse).
        this.onTexQuad(cx, cy, 2*major, 2*minor, tilt, vpId);

        // does start and end make a full ellipse?
        //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {
        //}
    }
};

// Currently this case does not actually come up, as textured quads, i.e., images, are
// not something that can be selected, from what data I have tried. So I have not spent
// any time on the rotated case.
// TODO: this code is only partially tested: I had problems getting a selectable raster
// object in a DWG convert to an F2D.
BoundsCallback.prototype.onTexQuad = function(centerX, centerY, width, height, rotation, vpId) {
    var halfWidth = 0.5 * width;
    var halfHeight = 0.5 * width;
    if (rotation == 0.0) {
        this.onVertex( centerX - halfWidth, centerY - halfHeight );
        this.onVertex( centerX + halfWidth, centerY + halfHeight );
    } else {
        // A more complex rectangle, rotated. Take the four corners and rotate each
        // around the center.
        var rmtx = new THREE.Matrix4();  // Matrix3() does not have enough helper methods
        var mtx = new THREE.Matrix4();
        // Take a rectangle centered at the origin, rotate it, translate it to the final
        // position. Each corner is added to the bounds.
        rmtx.makeRotationZ(rotation);
        // put it into the final position:
        mtx.makeTranslation(centerX, centerY, 0.0);
        mtx.multiply(rmtx);

        for (var i = 0; i < 4; i++) {
            this.point.x = (((i%2)==1)?halfWidth:-halfWidth);
            this.point.y = ((i>=2)?halfHeight:-halfHeight);
            this.point.applyMatrix4(mtx);
            this.bounds.expandByPoint( this.point );
        }
    }
};

BoundsCallback.prototype.onOneTriangle = function(x1, y1, x2, y2, x3, y3, vpId) {
    this.onVertex( x1, y1 );
    this.onVertex( x2, y2 );
    this.onVertex( x3, y3 );
};


avp.BoundsCallback = BoundsCallback;

})();


(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

/** 
 * Enumeration of important render targets generated by LMV.
 */
var RenderTargets = Object.freeze({
    Color: 'Color',
    Depth: 'Depth',
    ModelId: 'ModelId',
    Overlay: 'Overlay',
    Post1: 'Post1',
    Post2: 'Post2'
});

avp.RenderTargets = RenderTargets;

})();

(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

/**
 * Basic manager for a list of functions called to render additional content
 */ 
function RenderCallbacks()
{
    this.entries = {};

    /** 
     * Register a function to call for rendering
     * @param {string} name - Name of this callback
     * @param {Function} callback - Function called when rendering
     */
    this.add = function(name, callback) {
        this.entries[name] = { "callback": callback };
    };

    /** 
     * Remove a previously registered callback by name
     * @param {string} name - Name of the callback to remove
     */
    this.remove = function(name) {
        var entry = this.entries[name];
        if (entry) {
            delete this.entries[name];
        }
    };

    /** 
     * Run all of the registered render callbacks
     */
    this.render = function() {
        for (var name in this.entries) {
            this.entries[name].callback();
        }
    }
}

avp.RenderCallbacks = RenderCallbacks;

})();
(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

function RenderContext() {

    var _renderer;
    var _depthMaterial;
    var _edgeMaterial;
    var _idMaterial;

    //The camera and lights used for an entire progressive pass (potentially several GL frames)
    var _camera;
    var _lights;
    var _fog;

    var _clearPass,
        _saoBlurPass,
        _saoPass,
        _saoMipPass,
        _saoMipFirstPass,
        _fxaaPass,
        _postProcPass,
        _blendPass,
        _copyPass;

    var _pencilMap = null;
    var _graphiteMaps = [];
    var _pencilBackgroundMap = null;

    var _saoBufferValid = false;

    var _lastX, _lastY, _lastID, _lastModelID, _lastIDValid = false;

    var _depthTarget;
    var _depthMipMap = null;
    var _colorTarget = null;
    var _overlayTarget = null;
    var _postTarget1 = null;
    var _postTarget2 = null;
    var _idTargets = [];

    var _exposureBias = 0.0;
    var _envRotation = 0.0;
    var _tonemapMethod = 0;
    var _unitScale = 1.0;

    // Occlusion test variables
    var _occlusionMaterials = [ [], [] ];
    var _occlusionTarget = null;
    var _occlusionTest = null;
    var _unitCubeVerts = null;
    var _unitCubeIndices = null;
    var _occlusionScene = null;

    var _w, _h;
    var _warnedLeak = false;

    var _readbackBuffer = new Uint8Array(4);

    var _white = new THREE.Color().setRGB(1, 1, 1);
    var _black = new THREE.Color().setRGB(0, 0, 0);
    var _edgeColor = new THREE.Vector4(0,0,0,0.3);
    var _edgeColorHighlight = new THREE.Vector4(1,1,1, 1);
    var _edgeColorHighlightUnder = new THREE.Vector4(1,1,1, 0.5);
    var _clearColor = null;
    var _isWeakDevice = false;
    var _enableRolloverHighlight = true;

    var _renderEdges = false;
    var _isRenderingHidden = false;
    var _isRenderingOverlays = false;

    var _mrtFloat32Works = false;
    var _mrtRGBA8Works = false;
    var _renderTargetFormat;

    var _occlusionIds = null;
    var _occlusionIdsCopied = false;

    var _lastObjTime = 0,
        _lastHighlightId = 0,
        _lastHighlightModelId = 0,
        _easeCurve = [0.42,0,1,1],
        _easeSpeed = 0.004;

    //Rendering options
    var _settings = {
        antialias: true,
        sao: false,
        useHdrTarget: false,
        haveTwoSided: false,
        useSSAA: false, /* Whether to use supersampled targets when antialiasing is used (default is FXAA) */
        idbuffer: true,
        occlusionid: true,
        customPresentPass: false,
        postProcShaded: false,
        envMapBg: false,
        swapBlackAndWhite: false,
        numIdTargets: 1 //must be 1 or 2
    };

    var _oldSettings = {};

    var avs = Autodesk.Viewing.Shaders;


    //TODO: hide this once there is a way
    //to obtain the current pipeline configuration
    this.settings = _settings;


    this.init = function (glrenderer, width, height) {

        createRenderPasses();

        if (!glrenderer) {
            avp.logger.error("You need a gl context to make a renderer. Things will go downhill from here.", av.errorCodeString(av.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED));
            return;
        }

        //Rendering to RGB32F is broken as of Firefox 45, so we use alternative render target format until it works again.
        var isBrokenFF = window.navigator.userAgent.indexOf("Firefox") != -1;

        //RGB32F is not renderable on Firefox/Windows now, so we use RGBA instead.
        //NOTE: This assumes MRT does not work on Firefox/Windows with RGB32F target either. If it does, then
        //we have to use the same format for the color and id targets.
        _renderTargetFormat = isBrokenFF ? THREE.RGBAFormat : THREE.RGBFormat;

        _isWeakDevice = av.isMobileDevice();

        _settings.idbuffer = !_isWeakDevice;

        _w = width;
        _h = height;

        _renderer = glrenderer;

        //delayed until first begin frame
        //this.initPostPipeline(_settings.sao, _settings.antialias);

    };

    // Creates material for normal-depth shader - including alternative variants
    // for instancing and with/without cutplanes.
    function createDepthMaterial() {

        // create main/default override material first
        var depthShader = avs.NormalsShader;
        _depthMaterial = avs.createShaderMaterial(depthShader);
        _depthMaterial.blending = THREE.NoBlending;
        _depthMaterial.packedNormals = true;
        // normally the color target will write to the z-buffer, so depth does not need to do so.
        _depthMaterial.depthWrite = false;

        // Flags to define alternative depth material variants.
        var DepthMaterialFlags = {
            NoCutPlanes: 0x1, // Without cutplanes to render section caps
            Instancing:  0x2, // Using instancing
            Count     :  0x4
        };

        // create special-case material variants
        var variants = [];
        variants[0] = null; // index 0 = null (=use default depthMaterial)
        for (var i=1; i<DepthMaterialFlags.Count; i++) {
            var variant = _depthMaterial.clone();

            // cutplanes: with/without
            if (i & DepthMaterialFlags.NoCutPlanes) {
                variant.cutPlanes     = null;
                variant.blending      = THREE.NoBlending;
                variant.packedNormals = true;
                variant.doNotCut      = true; // make sure that cutplanes keep null (see MaterialManager.addMaterialNonHDR)
            }

            // instancing yes/no
            if (i & DepthMaterialFlags.Instancing) {
                variant.useInstancing = true;
            }

            variants[i] = variant;
        }

        _depthMaterial.variants = variants;

        // Define a custom override function: It decides for a shape
        // which depthMaterial variant will be used by WebGLRenderer.
        _depthMaterial.getCustomOverrideMaterial = function(shapeMaterial) {

            // If the original shape material has no cutplanes, use the alternative
            // _noCutplanesMaterial for normal/depth.
            var noCutPlanes = (!shapeMaterial || !shapeMaterial.cutplanes || shapeMaterial.cutplanes.length == 0);

            // If the original material applies the instance transform, depthMaterial must do this as well.
            var instanced   = shapeMaterial.useInstancing;

            // return the appropriate material variant
            var index =
                (noCutPlanes ? DepthMaterialFlags.NoCutPlanes : 0) |
                (instanced   ? DepthMaterialFlags.Instancing  : 0);
            return this.variants[index];
        };
    }

   function createEdgeMaterial() {
        // create main/default override material first
        var edgeShader = avs.EdgeShader;
        _edgeMaterial = avs.createShaderMaterial(edgeShader);
        _edgeMaterial.depthWrite = true;
        _edgeMaterial.depthTest = true;
        _edgeMaterial.isEdgeMaterial = true;
        _edgeMaterial.transparent = true;
        _edgeMaterial.blending = THREE.NormalBlending;

        // Flags to define alternative edge material variants.
        var EdgeMaterialFlags = {
            Instancing:  0x1, // Using instancing
            Count     :  2
        };

        // create special-case material variants
        var variants = [];
        variants[0] = null; // index 0 = null (=use default edgeMaterial)
        for (var i=1; i<EdgeMaterialFlags.Count; i++) {
            var variant = _edgeMaterial.clone();

            //Have to clone this manually, otherwise it's shared between the clones
            variant.defines = av.ObjectAssign({}, _edgeMaterial.defines);

            variant.isEdgeMaterial = true;

            // instancing yes/no
            if (i & EdgeMaterialFlags.Instancing) {
                variant.useInstancing = true;
            }

            variants[i] = variant;
        }

        _edgeMaterial.variants = variants;

        // Define a custom override function: It decides for a shape
        // which depthMaterial variant will be used by WebGLRenderer.
        _edgeMaterial.getCustomOverrideMaterial = function(shapeMaterial) {

            // If the original material applies the instance transform, depthMaterial must do this as well.
            var instanced   = shapeMaterial.useInstancing;

            // return the appropriate material variant
            var index =  (instanced ? EdgeMaterialFlags.Instancing : 0);

            var mat = this.variants[index] || _edgeMaterial;

            //Unlike depth test settings, we need to change uniforms on the material variant
            //for them to take effect
            if (_isRenderingOverlays) {
                if (_isRenderingHidden) {
                    mat.uniforms.color.value = _edgeColorHighlightUnder;
                } else {
                    mat.uniforms.color.value = _edgeColorHighlight;
                }
            } else {
                mat.uniforms.color.value = _edgeColor;
            }
            mat.uniforms.color.needsUpdate = true;

            return mat;
        };
    }

    this.setDepthMaterialOffset = function(on,factor,units) {
        var cb = function(mat) {
            mat.polygonOffset = on;
            mat.polygonOffsetFactor = factor;
            mat.polygonOffsetUnits = units;
            if (mat.extraDepthOffset) {
                mat.polygonOffsetFactor += mat.extraDepthOffset;
            }
            mat.needsUpdate = true;
        };
        forEachDepthMaterial(cb);
    };

    // Calls the cb for all depth material variants (including default)
    function forEachDepthMaterial(cb) {
        cb(_depthMaterial);
        for (var i=1; i<_depthMaterial.variants.length; i++) {
            cb(_depthMaterial.variants[i]);
        }
    }

    function createRenderPasses() {

        function setNoDepthNoBlend(pass) {
            pass.material.blending = THREE.NoBlending;
            pass.material.depthWrite = false;
            pass.material.depthTest = false;
        }

        createDepthMaterial();
        createEdgeMaterial();

        _saoPass = new avs.LmvShaderPass(avs.SAOShader);
        setNoDepthNoBlend(_saoPass);

        _saoBlurPass = new avs.LmvShaderPass(avs.SAOBlurShader);
        setNoDepthNoBlend(_saoBlurPass);

        _saoMipFirstPass = new avs.LmvShaderPass(avs.SAOMinifyFirstShader);
        setNoDepthNoBlend(_saoMipFirstPass);

        _saoMipPass = new avs.LmvShaderPass(avs.SAOMinifyShader);
        setNoDepthNoBlend(_saoMipPass);

        _fxaaPass = new avs.LmvShaderPass(avs.FXAAShader);
        setNoDepthNoBlend(_fxaaPass);

        _postProcPass = new avs.LmvShaderPass(avs.CelShader);
        setNoDepthNoBlend(_postProcPass);

        _blendPass = new avs.LmvShaderPass(avs.BlendShader);
        setNoDepthNoBlend(_blendPass);

        _clearPass = new avs.LmvShaderPass(avs.BackgroundShader);
        setNoDepthNoBlend(_clearPass);

        _copyPass = new avs.LmvShaderPass(avs.CopyShader);
        setNoDepthNoBlend(_copyPass);
    }

    /**
     * Returns true if render target with given name is used by at least one rendering component or effect.
     * @param {String} targetName - Render target name (see RenderTargets for complete list)
     */
    function isRenderTargetUsed(targetName) {
        switch (targetName) {
            case avp.RenderTargets.Color: return true;
            case avp.RenderTargets.Depth: return (_settings.sao || _settings.postProcShaded);
            case avp.RenderTargets.ModelId: return (_settings.idbuffer || _settings.occlusionid);
            case avp.RenderTargets.Overlay: return true;
            case avp.RenderTargets.Post1: return (_settings.antialias || _settings.sao || _settings.customPresentPass || _settings.postProcShaded);
            case avp.RenderTargets.Post2: return (_settings.sao || _settings.postProcShaded || (_settings.antialias && _settings.customPresentPass));
        }
    }

    function cubicBezier(p, t) {
        //var cx = 3.0 * p[0];
        //var bx = 3.0 * (p[2] - p[0]) - cx;
        //var ax = 1.0 - cx -bx;
        var cy = 3.0 * p[1];
        var by = 3.0 * (p[3] - p[1]) - cy;
        var ay = 1.0 - cy - by;

        //return ((ax * t + bx) * t + cx) * t;
        return ((ay * t + by) * t + cy) * t;
    }

    // Fades the overlay update in over time.
    // For rollover highlighting, which increases in effect as you wait.
    this.overlayUpdate = function() {

        if (_lastHighlightId === 0 || _lastHighlightId === -1)
            return false;

        var old = _blendPass.uniforms.highlightIntensity.value;

        // Multiply number of milliseconds that has elapsed by the
        // speed, 1/milliseconds, the time the transition should take.
        // So if _easeSpeed is, say, 1/1000, the transition takes a second;
        // 2/1000 is half a second, etc.
        var t = ((performance.now() - _lastObjTime) * _easeSpeed);
        t = Math.min(t, 1.0);

        // not a linear transition; use a cubic Bezier curve to ease in and out
        var current = cubicBezier(_easeCurve, t);

        // if intensity value has changed, update the shader's uniform
        if (old != current) {
            _blendPass.uniforms.highlightIntensity.value = current;
            return true;
        }

        return false;
    };

    // clear the color target and other targets, as needed
    this.beginScene = function (prototypeScene, camera, customLights, needClear) {
        _camera = camera;
        _fog = prototypeScene.fog;
        _lights = customLights;
        _saoBufferValid = false;
        _lastIDValid = false;

        if (!_colorTarget && _w) {
            this.initPostPipeline(_settings.sao, _settings.antialias);
        } else if (!_colorTarget && !_w) {
            if (!_warnedLeak) {
                avp.logger.error("Rendering to a canvas that was resized to zero. If you see this message you may be accidentally leaking a viewer instance.", av.errorCodeString(av.ErrorCodes.VIEWER_INTERNAL_ERROR));
                _warnedLeak = true;
            }
            return;
        }

        //We need to render once with the "prototype" scene which
        //only contains the cameras and lights, so that their positions
        //and transforms get updated to the latest camera. Hence the
        //call to render instead of just clear.


        //Clear the color target
        if (needClear) {

            if (_clearColor && !_settings.envMapBg) {
                if (_settings.swapBlackAndWhite) {
                    var white = new THREE.Color(1, 1, 1);
                    var black = new THREE.Color(0, 0, 0);
                    if (_clearColor.equals(white)) {
                        _renderer.setClearColor(black, 1.0);
                    }
                    else if (_clearColor.equals(black)) {
                        _renderer.setClearColor(white, 1.0);
                    }
                    else {
                        _renderer.setClearColor(_clearColor, 1.0);
                    }
                }
                else {
                    _renderer.setClearColor(_clearColor, 1.0);
                }
                _renderer.clearTarget(_colorTarget, true, true, false); //clear color and depth buffer
            } else {

                _clearPass.uniforms['uCamDir'].value = _camera.worldUpTransform ? _camera.getWorldDirection().clone().applyMatrix4(_camera.worldUpTransform) : _camera.getWorldDirection();
                _clearPass.uniforms['uCamUp'].value = _camera.worldUpTransform ? _camera.up.clone().applyMatrix4(_camera.worldUpTransform) : _camera.up;
                _clearPass.uniforms['uResolution'].value.set(_w, _h);
                _clearPass.uniforms['uHalfFovTan'].value = Math.tan(THREE.Math.degToRad(_camera.fov * 0.5));

                _renderer.clearTarget(_colorTarget, false, true, false); //clear depth buffer
                _clearPass.render(_renderer, _colorTarget, null); //clear the color buffer
            }

            //Clear the id buffer(s)
            for (var i=0; i<_idTargets.length; i++) {
                _renderer.setClearColor(_white, 1.0);
                _renderer.clearTarget(_idTargets[i], true, false, false);
            }
            _occlusionIdsCopied = false;
        }

        //Clear the G-buffer target if needed and update the SSAO uniforms.
        if (isRenderTargetUsed(avp.RenderTargets.Depth)) {

            if (needClear) {
                _renderer.setClearColor(_black, 0.0);
                //Skip clearing the depth buffer as it's shared with the color target
                _renderer.clearTarget(_depthTarget, true, false, false);
            }

            var near = camera.near;
            var far = camera.far;

            _saoPass.uniforms['cameraNear'].value = near;
            _saoPass.uniforms['cameraFar'].value = far;
            _postProcPass.uniforms['cameraNear'].value = near;
            _postProcPass.uniforms['cameraFar'].value = far;

            _saoMipFirstPass.uniforms['cameraNear'].value = near;
            _saoMipFirstPass.uniforms['cameraInvNearFar'].value = 1.0 / (near - far);

            var P = camera.projectionMatrix.elements;

            //Scaling factor needed to increase contrast of our SSAO.
            if (camera.isPerspective) {
                /*  vec4(-2.0f / (width*P[0][0]),
                 -2.0f / (height*P[1][1]),
                 ( 1.0f - P[0][2]) / P[0][0],
                 ( 1.0f + P[1][2]) / P[1][1])*/
                _saoPass.uniforms[ 'projInfo' ].value.set(
                    -2.0 / (_colorTarget.width * P[0]),
                    -2.0 / (_colorTarget.height * P[5]),
                    (1.0 - P[8]) / P[0],
                    (1.0 + P[9]) / P[5]);   //TODO: Not certain if we need + or - here for OpenGL off-center matrix (original is DX-style)
                                            //would have to verify if some day we have off-center projections.
            } else {
                _saoPass.uniforms[ 'projInfo' ].value.set(
                    -2.0 / (_colorTarget.width * P[0]),
                    -2.0 / (_colorTarget.height * P[5]),
                    (1.0 - P[12]) / P[0],
                    (1.0 - P[13]) / P[5]);
            }
            _postProcPass.uniforms[   'projInfo'].value.copy(_saoPass.uniforms[ 'projInfo' ].value);
            var isOrtho = (camera.isPerspective ? 0.0 : 1.0);
            _saoPass.uniforms[   'isOrtho' ].value = isOrtho;
            _postProcPass.uniforms[   'isOrtho' ].value = isOrtho;

            var hack_scale = 0.25;
            _saoPass.uniforms[ 'projScale' ].value = hack_scale * 0.5 * (_colorTarget.height * P[5]);

            // an approximation of the size of the world; relies on the camera's near and far being reasonable.
            // This is not a great solution, as orbiting changes this number. Better would be the length of
            // the diagonal of the whole world, or perhaps the *shortest* dimension (so that cities get SAO).
            // This method is variable on the camera's view. Better is to do this in Viewer3dImpl.addModel,
            // which is where we do this now.
            //this.setAOOptions( 0.05*(camera.far-camera.near) );
        }

        if (!_settings.sao)
        {
            // Ensure that any previous SSAO computation post-process target is not blended in.
            // This looks redundant with computeSSAO()'s code setting this blend off. However, it's
            // possible for computeSSAO() to not be executed if (a) smooth navigation and AO are both on
            // and (b) the scene is moving. In that case, smooth navigation turns off AO entirely in
            // Viewer3DImpl.js and computSSAO() is never called at all.
            _blendPass.uniforms['useAO'].value = 0;
        }

        // Render the prototype/pre-model scene, which may also contain some user added custom geometry.
        // The key bit here is the "updateLights" true flag, which updates the lights for the scene; this is the
        // only place this flag is passed in as true.
        this.renderScenePart(prototypeScene, true, true, false, true);
    };

    this.copyOcclusionIds = function() {
        if (!_settings.occlusionid || !_idTargets[0] || !_occlusionIds)
            return null;
        if (!_occlusionIdsCopied)
            _renderer.readRenderTargetPixels(_idTargets[0], 0, 0, _idTargets[0].width, _idTargets[0].height, _occlusionIds);
        return _occlusionIds;
    };

    // Called incrementally by the scene traversal, potentially
    // across several frames.
    this.renderScenePart = function (scene, want_colorTarget, want_saoTarget, want_idTarget, updateLights) {

        // Need to handle occlusion ids. Get the id values when we render the first transparent scene.
        if (want_idTarget && _settings.occlusionid && _idTargets[0]
            && _occlusionIds && scene instanceof avp.RenderBatch) {
            _occlusionIdsCopied = false;
        }

        //console.time("renderScenePart");
        _saoBufferValid = false;
        _lastIDValid = false;
        var lights = updateLights ? _lights : undefined;
        //update scene with stored _fog shared from prototypeScene fog.
        scene.fog = _fog;

        //Three possibilities here -- MRT fully supported (Mac OS or native GL backends on Windows).
        //MRT supported only for targets that have exactly equal number of bitplanes and bpp (ANGLE on Windows)
        //MRT not supported at all. (Not sure --> some mobile platforms?).

        var oldMat;
        if (_mrtFloat32Works && _mrtRGBA8Works) {
            //You lucky dog! Fast code path for you.

            //In case of MRT, we ignore the which target flags, because
            //we assume the shaders are set up to write to the multiple targets anyway.
            //NOP: except idTarget, since hidden pass doesn't want that
            if (isRenderTargetUsed(avp.RenderTargets.ModelId) && want_idTarget && isRenderTargetUsed(avp.RenderTargets.Depth)) {
                _renderer.render(scene, _camera, [_colorTarget, _depthTarget].concat(_idTargets), false, lights);
            }
            else if (isRenderTargetUsed(avp.RenderTargets.Depth)) {
                _renderer.render(scene, _camera, [_colorTarget, _depthTarget], false, lights);
            }
            else if (isRenderTargetUsed(avp.RenderTargets.ModelId) && want_idTarget) {
                _renderer.render(scene, _camera, [_colorTarget].concat(_idTargets));
            }
            else /*if (_settings.antialias)*/ {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            }
            //else {
            //    _renderer.render(scene, _camera, null);
            //}

        } else if (_mrtRGBA8Works) {
            //It's something...

            if (isRenderTargetUsed(avp.RenderTargets.ModelId) && want_idTarget) {
                _renderer.render(scene, _camera, [_colorTarget].concat(_idTargets), false, lights);
            }
            else /*if (_settings.antialias)*/ {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            }

            //Float target has to be rendered separately in case we can't
            //bind MRT with different bpp targets.
            // We do not render transparent objects to the depth target, which is currently used only for ambient shadows.
            // This is the same as sortObjects === true.
            // If we someday do render to depth target for other things, such as a good near, we will need to perhaps do
            // a separate pass to get the near, rendering all objects. (We'll have a good "far", since transparent objects will be off.)
            if (isRenderTargetUsed(avp.RenderTargets.Depth) && want_saoTarget && !scene.sortObjects) {
                //Render the depth pass
                oldMat = scene.overrideMaterial;

                scene.overrideMaterial = _depthMaterial;

                // If color or ID target was written, then the z-buffer is established and we don't need to write to it any more.
                // NOTE: until cutouts are dealt with properly by the depth material, there will still be mismatches.
                // If the color buffer already wrote to the z-buffer, don't write to it. This saves memory accesses
                // and more importantly means that the depth material doesn't need to take account of any cutout materials,
                // as now only the color pass will write to the hardware z-buffer, and that pass does it right.
                if ( _depthMaterial.depthWrite !== depthWriteToZbuffer ) {
                    // set depth write state as needed
                    _depthMaterial.depthWrite = depthWriteToZbuffer;
                    _depthMaterial.needsUpdate = true;
                }

                _renderer.render(scene, _camera, _depthTarget, false);

                scene.overrideMaterial = oldMat;
            }

        } else {

            //Poor sod. No MRT at all. Three passes.

            //Render the color target first -- actually this is slower
            //because the color shader is likely a lot slower than the
            //depth+normal shader, but if we render depth first, then
            //we lose stuff behind transparent objects (potentially).
            //So we cannot do this until the progressive render is split
            //into non-transparent and transparent worlds.

            // see if depth target needs to write to z-buffer, not just read it
            var depthWriteToZbuffer = false;    // assume the color buffer will write to z already: LMV-2375
            if (want_colorTarget) {
                _renderer.render(scene, _camera, _colorTarget, false, lights);
            } else {
                // This branch will never be hit with the current code - the color target
                // is always generated. But, future-proofing.
                depthWriteToZbuffer = true;
            }

            //TODO: In 3D we really don't want to get into
            //this situation -- we don't have a reasonable ID material that
            //will work for e.g. cutout maps. We have to run basically a full
            //shader, or at least one that support opacity and alpha map checks.
            if (isRenderTargetUsed(avp.RenderTargets.ModelId) && want_idTarget) {

                // TODO: the ID buffer should also probably not write to the z-buffer if the
                // color target already has. The _idMaterial should be adjusted. The bug that may
                // occur without this fixed is that objects with cutouts may instead fully cover
                // areas they should not. See LMV-2375.
                // Also, if the color buffer is *not* rendered, then the id buffer should use a special
                // material to represent cutout materials, so cutouts are treated properly and block only
                // the areas they truly cover.
                if (_idMaterial) {
                    oldMat = scene.overrideMaterial;
                    scene.overrideMaterial = _idMaterial;
                    //TODO: This code path does not work in case multiple id targets are attached
                    //We need a second ID material that renders modelId instead of dbId.
                    _renderer.render(scene, _camera, _idTargets[0], false);
                    scene.overrideMaterial = oldMat;
                } else {
                    _renderer.setProgramPrefix(1, "#define ID_COLOR", "#define ID_COLOR");
                    //TODO: This code path does not work in case multiple id targets are attached
                    //We need a second ID material that renders modelId instead of dbId.
                    _renderer.render(scene, _camera, _idTargets[0], false);
                    _renderer.setProgramPrefix(0, "", "");
                }
                depthWriteToZbuffer = false;
            }

            // We do not render transparent objects to the depth target, which is currently used only for ambient shadows.
            // This is the same as sortObjects === true.
            // If we someday do render to depth target for other things, such as a good near, we will need to perhaps do
            // a separate pass to get the near, rendering all objects. (We'll have a good "far", since transparent objects will be off.)
            if (isRenderTargetUsed(avp.RenderTargets.Depth) && want_saoTarget && !scene.sortObjects) {
                //Render the depth pass
                oldMat = scene.overrideMaterial;

                // If color or ID target was written, then the z-buffer is established and we don't need to write to it any more.
                // NOTE: until cutouts are dealt with properly by the depth material, there will still be mismatches.
                // If the color buffer already wrote to the z-buffer, don't write to it. This saves memory accesses
                // and more importantly means that the depth material doesn't need to take account of any cutout materials,
                // as now only the color pass will write to the hardware z-buffer, and that pass does it right.
                if ( _depthMaterial.depthWrite !== depthWriteToZbuffer ) {
                    // set depth write state as needed
                    _depthMaterial.depthWrite = depthWriteToZbuffer;
                    _depthMaterial.needsUpdate = true;
                }

                scene.overrideMaterial = _depthMaterial;

                _renderer.render(scene, _camera, _depthTarget, false);

                scene.overrideMaterial = oldMat;
            }

        }

        //Do a second pass to render edges, if needed.
        //TODO: Investigate if it will be faster to integrate
        //this draw call into the main color target render call, similar
        //to how decal materials are done inside the renderer.
        if (want_colorTarget && _renderEdges) {
            oldMat = scene.overrideMaterial;
            scene.overrideMaterial = _edgeMaterial;
            _renderer.context.depthFunc(_renderer.context.LESS); //hope to avoid some line-on-line overdraw this way
            _renderer.render(scene, _camera, [_colorTarget], false);
            _renderer.context.depthFunc(_renderer.context.LEQUAL);
            scene.overrideMaterial = oldMat;
        }

        //console.timeEnd("renderScenePart");
    };

    function createOcclusionTarget() {
        _occlusionTarget = new THREE.WebGLRenderTarget(
            _settings.deviceWidth, _settings.deviceHeight,
            {  minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: false
            });
        _occlusionTarget.generateMipmaps = false; 
        _occlusionTarget.shareDepthFrom = _colorTarget;
    }

    function addVerts(bboxVerts, toVerts, boxes, from) {
        // Eight corners of the box
        bboxVerts[toVerts++] = boxes[from];
        bboxVerts[toVerts++] = boxes[from + 1];
        bboxVerts[toVerts++] = boxes[from + 2];

        bboxVerts[toVerts++] = boxes[from + 3];
        bboxVerts[toVerts++] = boxes[from + 1];
        bboxVerts[toVerts++] = boxes[from + 2];

        bboxVerts[toVerts++] = boxes[from];
        bboxVerts[toVerts++] = boxes[from + 4];
        bboxVerts[toVerts++] = boxes[from + 2];

        bboxVerts[toVerts++] = boxes[from + 3];
        bboxVerts[toVerts++] = boxes[from + 4];
        bboxVerts[toVerts++] = boxes[from + 2];

        bboxVerts[toVerts++] = boxes[from];
        bboxVerts[toVerts++] = boxes[from + 1];
        bboxVerts[toVerts++] = boxes[from + 5];

        bboxVerts[toVerts++] = boxes[from + 3];
        bboxVerts[toVerts++] = boxes[from + 1];
        bboxVerts[toVerts++] = boxes[from + 5];

        bboxVerts[toVerts++] = boxes[from];
        bboxVerts[toVerts++] = boxes[from + 4];
        bboxVerts[toVerts++] = boxes[from + 5];

        bboxVerts[toVerts++] = boxes[from + 3];
        bboxVerts[toVerts++] = boxes[from + 4];
        bboxVerts[toVerts++] = boxes[from + 5];
        return toVerts;        
    }

    function addIndices(bboxIndices, toIndices, indexBase) {
        // -y
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 1;
        bboxIndices[toIndices++] = indexBase + 5;
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 5;
        bboxIndices[toIndices++] = indexBase + 4;

        // -z
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 2;
        bboxIndices[toIndices++] = indexBase + 3;
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 3;
        bboxIndices[toIndices++] = indexBase + 1;

        // -x
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 4;
        bboxIndices[toIndices++] = indexBase + 6;
        bboxIndices[toIndices++] = indexBase;
        bboxIndices[toIndices++] = indexBase + 6;
        bboxIndices[toIndices++] = indexBase + 2;

        // +z
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 6;
        bboxIndices[toIndices++] = indexBase + 4;
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 4;
        bboxIndices[toIndices++] = indexBase + 5;

        // +x
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 5;
        bboxIndices[toIndices++] = indexBase + 1;
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 1;
        bboxIndices[toIndices++] = indexBase + 3;

        // +y
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 3;
        bboxIndices[toIndices++] = indexBase + 2;
        bboxIndices[toIndices++] = indexBase + 7;
        bboxIndices[toIndices++] = indexBase + 2;
        bboxIndices[toIndices++] = indexBase + 6;

        return toIndices;
    }

    function createBBoxGeometry(boxes, fragIds, start, length) {
        var bboxVerts = new Float32Array(length * 24);
        var bboxIndices = new Uint16Array(length * 36);
        var toVerts = 0, toIndices = 0, indexBase = 0;
        length += start;
        for ( ; start < length; ++start, indexBase += 8) {
            // Copy indices and vertices for the box
            toIndices = addIndices(bboxIndices, toIndices, indexBase);
            toVerts = addVerts(bboxVerts, toVerts, boxes, fragIds[start] * 6);
        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(bboxVerts, 3));
        geometry.addAttribute('index', new THREE.BufferAttribute(bboxIndices, 1));
        geometry.streamingDraw = true;
        geometry.streamingIndex = true;
        return geometry;
    }

    function createInstancedBBoxGeometry(boxes, fragIds, start, length) {
        // Don't interleave the min and max vertices.
        var minVerts = new Float32Array(length * 3);
        var scaleVerts = new Float32Array(length * 3);
        var toVerts = 0;
        var end = length + start;
        for ( ; start < end; ++start) {
            var from = fragIds[start] * 6;
            scaleVerts[toVerts] = boxes[from + 3] - boxes[from];
            minVerts[toVerts++] = boxes[from++];
            scaleVerts[toVerts] = boxes[from + 3] - boxes[from];
            minVerts[toVerts++] = boxes[from++];
            scaleVerts[toVerts] = boxes[from + 3] - boxes[from];
            minVerts[toVerts++] = boxes[from++];
        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(_unitCubeVerts, 3));
        geometry.addAttribute('index', new THREE.BufferAttribute(_unitCubeIndices, 1));
        var minAttr = new THREE.BufferAttribute(minVerts, 3);
        minAttr.divisor = 1;
        var scaleAttr = new THREE.BufferAttribute(scaleVerts, 3);
        scaleAttr.divisor = 1;
        geometry.addAttribute('instOffset', minAttr);
        geometry.addAttribute('instScaling', scaleAttr);
        geometry.numInstances = length;
        geometry.streamingDraw = true;
        geometry.streamingIndex = true;
        return geometry;
    }

    function createUnitCube() {
        // Create unit cube vertex and index buffers
        _unitCubeVerts = new Float32Array(24);
        _unitCubeIndices = new Uint16Array(36);
        addIndices(_unitCubeIndices, 0, 0);
        addVerts(_unitCubeVerts, 0, [0, 0, 0, 1, 1, 1], 0);
    }

    // Create the occlusion materials for testing. The materials can test one pack file
    // in each color component, R, G, B, or A. The colors are setup so we can blend
    // each component separately using D = D * S. The target is initialized to opaque
    // white and a 0 in a component means a pixel was drawn. Doing it this way
    // makes it easier to see the results if we need to look at the bitmap.
    // The colors and alphas are ordered to match the byte ordering in the pixel.
    var colors = [
        [ 0, 1, 1],
        [ 1, 0, 1],
        [ 1, 1, 0],
        [ 1, 1, 1]
    ];
    var alphas = [1, 1, 1, 0];
    function createOcclusionMaterials(length, instanced) {
        var useInstancing = !!instanced;
        for (var i = _occlusionMaterials[instanced].length; i < length; ++i) {
            var occlusionMaterial = avs.createShaderMaterial(WGS.OcclusionShader);
            occlusionMaterial.useInstancing = useInstancing;
            occlusionMaterial.depthWrite = false;
            occlusionMaterial.uniforms.color.value.set(colors[i][0], colors[i][1], colors[i][2]);
            occlusionMaterial.uniforms.opacity.value = alphas[i];
            occlusionMaterial.defaultAttributeValues.instRotate = [1, 0, 0, 0];
            occlusionMaterial.blending = THREE.CustomBlending;
            occlusionMaterial.blendDst = THREE.SrcColorFactor;
            occlusionMaterial.blendSrc = THREE.ZeroFactor;
            occlusionMaterial.blendEquation = THREE.AddEquation;
            occlusionMaterial.transparent = true;
            _occlusionMaterials[instanced][i] = occlusionMaterial;
        }
    }

    // For debugging, show occlusion target for some pack files
    var showOcclusion = {};
    // Return whether the fragment ids are occluded
    this.occlusionTest = function(boxes, threshold, fragIds, useInstancing, packIds) {
        if (!fragIds || fragIds.length <= 0 || fragIds.length > 4)
            return Promise.reject({error : "fragIds invalid. Must be a nonempty array of fragment id arrays with length <= 4"});

        var counts = [0, 0, 0, 0];
        var visibleCount = 0;
        useInstancing = (useInstancing && _renderer.supportsInstancedArrays()) ? 1 : 0;
        if (!_occlusionMaterials[useInstancing] || _occlusionMaterials[useInstancing].length < fragIds.length)
            createOcclusionMaterials(fragIds.length, useInstancing);

        if (useInstancing && !_unitCubeVerts)
            createUnitCube();

        // Create a scene for the boxes
        if (!_occlusionScene)
            _occlusionScene = new THREE.Scene();
        _occlusionScene.frustumCulled = false;

        // Be careful and don't create buffers to large for short indices
        // 8 vertices per fragment box out of 64K vertices max means we
        // can't do more than 8K fragments per buffer. Cut this in half,
        // and only allow 4096 fragments per buffer. If we are instancing
        // then the buffers only hold a single point per instance, so
        // allow 32K fragments.
        var maxSize = useInstancing ? 32768 : 4096;
        var i;
        for (i = 0; i < fragIds.length; ++i ) {
            var fragIdList = fragIds[i];
            if (fragIdList && fragIdList.length > 0) {
                counts[i] = threshold;
                ++visibleCount;
                var occlusionMaterial = _occlusionMaterials[useInstancing][i];
                var length = fragIdList.length;
                var start = 0, end;
                for ( ; start < length; start += end) {
                    end = Math.min(maxSize, length - start);

                    // Build buffer for the fragment boxes
                    var geometry = useInstancing ? createInstancedBBoxGeometry(boxes, fragIdList, start, end)
                        : createBBoxGeometry(boxes, fragIdList, start, end);
                    var mesh = new THREE.Mesh(geometry, occlusionMaterial);
                    mesh.frustumCulled = false;
                    _occlusionScene.add(mesh);
                }
            }
        }

        // Clear render target
        if (!_occlusionTarget)
            createOcclusionTarget();
        _renderer.setClearColor(_white, 1);

        // Render the scene
        _renderer.setRenderTarget(_occlusionTarget);
        _renderer.clear(true, false, false);
        _renderer.render(_occlusionScene, _camera, _occlusionTarget, false, null);

        // Some cleanup
        _renderer.clearBlend();
        _occlusionScene.children.forEach(function(mesh) {
            mesh.geometry.dispose();
        });
        _occlusionScene.remove.apply(_occlusionScene, _occlusionScene.children); // Remove all children from scene

        // For debugging, show occlusion target for some pack files
        if (showOcclusion[packIds[0]] || showOcclusion[packIds[1]] || showOcclusion[packIds[2]] || showOcclusion[packIds[3]])
            this.getRenderTargetPixels('occlusion');

        // Get the result.
        if (!_occlusionTest)
            _occlusionTest = new Uint8Array(_settings.deviceWidth * 4 * _settings.deviceHeight);
        _renderer.readRenderTargetPixels(_occlusionTarget, 0, 0, _settings.deviceWidth, _settings.deviceHeight, _occlusionTest);

        // Look for pixels.
        switch (fragIds.length) {
        case 1:
            for (i = _occlusionTest.length; visibleCount > 0 && (i -= 4) >= 0; ) {
                if (!_occlusionTest[i]) {
                    counts[0] -= 1;
                    visibleCount -= !counts[0];
                }
            }
            return Promise.resolve([counts[0] <= 0]);
        case 2:
            for (i = _occlusionTest.length; visibleCount > 0 && (i -= 4) >= 0; ) {
                if (!_occlusionTest[i]) {
                    counts[0] -= 1;
                    visibleCount -= !counts[0];
                }
                if (!_occlusionTest[i + 1]) {
                    counts[1] -= 1;
                    visibleCount -= !counts[1];
                }
            }
            return Promise.resolve([counts[0] <= 0, counts[1] <= 0]);
        case 3:
            for (i = _occlusionTest.length; visibleCount > 0 && (i -= 4) >= 0; ) {
                if (!_occlusionTest[i]) {
                    counts[0] -= 1;
                    visibleCount -= !counts[0];
                }
                if (!_occlusionTest[i + 1]) {
                    counts[1] -= 1;
                    visibleCount -= !counts[1];
                }
                if (!_occlusionTest[i + 2]) {
                    counts[2] -= 1;
                    visibleCount -= !counts[2];
                }
            }
            return Promise.resolve([counts[0] <= 0, counts[1] <= 0, counts[2] <= 0]);
        case 4:
            for (i = _occlusionTest.length; visibleCount > 0 && (i -= 4) >= 0; ) {
                if (!_occlusionTest[i]) {
                    counts[0] -= 1;
                    visibleCount -= !counts[0];
                }
                if (!_occlusionTest[i + 1]) {
                    counts[1] -= 1;
                    visibleCount -= !counts[1];
                }
                if (!_occlusionTest[i + 2]) {
                    counts[2] -= 1;
                    visibleCount -= !counts[2];
                }
                if (!_occlusionTest[i + 3]) {
                    counts[3] -= 1;
                    visibleCount -= !counts[3];
                }
            }
            return Promise.resolve([counts[0] <= 0, counts[1] <= 0, counts[2] <= 0, counts[3] <= 0]);
        }
    };

    this.clearAllOverlays = function () {
        _renderer.clearTarget(_overlayTarget, true, false, false);
    };

    this.renderOverlays = function (overlays, lights) {
        var haveOverlays = 0;

        _isRenderingOverlays = true;

        for (var key in overlays) {
            var p = overlays[key];
            var s = p.scene;
            var c = p.camera ? p.camera : _camera;
            if (s.children.length) {

                if (!haveOverlays) {
                    haveOverlays = 1;

                    //clear the overlay target once we see
                    //the first non-empty overlay scene
                    _renderer.setClearColor(_black, 0.0);
                    _renderer.clearTarget(_overlayTarget, true, false, false);
                }

                //NOTE: This logic renders the top side of the highlighted objects first,
                //and then the bottom side. The reason is that the top side material is opaque,
                //while we want to render the hidden parts of the object with faint transparency.
                //For objects that covers themselves and are also covered by other objects
                //this is a problem, since the opaque parts would prevent the back parts from showing.

                //However, edge rendering uses painter's algorithm settings for the depth,
                //since we don't care to show hidden edges from under top edges.

                //Render top side of the object using the primary highlight material
                if (p.materialPre) {
                    s.overrideMaterial = p.materialPre;
                }
                _renderer.render(s, c, _overlayTarget, false, lights);


                if (p.materialPost) {
                    //render hidden edges
                    _isRenderingHidden = true; //flag used when getting the correct override material for the hidden pass
                    _renderer.context.depthFunc(_renderer.context.GREATER);

                    if (_renderEdges) {
                        _edgeMaterial.depthWrite = false;
                        _edgeMaterial.depthTest = false;
                        s.overrideMaterial = _edgeMaterial;
                        _renderer.render(s, c, _overlayTarget, false);
                    }

                    //Render bottom side of the object
                    //for selection that's done using light transparency to show
                    //areas the object spans under other objects
                    s.overrideMaterial = p.materialPost;
                    _renderer.render(s, c, _overlayTarget, false, lights);

                    _renderer.context.depthFunc(_renderer.context.LEQUAL);
                    _isRenderingHidden = false;
                }

                //Render top side edges last
                if (_renderEdges && p.materialPre) {
                    _edgeMaterial.depthWrite = false;
                    _edgeMaterial.depthTest = true;
                    s.overrideMaterial = _edgeMaterial;
                    _renderer.render(s, c, _overlayTarget, false);
                }

                s.overrideMaterial = null;
            }
        }

        //Back to normal edge mode
        _isRenderingOverlays = false;
        _edgeMaterial.depthWrite = true;
        _edgeMaterial.depthTest = true;

        _blendPass.uniforms['useOverlay'].value = haveOverlays;
    };


    this.computeSSAO = function(skipAOPass) {
        if (!skipAOPass && _settings.sao && !_settings.postProcShaded) {

            //console.time("SAO");
            if (!_saoBufferValid) {
                //Create mip levels for the depth/normals target
                if (_depthMipMap && _depthMipMap.length) {
                    var prevMip = _depthMipMap[0];
                    _saoMipFirstPass.uniforms['resolution'].value.set(1.0 / prevMip.width, 1.0 / prevMip.height);
                    _saoMipFirstPass.render(_renderer, prevMip, _depthTarget);
                    for (var i = 1; i < _depthMipMap.length; i++) {
                        var curMip = _depthMipMap[i];
                        _saoMipPass.uniforms['resolution'].value.set(1.0 / curMip.width, 1.0 / curMip.height);
                        _saoMipPass.render(_renderer, curMip, prevMip);
                        prevMip = curMip;
                    }
                }

                _saoPass.render(_renderer, _postTarget2, _colorTarget);

                //console.timeEnd("SAO");
                //console.time("SAOblur");
                //Do the bilateral blur
                _saoBlurPass.uniforms['axis'].value.set(1, 0);
                _saoBlurPass.render(_renderer, _postTarget1, _postTarget2);
                _saoBlurPass.uniforms['axis'].value.set(0, 1);
                _saoBlurPass.render(_renderer, _postTarget2, _postTarget1);

                _saoBufferValid = true;
            }

            _blendPass.uniforms['useAO'].value = 1;
            //console.timeEnd("SAOblur");
        } else {
            // Ensure that any previous SSAO computation post-process target is not blended in.
            _blendPass.uniforms['useAO'].value = 0;
        }

    };

    this.presentBuffer = function (userFinalPass) {

        if (!_renderer)
            return;

        //See if the blend pass is trivial 1:1, in which
        //case we can just use the main color target for
        //the final pass and skip the blend pass.
        //NOTE: This needs to be adjusted if the blend pass ever
        //does the tone mapping again.
        //TODO: Another possible improvement is to support blending of the SAO
        //inside the FXAA pass, in case the blend pass is just modulating by the AO value.
        var canSkipBlendPass = !_settings.sao &&
                               !_blendPass.uniforms['useOverlay'].value &&
                               // idAtPixel can return -1 for the ID when nothing is there
                               (_lastHighlightId === 0 || _lastHighlightId === -1) &&
                               (_lastHighlightModelId === 0 || _lastHighlightModelId === -1);

        if (canSkipBlendPass) {

            if (_settings.antialias) {

                if (userFinalPass) {
                    _fxaaPass.render(_renderer, _postTarget1, _colorTarget);
                    userFinalPass.render(_renderer, null, _postTarget1);
                } else if (_settings.postProcShaded) {
                    _postProcPass.render(_renderer, _postTarget1, _colorTarget);
                    _fxaaPass.render(_renderer, null, _postTarget1);
                } else {
                    _fxaaPass.render(_renderer, null, _colorTarget);
                }
            }
            else if (userFinalPass) {
                userFinalPass.render(_renderer, null, _colorTarget);
            } else if (_settings.postProcShaded) {
                _postProcPass.render(_renderer, _postTarget1, _colorTarget);
                _copyPass.render(_renderer, null, _postTarget1);
            } else {
                _copyPass.render(_renderer, null, _colorTarget);
            }

        } else {

            //console.time("post");
            //If we have fxaa, do the blending into an offscreen target
            //then FXAA into the final target
            if (_settings.antialias) {
                _blendPass.render(_renderer, _postTarget1, _colorTarget);

                if (userFinalPass) {
                    _fxaaPass.render(_renderer, _postTarget2, _postTarget1);
                    userFinalPass.render(_renderer, null, _postTarget2);
                } else if (_settings.postProcShaded) {
                    _postProcPass.render(_renderer, _postTarget2, _postTarget1);
                    _fxaaPass.render(_renderer, null, _postTarget2);
                } else {
                    _fxaaPass.render(_renderer, null, _postTarget1);
                }
            }
            else {
                if (userFinalPass) {

                    _blendPass.render(_renderer, _postTarget1, _colorTarget);
                    userFinalPass.render(_renderer, null, _postTarget1);

                } else {
                    if (_settings.postProcShaded) {
                        _blendPass.render(_renderer, _postTarget1, _colorTarget);
                        _postProcPass.render(_renderer, _postTarget2, _postTarget1);
                        _copyPass.render(_renderer, null, _postTarget2);
                    } else {
                        _blendPass.render(_renderer, null, _colorTarget);
                    }
                }
            }
        }

    };


    this.composeFinalFrame = function (skipAOPass, skipPresent) {
        //Apply the post pipeline and then show to screen.
        //Note that we must preserve the original color buffer
        //so that we can update it progressively

        // always called, so that useAO is set to 0 if not in use.
        this.computeSSAO(skipAOPass);

        if (!skipPresent)
            this.presentBuffer();

        //console.timeEnd("post");

    };

    this.cleanup = function () {
        if (_colorTarget) {
            _colorTarget.dispose();
            _colorTarget = null;
        }

        if (_depthTarget) {
            _depthTarget.dispose();
            _depthTarget = null;
        }

        if (_overlayTarget) {
            _overlayTarget.dispose();
            _overlayTarget = null;
        }

        if (_postTarget1) {
            _postTarget1.dispose();
            _postTarget1 = null;
        }

        if (_postTarget2) {
            _postTarget2.dispose();
            _postTarget2 = null;
        }

        if (_depthMipMap) {
            for (var i=0; i<_depthMipMap.length; i++) {
                _depthMipMap[i].dispose();
            }

            _depthMipMap = [];
        }

        if (_occlusionTarget) {
            _occlusionTarget.dispose();
            _occlusionTarget = null;
        }

        _occlusionTest = null;
    };

    this.setSize = function (w, h, force) {

        _w = w;
        _h = h;

        _settings.logicalWidth = w;
        _settings.logicalHeight = h;

        //Just a way to release the targets in cases when
        //we use a custom render context and don't need this one
        //temporarily
        if ((w === 0 && h === 0) || !_renderer) {
            this.cleanup();
            return;
        }

        var sw = 0 | (w * _renderer.getPixelRatio());
        var sh = 0 | (h * _renderer.getPixelRatio());

        _settings.deviceWidth = sw;
        _settings.deviceHeight = sh;

        _renderer.setSize(w, h);

        //avp.logger.log("width: " + sw + " height: " + sh);

        var resX = 1.0 / sw;
        var resY = 1.0 / sh;

        var i;

        //supersample antialiasing
        //Create a somewhat larger render target, that is power of 2 size and has mipmap
        if (_settings.useSSAA || (_settings.postProcShaded && _renderer.getPixelRatio() <= 1)) {
            /*
                sw *= 3 / _renderer.getPixelRatio();
                sh *= 3 / _renderer.getPixelRatio();

                var w = 1;
                while (w < sw) w *= 2;
                var h = 1;
                while (h < sh) h *= 2;

                sw = w;
                sh = h;
                */
                sw *=2;
                sh *=2;

            force = true;
        }

        //Just the regular color target -- shares depth buffer
        //with the depth target.
        if (force || !_colorTarget || _colorTarget.width != sw || _colorTarget.height != sh) {

            avp.logger.log("Reallocating render targets.");
            this.cleanup();

            _colorTarget = new THREE.WebGLRenderTarget(sw, sh,
                {   minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBFormat,
                    type: _settings.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
                    //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                    stencilBuffer: false
                });
            // three.js has a flaw in its constructor: the generateMipmaps value is always initialized to true
            _colorTarget.generateMipmaps = false; 

            _overlayTarget = new THREE.WebGLRenderTarget(sw, sh,
                {  minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    stencilBuffer: false
                });
            _overlayTarget.generateMipmaps = false; 


            _overlayTarget.shareDepthFrom = _colorTarget;


            _depthTarget = null;
            _postTarget1 = null;
            _postTarget2 = null;
            _depthMipMap = [];
        }

        if (isRenderTargetUsed(avp.RenderTargets.Post1))
        {
            if (force || !_postTarget1 || _postTarget1.width != sw || _postTarget1.height != sh) {
                //We need one extra post target if FXAA is on, so
                //to use as intermediate from Blend->FXAA pass.
                _postTarget1 = new THREE.WebGLRenderTarget(sw, sh,
                    {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat,
                        //anisotropy: 0,
                        //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                        stencilBuffer: false,
                        depthBuffer: false
                    });
                _postTarget1.generateMipmaps = false; 
           }
        }

        if (!_postTarget2 && isRenderTargetUsed(avp.RenderTargets.Post2)) {
            _postTarget2 = _postTarget1.clone();
        }

        if (isRenderTargetUsed(avp.RenderTargets.Depth)) {
            if (force || !_depthTarget || _depthTarget.width != sw || _depthTarget.height != sh) {

                var format = THREE.FloatType;
                if (av.isMobileDevice()) {
                    format = THREE.HalfFloatType;
                }

                _depthTarget = new THREE.WebGLRenderTarget(sw, sh,
                    { minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: _renderTargetFormat,
                        type: format,
                        stencilBuffer: false});
                _depthTarget.shareDepthFrom = _colorTarget;

                //SSAO depth/normals mip maps. Those are "manually" created
                //because we use custom sampling. Also, they are separately bound into
                //the shader because there doesn't seem to be an easy way to load them
                //as mip levels of the same texture, in the case they were render buffers initially.
                _depthMipMap = [];
                for (var j = 0; j < 5; j++) {
                    var mip = new THREE.WebGLRenderTarget(0 | (sw / (2 << j)), 0 | (sh / (2 << j)),
                        {   minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            format: THREE.RGBAFormat,
                            //type:THREE.FloatType,
                            depthBuffer: false,
                            stencilBuffer: false});
                    mip.generateMipmaps = false;
                    _depthMipMap.push(mip);
                    _saoPass.uniforms['tDepth_mip' + (j + 1)].value = mip;
                }

                //Re-check this when render targets change
                _mrtFloat32Works = _renderer.verifyMRTWorks([_colorTarget, _depthTarget]);
            }

            _saoPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoPass.uniforms[ 'resolution' ].value.set(resX, resY);
            _saoPass.uniforms[ 'tDepth' ].value = _depthTarget;

            _saoBlurPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoBlurPass.uniforms[ 'resolution' ].value.set(resX, resY);

            _postProcPass.uniforms['tDepth'].value = _depthTarget;
        }

        if (isRenderTargetUsed(avp.RenderTargets.ModelId)) {
            if (force || !_idTargets[0] || _idTargets[0].width != sw || _idTargets[0].height != sh) {
                for (i=0; i<_idTargets.length; i++) {
                    _idTargets[i] && _idTargets[i].dispose();
                }
                _idTargets = [];
                for (i=0; i<_settings.numIdTargets; i++) {
                    _idTargets[i] = new THREE.WebGLRenderTarget(sw, sh,
                        {   minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            format: THREE.RGBFormat,
                            type: THREE.UnsignedByteType,
                            stencilBuffer: false
                        });
                    _idTargets[i].generateMipmaps = false; 

                    _idTargets[i].shareDepthFrom = _colorTarget;

                    //Set this flag to avoid checking frame buffer status every time we read
                    //a pixel from the ID buffer. We know the ID target is compatible with readPixels.
                    _idTargets[i].canReadPixels = true;
                }

                //Re-check this when render targets change
                _mrtRGBA8Works = _renderer.verifyMRTWorks([_colorTarget].concat(_idTargets));
                if (!_mrtRGBA8Works) {
                    avp.logger.warn("ID buffer requested, but MRT is not supported. Some features will not work.");
                }

                _occlusionIds = new Uint8Array(4 * _idTargets[0].width * _idTargets[0].height);
            }

            _postProcPass.uniforms['tID'].value = _idTargets[0];
            _postProcPass.uniforms['tID'].value = _idTargets[0];

        } else if (_idTargets[0]) {
            _occlusionIds = null;
            for (i=0; i<_idTargets.length; i++) {
                _idTargets[i].dispose();
                _idTargets[i] = null;
            }
            // make sure no _idTargets are defined, since they've been released. LMV-2691
            _idTargets.length = 0;
        }


        _fxaaPass.uniforms[ 'uResolution' ].value.set(resX, resY);
        _postProcPass.uniforms[ 'resolution' ].value.set(resX, resY);

        _blendPass.uniforms[ 'tOverlay' ].value = _overlayTarget;
        _blendPass.uniforms[ 'tAO' ].value = _postTarget2;
        _blendPass.uniforms[ 'useAO' ].value = _settings.sao ? 1 : 0;
        _blendPass.uniforms[ 'resolution' ].value.set(resX, resY);
        _blendPass.uniforms[ 'tID' ].value = _idTargets[0];

    };

    

    this.getMaxAnisotropy = function () {
        return _renderer ? _renderer.getMaxAnisotropy() : 0;
    };

    // HACK: returns MRT flags required by this render context
    // so that the flags can be passed to the material manager
    this.mrtFlags = function() {
        return {
            mrtNormals: _mrtFloat32Works && isRenderTargetUsed(avp.RenderTargets.Depth),
            mrtIdBuffer: (_mrtRGBA8Works && isRenderTargetUsed(avp.RenderTargets.ModelId)) ? _settings.numIdTargets : undefined
        };
    };
    

    this.getAntialiasing = function () {
       return _settings.antialias;
    };

    this.initPostPipeline = function (useSAO, useFXAA) {

        //TODO: Do we want to move the IE check to higher level code?
        _settings.sao = useSAO && !av.isIE11;
        _settings.antialias = useFXAA && !av.isIE11;

        if (_settings.haveTwoSided) {
            forEachDepthMaterial(function(mat){
                mat.side = THREE.DoubleSide;
            });
        }

        //TODO: do we really need to update all these or just the depthMaterial?
        forEachDepthMaterial(function(mat) {
            mat.needsUpdate = true;
        });
        _saoPass.material.needsUpdate = true;
        _saoBlurPass.material.needsUpdate = true;
        _saoMipFirstPass.material.needsUpdate = true;
        _saoMipPass.material.needsUpdate = true;
        _fxaaPass.material.needsUpdate = true;
        _postProcPass.material.needsUpdate = true;
        _blendPass.material.needsUpdate = true;
        _clearPass.material.needsUpdate = true;
        _copyPass.material.needsUpdate = true;

        //Also reallocate the render targets
        this.setSize(_w, _h);
    };

    this.setClearColors = function (colorTop, colorBot) {
        if (!colorBot) {
            _clearColor = colorTop.clone();
        }
        //If the gradient is trivial, we can use a simple clear instead.
        else if (colorTop.equals(colorBot) || _isWeakDevice) {
            _clearColor = new THREE.Color(
                0.5 * (colorTop.x + colorBot.x),
                0.5 * (colorTop.y + colorBot.y),
                0.5 * (colorTop.z + colorBot.z));
        } else {
            _clearColor = undefined;
        }

        if (!_clearColor) {
            _clearPass.uniforms.color1.value.copy(colorTop);
            _clearPass.uniforms.color2.value.copy(colorBot);
        }
    };


    this.setAOEnabled = function(enabled) {
        _settings.sao = enabled;
        // recreate required buffers when sao is turned on
        this.setSize(_w, _h);
    };

    this.setAOOptions = function (radius, intensity, opacity) {
        
        if (radius !== undefined) {
            _saoPass.uniforms[ 'radius' ].value = radius;
            _saoPass.uniforms[ 'bias' ].value = radius * av.isMobileDevice() ? 0.1 : 0.01;
            _saoBlurPass.uniforms[ 'radius' ].value = radius;
        }
        if (intensity !== undefined) {
            _saoPass.uniforms[ 'intensity' ].value = intensity;
        }
        //Opacity handles undefined differently (it uses default if undefined given)
        //until all user-facing calls to setAOOptions can handle the new opacity setting.
        if (opacity !== undefined) {
            _blendPass.uniforms[ 'aoOpacity'].value = opacity;
        } else {
            _blendPass.uniforms[ 'aoOpacity'].value = 1.0;
        }
        _saoBufferValid = false;
    };

    this.getAOEnabled = function() {
        return _settings.sao;
    };

    this.getAORadius = function () {
        return _saoPass.uniforms['radius'].value;
    };

    this.getAOIntensity = function() {
        return _saoPass.uniforms['intensity'].value;
    };

    this.setCubeMap = function(map) {
        _clearPass.material.envMap = map;
        if (!map)
            this.toggleEnvMapBackground(false);
    };

    this.setEnvRotation = function(rotation) {
        _envRotation = rotation;
        _clearPass.material.envRotationSin = Math.sin(rotation);
        _clearPass.material.envRotationCos = Math.cos(rotation);
    };

    this.getEnvRotation = function() {
        return _envRotation;
    };

    this.setEnvExposure = function(exposure) {
        _clearPass.uniforms['envMapExposure'].value = Math.pow(2.0, exposure);

        //The renderer overwrites the uniform's value based on the material's
        //property in refreshUniformsIBL, so set it there too.
        _clearPass.material.envMapExposure = Math.pow(2.0, exposure);
        _clearPass.material.needsUpdate = true;
    };

    this.setTonemapExposureBias = function (bias) {
        _exposureBias = bias;

        _clearPass.uniforms['exposureBias'].value = Math.pow(2.0, bias);

        //_blendPass.uniforms['exposureBias'].value = Math.pow(2.0, bias);
    };

    this.getExposureBias = function () {
        return _exposureBias;
    };

    //Required for switching camera for stereo rendering
    this.setCamera = function (camera) {
        _camera = camera;
    };

    this.setTonemapMethod = function (value) {

        _tonemapMethod  = value;

        if (value === 0) {
        /*
            if (_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = false;
                this.setSize(_w, _h, true);
            }
            */
            _renderer.gammaInput = false;
        }
        else {
        /*
            if (!_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = true;
                this.setSize(_w, _h, true);
            }
        */
            //Tell the renderer to linearize all material colors
            _renderer.gammaInput = true;
        }

        _clearPass.material.tonemapOutput = _tonemapMethod;
        _clearPass.material.needsUpdate = true;

        // _blendPass.uniforms['toneMapMethod'].value = value;

    };

    this.getToneMapMethod = function () {
        return _tonemapMethod;
    };

    this.toggleTwoSided = function (isTwoSided) {

        //In case the viewer encounters two-sided materials
        //it will let us know, so that we can update
        //the override material used for the SAO G-buffer to also
        //render two sided.
        if (_settings.haveTwoSided != isTwoSided) {
            if (_depthMaterial) {
                forEachDepthMaterial(function(mat) {
                    mat.side = isTwoSided ? THREE.DoubleSide : THREE.FrontSide;
                    mat.needsUpdate = true;
                });
            }
        }
        _settings.haveTwoSided = isTwoSided;
    };

    this.toggleEdges = function(state) {
        _renderEdges = state;
    };

    this.preloadPostProcessStyle = function (style) {
        if ( style == undefined ) {
            // if no argument given, load them all
            this.preloadPostProcessStyle("graphite");
            this.preloadPostProcessStyle("pencil");
            return;
        }
        switch (style) {
            case "graphite":
                if ( _graphiteMaps[0] === undefined ) { // TODO better way to test? Note it differs from the one below
                    for ( var i = 0; i < 8; i++ ) {
                        var file = Autodesk.Viewing.Private.getResourceUrl("res/postprocess/Graphite" + (i+1) + ".png");
                        _graphiteMaps[i] = THREE.ImageUtils.loadTexture(file); 
                        //_graphiteMaps[i] = THREE.ImageUtils.loadTexture("http://localhost:8000/build/res/postprocess/Graphite" + (i+1) + ".png"); 
                        _graphiteMaps[i].wrapS = _graphiteMaps[i].wrapT = THREE.RepeatWrapping;
                    }
                    _postProcPass.uniforms['tGraphite1'].value = _graphiteMaps[0];
                    _postProcPass.uniforms['tGraphite2'].value = _graphiteMaps[1];
                    _postProcPass.uniforms['tGraphite3'].value = _graphiteMaps[2];
                    _postProcPass.uniforms['tGraphite4'].value = _graphiteMaps[3];
                    _postProcPass.uniforms['tGraphite5'].value = _graphiteMaps[4];
                    _postProcPass.uniforms['tGraphite6'].value = _graphiteMaps[5];
                    _postProcPass.uniforms['tGraphite7'].value = _graphiteMaps[6];
                    _postProcPass.uniforms['tGraphite8'].value = _graphiteMaps[7];
                }
                break;
            case "pencil":
                if ( _pencilMap === null ) { // TODO better way to test?
                    _pencilMap = THREE.ImageUtils.loadTexture( Autodesk.Viewing.Private.getResourceUrl("res/postprocess/ColorPencil_02.png"));
                    _pencilMap.wrapS = _pencilMap.wrapT = THREE.RepeatWrapping;
                    _pencilBackgroundMap = THREE.ImageUtils.loadTexture( Autodesk.Viewing.Private.getResourceUrl("res/postprocess/paper2.jpg"));
                    _pencilBackgroundMap.wrapS = _pencilBackgroundMap.wrapT = THREE.RepeatWrapping;

                    _postProcPass.uniforms['tFill'].value = _pencilMap;
                    _postProcPass.uniforms['tPaper'].value = _pencilBackgroundMap;
                }
                break;
        }
    }

    // returns 1 (or some other error code) on failure, 0 on success
    this.setPostProcessParameter = function (token, value) {

        switch ( token ) {
            case "style":
                _settings.postProcShaded = false;
                _postProcPass.uniforms['style'].value = WGS.POSTPROC_STYLE_OFF;
                // put this code back in if we can't run with mobile
                // if _isWeakDevice, I guess we can't use? Needs ID buffer and normals/depths.
                // if ( _isWeakDevice ) {
                //     // sorry, not available on mobile - needs ID buffer and normal/depth buffer
                //     return 1;
                // } else {
                    // load any textures that haven't been loaded.
                    this.preloadPostProcessStyle(value);
                    switch (value) {
                        case "edging":
                            _settings.postProcShaded = true;
                            _postProcPass.uniforms['style'].value = WGS.POSTPROC_STYLE_EDGING;
                            break;
                        case "cel":
                            _settings.postProcShaded = true;
                            _postProcPass.uniforms['style'].value = WGS.POSTPROC_STYLE_CEL;
                            break;
                        case "graphite":
                            _settings.postProcShaded = true;
                            _postProcPass.uniforms['style'].value = WGS.POSTPROC_STYLE_GRAPHITE;
                            break;
                        case "pencil":
                            _settings.postProcShaded = true;
                            _postProcPass.uniforms['style'].value = WGS.POSTPROC_STYLE_PENCIL;
                            break;
                    }
                    _settings.idbuffer = _settings.postProcShaded;

                    this.initPostPipeline(_settings.sao, _settings.antialias);
                    break;
                // }

            case "edges":
                _postProcPass.uniforms[ 'idEdges' ].value = value ? 1 : 0;
                _postProcPass.uniforms[ 'normalEdges' ].value = value ? 1 : 0;
                _postProcPass.uniforms[ 'depthEdges' ].value = value ? 1 : 0;
                break;
            case "idEdges":
                _postProcPass.uniforms[ 'idEdges' ].value = value ? 1 : 0;
                break;
            case "normalEdges":
                _postProcPass.uniforms[ 'normalEdges' ].value = value ? 1 : 0;
                break;
            case "depthEdges":
                _postProcPass.uniforms[ 'depthEdges' ].value = value ? 1 : 0;
                break;
            case "brightness":
                _postProcPass.uniforms[ 'brightness' ].value = value;
                break;
            case "contrast":
                _postProcPass.uniforms[ 'contrast' ].value = value;
                break;
            case "preserveColor":
                _postProcPass.uniforms[ 'preserveColor' ].value = value ? 1 : 0;
                break;
            case "levels":
                _postProcPass.uniforms[ 'levels' ].value = value;
                break;
            case "repeats":
                _postProcPass.uniforms[ 'repeats' ].value = value;
                break;
            case "rotation":    // 0.0 to 1.0, around circle (e.g. 0.5 == pi radians, 1.0 == 2*pi)
                _postProcPass.uniforms[ 'rotation' ].value = value;
                break;
            default:
                console.error("setPostProcessParameter: parameter '" + token + "' is not valid.");
        }

        return 0;
    };

    // TODO what's a better return value if undefined? Or just issue a warning? Should there be a separate query function?
    this.queryPostProcessParameter = function (token, value) {
        if ( _postProcPass.uniforms[token] !== 'undefined' ) {
            return _postProcPass.uniforms[token].value;
        } else {
            console.warning( "queryPostProcessParameter: parameter '" + token + "' is not valid");
            return 0;
        }
    }

    this.toggleEnvMapBackground = function (value) {
        _settings.envMapBg = value;
        _clearPass.uniforms.envMapBackground.value = value;
    };

    this.toggleSwapBlackAndWhite = function (value) {

        _settings.swapBlackAndWhite = value;
    };

    this.enter2DMode = function(idMaterial) {
        _idMaterial = idMaterial;
        _oldSettings.sao = _settings.sao;
        _oldSettings.postProcShaded = _settings.postProcShaded;
        _oldSettings.antialias = _settings.antialias;
        _oldSettings.idbuffer = _settings.idbuffer;
        _oldSettings.occlusionid = _settings.occlusionid;
        _settings.idbuffer = true;
        _settings.occlusionid = false;
        _settings.postProcShaded = false;
        _blendPass.material.defines.IS_2D = "";
        this.initPostPipeline(false, false);
    };

    this.exit2DMode = function() {
        _idMaterial = null;
        _settings.idbuffer = _oldSettings.idbuffer && _enableRolloverHighlight;
        _settings.occlusionid = _oldSettings.occlusionid;
        _settings.postProcShaded = _oldSettings.postProcShaded;
        delete _blendPass.material.defines.IS_2D;
        this.initPostPipeline(_oldSettings.sao, _oldSettings.antialias);
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    //If the optional third parameter is passed in, it's assume to be a two integer array-like,
    //and the extended result of the hit test (including model ID) is stored in it.
    this.idAtPixel = function (vpx, vpy, res) {
        if (!_idTargets[0])
            return 0;

        var px = 0 | ((vpx + 1.0) * 0.5 * _idTargets[0].width);
        var py = 0 | ((vpy + 1.0) * 0.5 * _idTargets[0].height);

        if (_lastIDValid && px === _lastX && py === _lastY) {
            if (res) {
                res[0] = _lastID;
                res[1] = _lastModelID;
            }
            return _lastID;
        }

        _renderer.readRenderTargetPixels(_idTargets[0], px, py, 1, 1, _readbackBuffer);

        var id =  (_readbackBuffer[2] << 16) | (_readbackBuffer[1] << 8) | _readbackBuffer[0];
        var modelId = 0;

        if (_idTargets[1]) {
            _renderer.readRenderTargetPixels(_idTargets[1], px, py, 1, 1, _readbackBuffer);

            modelId = (_readbackBuffer[1] << 8) | _readbackBuffer[0];

            //recover negative values when going from 16 -> 32 bits.
            modelId = (modelId << 16) >> 16;

            //Upper byte of 32 bit dbId encoded in the 3rd byte of the model ID target.
            //id = id | (_readbackBuffer[2] << 24);
            //TODO: ouch, the above does not work for 2d sheets, because each mesh contains many objects.
            //Do something about it...
            id = (id << 8) >> 8;

        } else {
            //sign extend the upper byte to get back negative numbers (since we clamp 32 bit to 24 bit when rendering ids)
            id = (id << 8) >> 8;
        }

        _lastX = px;
        _lastY = py;
        _lastID = id;
        _lastModelID = modelId;
        _lastIDValid = true;

        if (res) {
            res[0] = id;
            res[1] = modelId;
        }

        return id;
    };

    this.idAtPixels = function (vpx, vpy, res, result) {
        if (!_idTargets[0])
            return 0;

        var px = (vpx + 1.0) * 0.5 * _idTargets[0].width - (res - 1) * 0.5;
        var py = (vpy + 1.0) * 0.5 * _idTargets[0].height - (res - 1) * 0.5;

        var readbackBuffer = new Uint8Array(4 * res * res);

        _renderer.readRenderTargetPixels(_idTargets[0], px, py, res, res, readbackBuffer);

        var readbackBuffer2 = undefined;
        if(result && _idTargets[1]) {
            readbackBuffer2 = new Uint8Array(4 * res * res);
            _renderer.readRenderTargetPixels(_idTargets[1], px, py, res, res, readbackBuffer2);
        }
        // Start the search at the center of the region and then spiral.
        function spiral() {

            var id;
            var x = 0, y = 0;
            var dx = 0, dy = -1;

            for (var i = 0; i < res * res; i++) {

                // Translate coordinates with top left as (0, 0)
                var tx = x + (res - 1) / 2;
                var ty = y + (res - 1) / 2;
                if (tx >= 0 && tx <= res && ty >= 0 && ty <= res) {
                    var index = tx + ty * res;
                    id = (readbackBuffer[4 * index + 2] << 16) | (readbackBuffer[4 * index + 1] << 8) | readbackBuffer[4 * index];

                    //sign extend the upper byte to get back negative numbers (since we clamp 32 bit to 24 bit when rendering ids)
                    id = (id << 8) >> 8;
                    if (id >= 0) {
                        if(readbackBuffer2) {
                            var modelId = (readbackBuffer2[4 * index + 1] << 8) | readbackBuffer2[4 * index];
                            //recover negative values when going from 16 -> 32 bits.
                            modelId = (modelId << 16) >> 16;

                            result[0] = id;
                            result[1] = modelId;
                        }
                        break;
                    }
                }

                if ( (x == y) || (x < 0 && x == -y) || (x > 0 && x == 1-y) ) {
                    var t = dx;
                    dx = -dy;
                    dy = t;
                }
                x += dx;
                y += dy;
            }

            return id;
        }

        return spiral();

    };

    this.readbackTargetId = function() {
        if (!_idTargets[0])
            return null;

        var readbackBuffer = new Uint8Array(4 * _idTargets[0].width * _idTargets[0].height);
        _renderer.readRenderTargetPixels(_idTargets[0], 0, 0, _idTargets[0].width, _idTargets[0].height, readbackBuffer);

        return {
            buffer: readbackBuffer,
            width: _idTargets[0].width,
            height: _idTargets[0].height
        };
    };

    /**
     * @private
     * Shows the content of a render target in a new browser window.
     * Check to make sure your popup blocker is not blocking the local host.
     * For debugging purposes only. Typical console command to dump target
     * to a new browser window:
     * NOP_VIEWER.impl.renderer().getRenderTargetPixels('color')
     *
     * @param targetName {string} Name of render target.
     *      Can be 'color', 'overlay', 'id', 'post1' or 'post2'.
     * 
     * On Safari popups need to be unblocked to see the image.
     */
     /*
    this.getRenderTargetPixels = function(targetName) {
        // https://github.com/ebidel/filer.js/blob/master/src/filer.js
        function dataURLToBlob(dataURL) {
            var BASE64_MARKER = ';base64,';
            var parts, contentType, raw;
            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                parts = dataURL.split(',');
                contentType = parts[0].split(':')[1];
                raw = decodeURIComponent(parts[1]);

                return new Blob([raw], {type: contentType});
            }

            parts = dataURL.split(BASE64_MARKER);
            contentType = parts[0].split(':')[1];
            raw = window.atob(parts[1]);
            var rawLength = raw.length;

            var uInt8Array = new Uint8Array(rawLength);

            for (var i = 0; i < rawLength; ++i) {
                uInt8Array[i] = raw.charCodeAt(i);
            }

            return new Blob([uInt8Array], {type: contentType});
        }

        var target;
        switch (targetName) {
            case 'color': target = _colorTarget; break;
            case 'overlay': target = _overlayTarget; break;
            case 'id': target = _idTargets[0]; break;
            case 'post1': target = _postTarget1; break;
            case 'post2': target = _postTarget2; break;
            case 'occlusion': target = _occlusionTarget; break;
        }

        if (!target) {
            console.error('unknown target name');
        } else {
            var buffer = new Uint8Array(4 * target.width * target.height);
            _renderer.readRenderTargetPixels(target, 0, 0, target.width, target.height, buffer);
            var imgdata = new ImageData(new Uint8ClampedArray(buffer), target.width, target.height);
            var canvas = document.createElement('canvas');
            canvas.width = target.width;
            canvas.height = target.height;
            var context = canvas.getContext('2d');
            context.putImageData(imgdata, 0, 0);
            var newBlobURL = window.URL.createObjectURL(dataURLToBlob(canvas.toDataURL("image/png")));
            window.open(newBlobURL);
        }
    };
    */

    this.rolloverObjectViewport = function (vpx, vpy, dbIds) {
        if (_enableRolloverHighlight) {
            var objId = dbIds ? dbIds[0] : this.idAtPixel(vpx, vpy);
            return this.rolloverObjectId(objId, dbIds);
        }
    };

    this.rolloverObjectId = function(objId, dbIds, modelId) {

        modelId = modelId || 0;

        if (!_enableRolloverHighlight || (objId === _lastHighlightId && modelId === _lastHighlightModelId))
            return false;

        _blendPass.uniforms['highlightIntensity'].value = 0;
        _blendPass.uniforms['objID'].value = objId;

        _lastObjTime = performance.now();

        _lastHighlightId = objId;
        _lastHighlightModelId = modelId;

        // When dbIds is provided, highlight nodes in a range
        if (dbIds) {

            if (dbIds.length > 1)
                dbIds.shift();
            _blendPass.uniforms['highlightRange'].value = 1;
            _blendPass.uniforms['objIDStart'].value = dbIds[0];
            _blendPass.uniforms['objIDEnd'].value = dbIds[dbIds.length - 1];
        }
        else {

            _blendPass.uniforms['highlightRange'].value = 0;

            //Check if nothing was at that pixel -- 0 means object
            //that has no ID, ffffff (-1) means background, and both result
            //in no highlight.
            if (objId <= 0) {
                objId = 0;
            }

            _blendPass.uniforms['objIDv3'].value.set((objId & 0xFF) / 255,
                                                    ((objId >> 8) & 0xFF) / 255,
                                                    ((objId >> 16) & 0xFF) / 255);
        }

        return true;
    };

    this.setSelectionColor = function(color) {
        // The selection color is gamma corrected using 2.0.
        var gamma = new THREE.Color(color);
        gamma.r = Math.pow(gamma.r, 2.0);
        gamma.g = Math.pow(gamma.g, 2.0);
        gamma.b = Math.pow(gamma.b, 2.0);
        _blendPass.uniforms['selectionColor'].value.set(gamma);
        _blendPass.material.needsUpdate = true;
    };

    this.setMemoryLimited = function(memoryLimited) {
        _enableRolloverHighlight = !memoryLimited;
        _settings.idbuffer = _settings.idbuffer && _enableRolloverHighlight;
        _settings.occlusionid = memoryLimited;
        this.setSize(_w, _h);    // Create/dispose idTargets if needed
    };

    this.isMemoryLimited = function() {
        return !_enableRolloverHighlight;
    };

    this.setUnitScale = function(metersPerUnit) {
        _unitScale = metersPerUnit;
    };

    this.getUnitScale = function() {
        return _unitScale;
    };

    this.getBlendPass = function() {
        return _blendPass;
    };

    this.getClearPass = function() {
        return _clearPass;
    };

    // TODO_NOP: hack expose colorTarget so shadow/reflection can draw into
    this.getColorTarget = function() {
        return _colorTarget;
    };

    /**
     * @returns {WebGLRenderTarget} Normal/depth target for this context (if rendered)
     */
    this.getDepthTarget = function() {
        return _depthTarget;
    };

    /**
     * @returns {WebGLRenderTarget} Model ID target for this context (if rendered)
     */
    this.getIdTarget = function() {
        return _idTargets[0];
    };

    // TODO_NOP: hack expose depthMaterial to register with matman for cutplanes
    this.getDepthMaterial = function() {
        return _depthMaterial;
    };

    this.getPostTarget = function() {
        return _postTarget1;
    };

    //TODO: Why not, adding another NOP-style hack
    this.getEdgeMaterial = function() {
        return _edgeMaterial;
    };

    /**
     * @returns {WebGLFramebuffer} Currently bound framebuffer for this context
     */
    this.getCurrentFramebuffer = function() {
        return _renderer.getCurrentFramebuffer();
    }
}

avp.RenderContext = RenderContext;

})();


(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private,
    lmv = Autodesk.LMVTK;

avp.DefaultLightPreset = 1; // "Sharp Highlights"
avp.DefaultLightPreset2d = 0;   // "Simple Grey"

avp.ModelSettingsEnvironment = null; // env. settings provided by the last call to setLightPresetFromFile

    avp.BackgroundPresets = {
        "Fusion Grey":      [230, 230, 230, 150, 150, 150],
        "Sky Blue":         [226, 244, 255, 156, 172, 180],
        "Snow":             [181, 186, 199, 181, 186, 199],
        "Midnight":         [ 41,  76, 120,   1,   2,   3],
        "White":            [255, 255, 255, 255, 255, 255],
        "AutoCADModel":     [ 30,  40,  48,  30,  40,  48],
        "Dark Grey":        [ 51,  51,  51,  51,  51,  51],
        "Dark Sky":         [ 51,  51,  51,  51,  51,  51],
        "Infinity Pool":    [255, 255, 255, 255, 255, 255],
        "Tranquility":      [  0,  84, 166,   0,  84, 166],
        "Grey Room":        [129, 129, 129, 129, 129, 129],
        "Photo Booth":      [237, 237, 237, 237, 237, 237],
        "RaaS SBS":         [  1,   1,   1,  90,  90,  90],
        "Plaza":            [ 79, 102, 130,  79, 102, 130],
        "Field":            [202, 226, 252, 202, 201, 190],
        "Boardwalk":        [216, 230, 248, 230, 228, 220],

        //This will get modified when the user changes the background
        //using the color picker.
        "Custom":           [230, 230, 230, 150, 150, 150]
    };

    var bg = avp.BackgroundPresets;

    avp.LightPresets = [
        //Notes: tonemap = which tone map method to use. Any tonemap method other than zero will cause colors to be linearized before use.
        //              0 = None, 1 = Prism Cannon-Lum (color preserving), 2 = OGC Cannon RGB (non-color preserving)
        //       exposure = exponential bias to use as pre-tonemap multiplier for all rendered colors, including background
        //       lightMultiplier = linear scale of direct light intensity (diffuse only, not ambient)
        //       bgColorGradient = which background color preset to use as default for the environment map
        //       illuminance     = cosine-weighted integral of the upper-hemisphere (i.e., actual lux)

        //Image-based lighting from RaaS. Initial exposure is empirically obtained.
        //These do not normally require any extra lights, because they have the lights fully baked into
        //the environment maps.

        //Simple ***non-HDR*** environment.
        {
            name: "Simple Grey",    // localized in viewer-environments.loc.json
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8*0.25, 0.9*0.25,  1.0*0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: false,
            rotation: 0.0
        },

        //Fusion Environments which require extra lights

        // The E_bias value for the Fusion render-space environments is setup such that
        // the default values match the preset values of brightness (in lux) and EV.
        // The EV value from Fusion follows the Canon standard for luminance and middle-gray
        // https://en.wikipedia.org/wiki/Exposure_value#EV_as_a_measure_of_luminance_and_illuminance [September 2015]
        //
        // Rationale (using the canon tonemap as a guide, based on documentation by Adam Arbree):
        // 1. BaseExposure (B) in the canon tonemap is the negative log2 luminance of the
        //    white point (W) so B = -log2(W)
        // 2. To match the target illuminance from Fusion, the environment needs
        //    to be scaled by the ratio between the target and its actual illuminance, thus
        //    S = target_illuminance / actual_illuminance
        // 3. Then by the definition of middle grey W = L / (0.18*S) where L is the middle grey
        //    luminance and 0.18 is the standard reflection of middle grey.
        // 4. As per the Wikipedia entry, we have L = 2^(EV-3)
        // 5. Putting this all together we have
        //      B = -log2( 2^(EV-3) / (0.18*S))
        //        = log2(0.18) + log2(S) – (EV – 3)
        //        = (3+log2(0.18)) – EV + log2(S)
        //        = 0.526069 – EV + log2(S)

        {
            name: "Sharp Highlights",    // localized in viewer-environments.loc.json
            path:"SharpHighlights",
            type:"logluv",
            tonemap:1,
            // illuminance currently is not used elsewhere in LMV, its effect is folded into E_bias.
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [0.5, -0.2, -0.06],
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Dark Sky",     // "Dark Sky", localized in viewer-environments.loc.json
            path:"DarkSky",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8], //0.25 with gain of 0.125
            lightMultiplier: 1.0,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Dark Sky"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Grey Room",    // "Grey Room", localized in viewer-environments.loc.json
            path:"GreyRoom",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Grey Room"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Photo Booth",     // "Photo Booth", localized in viewer-environments.loc.json
            path:"PhotoBooth",
            type:"logluv",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Tranquility",     // "Tranquility", localized in viewer-environments.loc.json
            path:"TranquilityBlue",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Tranquility"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Infinity Pool",     // "Infinity Pool", localized in viewer-environments.loc.json
            path: "InfinityPool",
            type:"logluv",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.5,
            lightDirection: [0.1, -0.55, -1.0],
            bgColorGradient: bg["Infinity Pool"],
            darkerFade: false,
            rotation: 0.0
        },

        // Non fusion environments

        //White background, no HDR -- for cases like SIM360 models
        {
            name: "Simple White",     //"Simple White", localized in viewer-environments.loc.json
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.25, 0.25, 0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["White"],
            saoRadius: 0.06,
            saoIntensity: 0.15,
            darkerFade: true,
            rotation: 0.0
        },
/*
        {
            name: "Simple Black",
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8, 0.9,  1.0],
            lightMultiplier: 1.0,
            bgColorGradient: bg["AutoCADModel"],
            darkerFade: false
        },
  */
        //RaaS environments
        {
            name: "Riverbank",     // "Riverbank", localized in viewer-environments.loc.json
            path:"riverbank",
            type:"logluv",
            tonemap:1,
            E_bias:-5.7,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Sky Blue"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Contrast",     // "Contrast", localized in viewer-environments.loc.json
            path:"IDViz",
            type:"logluv",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Midnight"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Rim Highlights",     //  localized in viewer-environments.loc.json
            path:"RimHighlights",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [0.35, -0.35, -0.5],
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true,
            rotation: 0.0
        },
        {
            name: "Cool Light",     // "Cool Light", localized in viewer-environments.loc.json
            path:"CoolLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [-0.0, -0.15, -0.5],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Warm Light",     // "Warm Light", localized in viewer-environments.loc.json
            path:"WarmLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [-0.0, -0.15, -0.5],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Soft Light",     // "Soft Light", localized in viewer-environments.loc.json
            path:"SoftLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [-0.5, -0.5, 0.0],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Grid Light",     // "Grid Light", localized in viewer-environments.loc.json
            path:"GridLight",
            type:"logluv",
            tonemap:1,
            //illuminance: 1000.0,
            E_bias:-9.0, // EV 9.526, 1000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0,
            lightDirection: [-0.5, -0.6, 0.0],
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true,
            rotation: 0.0
        },

        {
            name: "Plaza",             //  "Plaza", localized in viewer-environments.loc.json
            path:"Plaza",
            type:"logluv",
            tonemap:1,
            //illuminance: 24157.736,
            E_bias: -14.0, // FIXME: EV 14.526, 50000.0 lux in the GUI, yet it does not seem to use illuminance
            directLightColor: [0.9, 0.9, 1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0, //8000.0, Turned off -- until we support world space light positioning.
            lightDirection: [-0.2, -0.18, 0.72],
            bgColorGradient: bg["Plaza"],
            darkerFade: false,
            rotation: 0.0
        },

        {
            name: "Snow Field",            //  "Snow Field", localized in viewer-environments.loc.json
            path:"SnowField",
            type:"logluv",
            tonemap:1,
            //illuminance: 4302.7773,
            E_bias: -10.461343,  // EV 14.526, 50000.0 lux (target)
            directLightColor: [1,1,1],
            ambientColor: [0.25/8,0.25/8,0.25/8],
            lightMultiplier: 0.0, //800.0, Turned off -- until we support world space light positioning.
            lightDirection: [0.0, -1.0, 0.0],
            bgColorGradient: bg["Snow"],
            darkerFade: false,
            rotation: 0.0
        },
        {
            name: "Field",            //  "Field", localized in viewer-environments.loc.json
            path:"field",
            type:"logluv",
            tonemap:1,
            E_bias:-2.9,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Field"],
            useIrradianceAsBackground: true,
            darkerFade: true,
            rotation: 0.0
        },
        {
            name: "Boardwalk",           //  "Boardwalk", localized in viewer-environments.loc.json
            path:"boardwalk",
            type:"logluv",
            tonemap:1,
            E_bias:-7.0,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Boardwalk"],
            useIrradianceAsBackground: true,
            darkerFade: false,
            rotation: 0.0
        }
    ];

    avp.DebugEnvironments = [
             //More RaaS ones
            {
                name: "Crossroads",         //  "Crossroads", localized in viewer-environments.loc.json
                path:"crossroads",
                type:"logluv",
                tonemap:1,
                E_bias:-5.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                useIrradianceAsBackground: true,
                darkerFade: true,
                rotation: 0.0
            },
            {
                name: "Seaport",            //  "Seaport", localized in viewer-environments.loc.json
                path:"seaport",
                type:"logluv",
                tonemap:1,
                E_bias:-6.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                useIrradianceAsBackground: true,
                darkerFade: false,
                rotation: 0.0
            },

            {
                name: "Glacier",            //  "Glacier", localized in viewer-environments.loc.json
                path:"glacier",
                type:"logluv",
                tonemap:1,
                E_bias:0,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Midnight"],
                darkerFade: false,
                rotation: 0.0
            },
            {
                name: "RaaS Test Env",      // localized in viewer-environments.loc.json
                path:"Reflection",
                type:"logluv",
                tonemap:2,
                E_bias:-1.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["RaaS SBS"],
                darkerFade: false,
                rotation: 0.0
            }
    ];

    if (avp.ENABLE_DEBUG) {
        avp.LightPresets = avp.LightPresets.concat(avp.DebugEnvironments);
    }

    /**
     * Copies properties from a Preset (src) into a user provided preset (env)
     * Ideally, this function is used with avp.ModelSettingsEnvironment
     */
    avp.copyLightPreset = function(src, env) {

        av.ObjectAssign(env, src);
        env.name = src.name + " (copy)";
    };


    avp.CreateCubeMapFromColors = function(ctop, cbot) {
        var r1 = ctop.x * 255, g1 = ctop.y * 255, b1 = ctop.z * 255,
            r2 = cbot.x * 255, g2 = cbot.y * 255, b2 = cbot.z * 255;

        var pixelsTop = new Uint8Array(16);
        var pixelsBot = new Uint8Array(16);
        var pixelsSide = new Uint8Array(16);

        for (var i=0; i<4; i++) {
            pixelsTop[i*4] = r1;
            pixelsTop[i*4+1] = g1;
            pixelsTop[i*4+2] = b1;
            pixelsTop[i*4+3] = 255;

            pixelsBot[i*4] = r2;
            pixelsBot[i*4+1] = g2;
            pixelsBot[i*4+2] = b2;
            pixelsBot[i*4+3] = 255;

            // was this, which is wild: if (0 | (i / 2)) {
            if ( i > 1 ) {
				// color sides 2 and 3 with the first color
                pixelsSide[i*4] = r1;
                pixelsSide[i*4+1] = g1;
                pixelsSide[i*4+2] = b1;
                pixelsSide[i*4+3] = 255;
            }
            else {
				// color sides 0 and 1 with the second color
                pixelsSide[i*4] = r2;
                pixelsSide[i*4+1] = g2;
                pixelsSide[i*4+2] = b2;
                pixelsSide[i*4+3] = 255;
            }
        }

        var x_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var x_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var y_neg = new THREE.DataTexture( pixelsBot, 2, 2, THREE.RGBAFormat );
        var y_pos = new THREE.DataTexture( pixelsTop, 2, 2, THREE.RGBAFormat );
        var z_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var z_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );

        var texture = new THREE.Texture(null, THREE.CubeReflectionMapping,
                                        THREE.RepeatWrapping, THREE.RepeatWrapping,
                                        THREE.LinearFilter, THREE.LinearFilter,
                                        //THREE.NearestFilter, THREE.NearestFilter,
                                        THREE.RGBAFormat);
        texture.image = [x_pos, x_neg, y_pos, y_neg, z_pos, z_neg];
        texture.needsUpdate = true;

        return texture;
    };

})();


(function() {


"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//====================================================================================================
//
//
// DO NOT ADD STUFF TO THIS CLASS. IT WILL GO AWAY.
//
//
//====================================================================================================
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


/** @constructor */
function MaterialManager(renderer)
{
    WGS.MaterialManager.call(this, renderer);

    var _super = WGS.MaterialManager.prototype;


    this.create2DMaterial = function(model, material, isIdMaterial, selectionTexture, onReady) {
        var svf = model ? model.getData() : null;

        //Create a hash string of the material to see if we have
        //already created it
        var name = "__lineMaterial__";
        if (material.image)
            name += "|image:" + material.image.name;
        if (material.clip)
            name += "|clip:" + JSON.stringify(material.clip);
        if (isIdMaterial)
            name += "|id";
        if (selectionTexture)
            name += "|selection";
        if (material.skipEllipticals)
            name += "|skipEllipticals";
        if (material.skipCircles)
            name += "|skipCircles";
        if (material.skipTriangleGeoms)
            name += "|skipTriangleGeoms";
        if (material.useInstancing)
            name += "|useInstancing";

        var hash = this._getMaterialHash(model, name);

        if (!this._materials.hasOwnProperty(hash))
        {
            var avs = av.Shaders;
            var lineMaterial = avs.createShaderMaterial(avs.LineShader);
            lineMaterial.is2d = true;
            lineMaterial.transparent = true;
            lineMaterial.depthWrite = false;
            lineMaterial.depthTest = false;
            lineMaterial.side = THREE.DoubleSide;
            lineMaterial.blending = THREE.NormalBlending;

            if (isIdMaterial) {
                //Is the caller requesting the special case of
                //shader that outputs just IDs (needed when MRT not available)?
                lineMaterial.defines["ID_COLOR"] = 1;
                lineMaterial.blending = THREE.NoBlending;
            }
            else if (selectionTexture) {
                lineMaterial.uniforms["tSelectionTexture"].value = selectionTexture;
                lineMaterial.uniforms["vSelTexSize"].value.set(selectionTexture.image.width, selectionTexture.image.height);
                lineMaterial.defines["SELECTION_RENDERER"] = 1;
                lineMaterial.uniforms["selectionColor"].value = new THREE.Vector4(0, 0, 1, 1);
            }
            else {
                if (renderer && renderer.supportsMRT()) {
                    //If the renderer can do MRT, enable it in the shader
                    //so we don't have to draw the ID buffer separately.
                    lineMaterial.mrtIdBuffer = this._mrtIdBuffer;
                }
            }

            if (!material.skipEllipticals) {
                lineMaterial.defines["HAS_ELLIPTICALS"] = 1;
            }

            if (!material.skipCircles) {
                lineMaterial.defines["HAS_CIRCLES"] = 1;
            }

            if (!material.skipTriangleGeoms) {
                lineMaterial.defines["HAS_TRIANGLE_GEOMS"] = 1;
            }

            if (material.useInstancing) {
                lineMaterial.defines["USE_INSTANCING"] = 1;
            }

            if (material.image) {

                var onTexLoad = function(texture) {

                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = 1; // renderer.getMaxAnisotropy();
                    texture.flipY = true;
                    texture.generateMipmaps = true;

                    texture.needsUpdate = true;

                    lineMaterial.defines["HAS_RASTER_QUADS"] = 1;
                    lineMaterial.uniforms["tRaster"].value = texture;
                    if (material.image.dataURI.indexOf("png") !== -1)
                        lineMaterial.transparent = true;
                    lineMaterial.needsUpdate = true;
                    if (onReady) {
                        onReady(texture);
                    }
                };

                WGS.TextureLoader.loadTextureWithSecurity(material.image.dataURI, THREE.UVMapping, onTexLoad, svf.acmSessionId, avp.initLoadContext);
            }

            lineMaterial.modelScale = material.modelScale || 1;

            _super.addLineMaterial.call(this, hash, lineMaterial);
        }

        return name;
    };


    //this.initLineStyleTexture();

}

// Helper function that postpones the setup of MaterialManager's prototype chain
// (because it depends on WGS.MaterialManager which is loaded as a dependency).
function createMaterialManager(renderer) {
    if (!avp.hasOwnProperty('MaterialManager')) {
        MaterialManager.prototype = new WGS.MaterialManager(renderer);
        MaterialManager.prototype.constructor = MaterialManager;
        avp.MaterialManager = MaterialManager;
    }
    return new avp.MaterialManager(renderer);
}


Autodesk.Viewing.Private.createMaterialManager = createMaterialManager;

})();

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private;

//Those are globals -- set by the build system.
var LMV_WORKER_URL = avp.LMV_WORKER_URL || "src/workers/MainWorker-web.js";
var ENABLE_INLINE_WORKER = avp.ENABLE_INLINE_WORKER || false;

(function(){

"use strict";

// A cache of entire worker script as data URL.
var WORKER_DATA_URL = null;
var WORKER_FETCHING_SCRIPT = false;
var WORKER_FETCHING_CALLBACKS = [];

avp.workerScript = null;

function createScript() {
    if (!avp.workerScript) {
        var scriptURL = LMV_WORKER_URL;

        // We need to request the same version of the library for this worker.  Take the original
        // script url, which will already have the version string (if provided).
        //
        var originalScriptURL = avp.getResourceUrl(LMV_WORKER_URL);

        if (originalScriptURL) {
            scriptURL = originalScriptURL;
        }

        avp.workerScript = WGS.WebWorkerCreator
            ? new WGS.WebWorkerCreator(scriptURL, ENABLE_INLINE_WORKER)
            : new WGS.NodeWorkerCreator();
    }
    return avp.workerScript;
}

// This mainly is used for testing.
avp.clearWorkerDataURL = function() {
    avp.workerScript && avp.workerScript.clearWorkerDataURL();
};

avp.initWorkerScript = function(successCB, errorCB) {
    return createScript().initWorkerScript(successCB, errorCB);
};

// Create a web worker.
avp.createWorker = function() {
    return createScript().createWorker();
};
    

avp.createWorkerWithIntercept = function() {
    return createScript().createWorkerWithIntercept();
};


})();


(function(){

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var WORKER_PARSE_F2D = "PARSE_F2D";
var WORKER_STREAM_F2D = "STREAM_F2D";
var WORKER_PARSE_F2D_FRAME = "PARSE_F2D_FRAME";

var RENDER_BUFFER_REQUEST = 0x1;
var PROMISE_BUFFER_REQUEST = 0x2;
var ANY_BUFFER_REQUEST = 0x4;
var BUFFER_SENT_TO_PARSER = 0x8;

var MEGA = 1024 * 1024;
var VERT_SIZE = 12 * 4; // 12 floats per vertex
var INDEX_SIZE = 2;

// Paging proxy object to manage on demand loading and paging logic, 
// that is specific to the model loaded by svf loader.
var F2DPagingProxy = function(loader, options) {

    var _extendObject = function(target, source) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }
    };

    var _loader = loader;

    // Options of control memory management.
    // Options of control memory management.
    this.options = {
        onDemandLoading: false,
        pageOutGeometryEnabled: false
    };
    _extendObject(this.options, options);
    this.options.debug = {

        pageOutStart: .75,
        pageOutEnd: .50,
        pixelCullingEnable: false,      // Not useful for 2D
        pixelCullingThreshold: WGS.PIXEL_CULLING_THRESHOLD
    };
    _extendObject(this.options.debug, options.debug);

    // Initialize members used by on demand loading
    var _pendingBuffers = [];
    var _pendingPromises = {};
    var _promiseQueue = [];
    var _pendingSize = 0;
    var _actualGeomSize = 0;
    var _lastBufferPending = -1;
    var _lastTraversed = -1;
    var _maxRequest = -1;
    var _canceled = 0;
    var _alternatePromise = true;
    var _bufferCount = 0;
    // Max size of a 2D buffer.
    var _maxBufferSize;
    if (_loader.useInstancing) {
        // If we are instancing, then everything is output as a quad, even triangles.
        // So we are limited by the max size the VertexBufferBuilder will allow.
        // When we are instancing the VertexBufferBuilder cuts the buffer size by 1/4.
        _maxBufferSize = ((av.isMobileDevice() ? 16383 : 32767) / 4) | 0;
        // Don't use indices with instancing
        _maxBufferSize = _maxBufferSize * VERT_SIZE / MEGA;
    } else {
        // We can have polytris with 65535 verts Can only guess at the max index size,
        // since we don't get a stat for that so we guess an average of 6 indices per vert.
        _maxBufferSize = 65535 * (VERT_SIZE + INDEX_SIZE * 6) / MEGA;
    }
    var _finalFrame = false;
    var _culledGeom = [];

    // Need at least 10 MB to work
    this.options.limit = Math.max(this.options.limit, 10);
    this.options.debug.pageOutEnd = Math.min(this.options.debug.pageOutEnd, this.options.debug.pageOutStart);

    this.totalGeomSize = loader.totalGeomSize;

    // Viewer API - these methods are used by the viewer to handler
    // on demand loading and paging out geometry

    // Return true of false, whether on demand loading enabled.
    // This controls how the geometry buffers are going to load. 
    //
    // If false, then geometry buffers will load in sequence all at once.
    // if true, then only those geometry buffers that are request to render,
    //          can they start to load *on demand*
    this.onDemandLoadingEnabled = function() {
        return this.options.onDemandLoading;
    };

    this.pageOutGeometryEnabled = function() {
        return this.options.onDemandLoading;
    };

    this.pixelCullingEnable = function() {
        return this.options.debug.pixelCullingEnable;
    };

    this.pixelCullingThreshold = function() {
        return this.options.debug.pixelCullingThreshold;
    };

    /**
     * Get the memory stats when using on demand loading.
     * @returns {object|null} Object containing the limit and loaded memory usage for the model.
     *                        Return null if the model isn't being loaded on demand.
     */
    this.getMemoryInfo = function() {
        var geomSizeInMemory = 0;
        if (_loader.model) {
            var geoms = _loader.model.getGeometryList();
            if (geoms) {
                geomSizeInMemory = geoms.geomMemory / MEGA; 
            }
        }

        return this.onDemandLoadingEnabled() ? {
            limit: this.options.limit,
            effectiveLimit: this.options.limit,
            loaded: geomSizeInMemory + _loader.fileMemorySize
        } : null;
    };

    function nextRenderRequest(nextReq) {
        while (++nextReq < _pendingBuffers.length) {
            // Continue until we find a buffer that is requested and not sent to the parser
            if ((_pendingBuffers[nextReq] & (ANY_BUFFER_REQUEST | BUFFER_SENT_TO_PARSER)) == ANY_BUFFER_REQUEST)
                break;
        }
        return nextReq;
    }

    function scheduleMoreBuffers(options) {
        // request more buffers to draw.
        var geomSizeInMemory = 0;
        if (_loader.model) {
            var geoms = _loader.model.getGeometryList();
            if (geoms) {
                geomSizeInMemory = geoms.geomMemory / MEGA; 
            }
        }

        // Schedule the geometry download. Alternate between promised buffers
        // and render buffers
        var nextReq = nextRenderRequest(_lastBufferPending);
        var currentMemSize = geomSizeInMemory + _loader.fileMemorySize + _maxBufferSize;
        while (currentMemSize + _pendingSize < options.limit) {
            // Find the next buffer to request. Alternate between promised buffers
            // and render buffer based on the last one requested.            
            var bufferId = -1;
            var promise = null;
            if (_promiseQueue.length > 0 && (_alternatePromise || nextReq > _pendingBuffers.length)) {
                // Get the promised buffer id and mark it as pending
                promise = _promiseQueue.shift();
                bufferId = promise.lmv_buffer_id;
                // Next time request a render buffer
                _alternatePromise == false;
            } else if (nextReq < _pendingBuffers.length) {
                // request a render buffer
                bufferId = nextReq;
                _lastBufferPending = nextReq;
                nextReq = nextRenderRequest(nextReq);
                _alternatePromise = true;
            } else
                break;      // no more buffers to request

            // Request the next buffer. If this buffer was already sent to the
            // parser, then we make this request conditional.
            _loader.parsingWorker.doOperation({operation:WORKER_PARSE_F2D_FRAME,
                                               bufferId: bufferId,
                                               rendered: !!(_pendingBuffers[bufferId] & RENDER_BUFFER_REQUEST),
                                               promised: !!(_pendingBuffers[bufferId] & PROMISE_BUFFER_REQUEST),
                                               conditional: !!(_pendingBuffers[bufferId] & BUFFER_SENT_TO_PARSER) });
            if (!(_pendingBuffers[bufferId] & BUFFER_SENT_TO_PARSER)) {
                _pendingSize += _maxBufferSize;
                _pendingBuffers[bufferId] |= BUFFER_SENT_TO_PARSER;
            }
        }
    }

    this.loadPackFile = function(bufferId) {
        if (!this.onDemandLoadingEnabled())
            return false;

        // Request out of range
        if (bufferId < 0 || (_finalFrame && bufferId >= _bufferCount))
            return false;

        if (bufferId > _maxRequest)
            _maxRequest = bufferId;

        // If this buffer hasn't been requested for rendering, then check for
        // out of sequence ordering and mark it as requested.
        if (!(_pendingBuffers[bufferId] & RENDER_BUFFER_REQUEST)) {
            // reset if we get a request out of order
            if (bufferId <= _lastBufferPending)
                this.reset();
            // Mark as pending
            _pendingBuffers[bufferId] |= ANY_BUFFER_REQUEST | RENDER_BUFFER_REQUEST;
        }

        scheduleMoreBuffers(this.options);
        return true;
    };

    this.promisePackFile = function(bufferId) {
        if (!this.onDemandLoadingEnabled())
            return Promise.reject( { reason: "Not supported" } );

        // Request out of range
        if (bufferId < 0 || bufferId >= _bufferCount)
            return Promise.reject( { reason: "Buffer id out of bounds" } );

        // If this buffer hasn't been requested, then check for
        // out of sequence ordering and mark it as requested.
        var promise = _pendingPromises[bufferId];
        if (promise) {
            // We already have this buffer queue. We only keep one promise for
            // each buffer, so just return the one we already have
            scheduleMoreBuffers(this.options);
            return promise;
        }

        // Add to the pending promises. We do this carefully without making
        // any assumptions about when the argument to the Promise constructor,
        // might get called or when the buffer might be loaded.
        var lmv_resolve;
        var lmv_reject;
        // Create the promise, we keep the promise and the resolve and
        // reject functions in a state object, so we can separate the
        // download scheduler from the promise
        promise = new Promise( function(resolve, reject) {
            lmv_resolve = resolve;
            lmv_reject = reject; 
        } );

        // Add some properties to the promise, so we can download
        // the buffer, and resolve or reject the promise.
        promise.lmv_resolve = lmv_resolve;
        promise.lmv_reject = lmv_reject;
        promise.lmv_buffer_id = bufferId;

        // Put the promise in the pending promises list, and the
        // pending buffers. The pending promises list allows promised
        // geometry to run out of order.
        _promiseQueue.push( promise );
        _pendingPromises[bufferId] = promise;
        _pendingBuffers[bufferId] |= ANY_BUFFER_REQUEST | PROMISE_BUFFER_REQUEST;

        // schedule more buffers, if we can
        scheduleMoreBuffers(this.options);
        return promise;
    };

    this.cancelPromisedPackFile = function(promise) {
        // Not one of mine.
        if (!promise || !promise.hasOwnProperty("lmv_buffer_id")
            || _pendingPromises[promise.lmv_buffer_id] != promise)
            return false;

        // Remove the promise, and reject it.
        var index = _promiseQueue.indexOf(promise);
        if (index >= 0)
            _promiseQueue.splice(index, 1);
        // Cancel it in the parser, if it has been requested
        var flags = _pendingBuffers[promise.lmv_buffer_id]; 
        if (flags & BUFFER_SENT_TO_PARSER) {
            _loader.parsingWorker.doOperation({operation:WORKER_PARSE_F2D_FRAME,
                                               cancelPromise: promise.lmv_buffer_id });
            if (!(flags & RENDER_BUFFER_REQUEST))
                _pendingSize -= _maxBufferSize;
        }
        if (flags & RENDER_BUFFER_REQUEST)
            flags &= ~PROMISE_BUFFER_REQUEST;
        else
            flags = 0;
        _pendingBuffers[promise.lmv_buffer_id] = flags;
        delete _pendingPromises[promise.lmv_buffer_id];
        if (promise.lmv_reject)
            promise.lmv_reject( { canceled: true } );

        // Schedule more buffers if we can.
        scheduleMoreBuffers(this.options);
        return true;
    };

    this.resetIterator = function(/*camera, resetType*/) {
    };

    this.reset = function() {
        // we need to cancel the parsing worker.
        _loader.parsingWorker.doOperation({operation:WORKER_PARSE_F2D_FRAME,
                                           cancel: true });
        _pendingSize = 0;
        for (var i = 0; i < _pendingBuffers.length; ++i) {
            // Clear render request if buffer is promised.
            // Otherwise we can clear everything.
            if (_pendingBuffers[i] & PROMISE_BUFFER_REQUEST) {
                _pendingBuffers[i] &= ~RENDER_BUFFER_REQUEST;
                if (_pendingBuffers[i] & BUFFER_SENT_TO_PARSER)
                    _pendingSize += _maxBufferSize;
            } else
                _pendingBuffers[i] = 0;
        }
        this.lastPageOut = -1;
        _lastBufferPending = -1;
        _lastTraversed = -1;
        _culledGeom.length = 0;
        _maxRequest = _bufferCount - 1;
        ++_canceled;
    };

    this.addGeomPackMissingLastFrame = function(/*packId*/) {
        return true;// Shouldn't be called
    };

    this.needResumeNextFrame = function() {
        return false;
    };

    this.pageOut = function(iterationDone, forcePageOut) {
        var geomList = _loader.model.getGeometryList();
        // If over the limit, start page out
        var size = geomList.geomMemory / MEGA + _loader.fileMemorySize;
        // Make sure we page out enough to load a new buffer
        var pageOutStart = Math.min(this.options.debug.pageOutStart * this.options.limit,
            this.options.limit - 1.1 * _maxBufferSize);
        var pageOutEnd = Math.min(this.options.debug.pageOutEnd * this.options.limit, pageOutStart);
        if (size > pageOutStart) {
            var i = 0; // tmp (see below)

            // Goal is to page out to limit - limit * percent
            var remaining = size - pageOutEnd;

            // Step 1: Remove untraversed geometries first
            while (i < _culledGeom.length && remaining > 0) {
                // remove culled geom
                remaining -= geomList.removeGeometry(_culledGeom[i++], _loader.viewer3DImpl.glrenderer()) / MEGA;
            }
            _culledGeom.splice(0, i);

            // Step 2: If not enough, continue to remove geometries aren't about to be traversed.
            for (i = geomList.geoms.length; --i > 0 && remaining > 0; ) {
                if (i <= _lastTraversed || i > _lastBufferPending)
                    remaining -= geomList.removeGeometry(i, _loader.viewer3DImpl.glrenderer()) / MEGA;
            }

            // Step 3: If existing geometries are still over the limitation, and force page out enabled,
            //         run through the whole list and page out as much as needed.
            if (forcePageOut) {
                remaining = geomList.geomMemory / MEGA  - pageOutStart;
                for (i = _lastBufferPending; i > 0 && remaining > 0; --i) {
                    remaining -= geomList.removeGeometry(i, _loader.viewer3DImpl.glrenderer()) / MEGA;
                }
                //THREE.log("[On Demand Loading] A force page out occur. ");
            }
            this.lastPageOut = size - geomList.geomMemory / MEGA;

            // When starting chrome with this JS flag: --js-flags="--expose-gc", then window.gc is defined and
            // can be used for doing a force GC. This is useful for testing purpose.
            if (window && window.gc) {
                window.gc();
            }
        }

        // If the iterator is finished and the file is still loading then
        // we request more buffers. This how buffers initially get loaded
        var newSize = geomList.geomMemory / MEGA;
        if (iterationDone && !_finalFrame) {
            var bufferSize = this.options.limit - newSize;
            if (bufferSize > 0) { 
                var bufferId = _lastBufferPending;
                while ((bufferSize -= _maxBufferSize) >= 0)
                    this.loadPackFile(++bufferId);
            }
        }

        return WGS.PAGEOUT_SUCCESS;
    };

    this.onGeomTraversed = function(geometry) {
        // TODO Paging: refactor this to the proxy object of 2d loader.
        //              2d doesn't have multiple instance geometry, so 
        //              just record it as traversed.
        _lastTraversed = geometry.svfid - 1;
    };

    this.onGeomCulled = function(geometry) {
        // TODO Paging: refactor this to the proxy object of 2d loader.
        if (this.onDemandLoadingEnabled() && geometry) {
            _culledGeom.push(geometry.svfid - 1);
        }
    };

    this.onMeshReceived = function(mesh, mindex) {
        // Accept all meshes if not on demand loading
        if (!this.onDemandLoadingEnabled())
            return true;

        // If this buffer was promised, then signal that it is loaded
        // We will do this even if we are canceling render requests.
        var promise = _pendingPromises[mindex];
        if (promise) {
            // Signal that we loaded the buffer
            if (promise.lmv_resolve)
                promise.lmv_resolve();
            // delete the requests from the pending promises and the promise queue
            delete _pendingPromises[mindex];
            var index = _promiseQueue.indexOf(promise);
            if (index >= 0)
                _promiseQueue.splice(index, 1);
        }

        // If on demand loading don't process any meshes that aren't requested
        // Buffers can get queued after canceling all of the meshes, but promises aren't canceled
        if (!(_pendingBuffers[mindex] & BUFFER_SENT_TO_PARSER)
            || (_canceled != 0 && !(_pendingBuffers[mindex] & PROMISE_BUFFER_REQUEST))) {
            return false;
        }

        // Keep track of the buffer count
        if (mindex >= _bufferCount) {
            _bufferCount = mindex + 1;
            _actualGeomSize += mesh.vb.byteLength + mesh.indices.byteLength + WGS.GEOMETRY_OVERHEAD;
        }

        // If on demand loading then we need to invalidate for each render mesh
        // is loaded to insure that the visibility flags are correctly updated.
        if (_pendingBuffers[mindex] & RENDER_BUFFER_REQUEST)
            _loader.viewer3DImpl.invalidate(false, true);

        // Keep track of pending buffers
        _pendingBuffers[mindex] = 0;
        _pendingSize -= _maxBufferSize;
        return true;
    };

    this.onFinalFrame = function() {
        // When we are done, reset
        if (this.onDemandLoadingEnabled()) {
            if (!_finalFrame)
                this.totalGeomSize = _actualGeomSize / MEGA + _loader.fileMemorySize;
            _finalFrame = true;
            _pendingBuffers.splice(_bufferCount, _pendingBuffers.length).forEach( function(pending) {
                if (pending & BUFFER_SENT_TO_PARSER)
                    _pendingSize -= _maxBufferSize;
            } );
        }
    };

    this.preparedPackFilesSize = function() {
        return _loader.fileMemorySize + _pendingSize
            + _loader.model.getGeometryList().geomMemory / MEGA;
    };

    this.cancelAcknowledged = function() {
        --_canceled;
    };
};

/** @constructor */
function F2DLoader(delegate, config) {
    this.viewer3DImpl = delegate.viewer3DImpl;
    this.delegate = WGS.FileLoader.copyDelegate(this, delegate);
    this.loading = false;
    this.tmpMatrix = new THREE.Matrix4();

    this.logger = avp.logger;
    this.loadTime = 0;
    this.useInstancing = this.viewer3DImpl.use2dInstancing;
}

F2DLoader.prototype.dtor = function () {
    // Cancel all potential process on loading a file.

    // 1. init worker script can be cancelled. 
    // 
    if (this.initWorkerScriptToken) {
        this.initWorkerScriptToken.cancel();
        this.initWorkerScriptToken = null;
        avp.logger.debug("F2D loader dtor: on init worker script.");
    }

    // 2. Streaming F2D data can be cancelled. 
    if (this.streamingWorker) {
        this.streamingWorker.terminate();
        this.streamingWorker = null;
        avp.logger.debug("F2D loader dtor: on streaming worker.");
    }

    // 3. Parsing F2D geometry can be cancelled.
    if (this.parsingWorker) {
        this.parsingWorker.terminate();
        this.parsingWorker = null;
        avp.logger.debug("F2D loader dtor: on parsing worker.");
    }

    // 4. Property loading can be cancelled.
    if (this.svf && this.svf.propDbLoader) {
        this.svf.propDbLoader.dtor();
        this.svf.propDbLoader = null;
    }   

    // And clear metadata.
    this.viewer3DImpl = null;
    this.loading = false;
    this.tmpMatrix = null;
    this.logger = null;
    this.loadTime = 0;

    this.svf = null;
    this.options = null;
        this.pagingProxy = null;
};

F2DLoader.prototype.isValid = function() {
    return this.viewer3DImpl != null;
};

F2DLoader.prototype.loadFile = function(path, options, onDone, onWorkerStart) {
    if (!this.viewer3DImpl) {
        avp.logger.log("F2D loader was already destructed. So no longer usable.");
        return false;
    }

    if (this.loading) {
        avp.logger.log("Loading of F2D already in progress. Ignoring new request.");
        return false;
    }

    // Mark it as loading now.
    this.loading = true;
    this.viewer3DImpl._addLoadingFile(this);

    var index = path.indexOf('urn:');
    if (index != -1) {
        // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.
        // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.
        path = decodeURIComponent(path);
        var urn = path.substr(index, path.substr(index).indexOf('/'));
        avp.logger.log("Extracted URN: " + urn);

        // Extract urn(just base64 code)
        var _index = urn.lastIndexOf(':');
        this.svfUrn = urn.substr(_index + 1);
    } else {
        this.svfUrn = path;
    }

    this.sharedDbPath = options.sharedPropertyDbPath;
    this.currentLoadPath = path;
    this.acmSessionId = options.acmSessionId;

    this.queryParams = "";
    if (this.acmSessionId) {
        this.queryParams = "acmsession=" + this.acmSessionId;
    }

    this.options = options;

    if (this.options.placementTransform) {
        //NOTE: The scale of the placement transform is not always sufficient to
        //determine the correct scale for line widths. This is because when a 2D model (in inches) is
        //loaded into a 3d scene in feet, the transform includes all the scaling needed to get into feet
        //but the model space line weight for the drawing is relative to the drawing itself, so an extra
        //factor of 12 would be needed in such case to cancel out the 1/12 needed for inch->foot.
        //This could probably be automatically derived, but in an error prone way, so I'm leaving it
        //up to the application layer that does the model aggregation to pass in the right model scale as an option.
        this.modelScale = this.options.modelScale || this.options.placementTransform.getMaxScaleOnAxis();
    } else {
        this.modelScale = this.options.modelScale || 1;
    }

    this.isf2d = true;
    var scope = this;
    
    avp.processMemoryOptions(this.viewer3DImpl.api.config);
    var memSrcOpts = this.viewer3DImpl.api.config && this.viewer3DImpl.api.config.memory;
    var memoryOpts = this.memoryOpts = {
        onDemandLoading: false,
        debug: {}
    };
    if (memSrcOpts) {
        if (memSrcOpts.hasOwnProperty("limit")) {
            memoryOpts.limit = memSrcOpts.limit;
            memoryOpts.onDemandLoading = true;
            WGS.memoryOptimizedLoading = true;  // Required for on demand loading
            memoryOpts.pageOutGeometryEnabled = true;
        }
        memoryOpts.debug = memSrcOpts.debug || {};
    }

    this.initWorkerScriptToken = this.delegate.workerScript.initWorkerScript(function() {
        scope.loadFydoCB(path, options, onDone, onWorkerStart);
    });
    
    return true;
};


var _fragLoadedEvent = {
    fragIds: []
};

function fireFragmentsLoadedEvent(loader, data) {
    function getFragIds() {
        if (this.fragIds)
            return fragIds;

        var rm = this.model;
        if (!rm || !this.data || !this.data.meshes)
            return null;

        var fragIds = this.fragIds = [];

        var meshIndex = this.data.baseIndex | 0;
        for (var i = 0; i < this.data.meshes.length; ++i)
            fragIds.push(meshIndex++);        

        return fragIds;
    };

    loader.viewer3DImpl.api.dispatchEvent({
        type: av.FRAGMENTS_LOADED_EVENT,
        model: loader.model,
        getFragIds: getFragIds,
        data: data,
    });
};

F2DLoader.prototype.loadFydoCB = function(path, options, onDone, onWorkerStart) {
    this.t0 = Date.now();

    var svfPath = WGS.pathToURL(path);

    // Streaming worker as data producer that generates fydo frame streams.
    this.streamingWorker = this.delegate.workerScript.createWorker();
    // Parsing worker as data consumer that consumes fydo frame streams and generate meshes.
    this.parsingWorker = this.delegate.workerScript.createWorker();
    var scope = this;
    var first = true;

    var terminateParser = function() {
        // The parse worker is only terminated when the loader is destroyed when we
        // are doing on demand loading. It is needed to supply buffers on demand.
        if (!scope.memoryOpts.onDemandLoading) {
            scope.parsingWorker.terminate();
            scope.parsingWorker = null;
        }
    };

    var onStream = function (ew) {

        if (!scope.isValid()) {
            return;
        }

        // Determine whether the current model should use on demand loading.
        // This can only be calculated after the metadata is read. We estimate
        // the number of vertex buffers we need to hold the data and turn it on
        // if there are too many.
        var shouldLoadOnDemand = function(metadata) {
            if (metadata) {
                var stats = metadata.geom_metrics;
                // Start counting segments, because most things are done as segments
                var verts = (stats.arcs + stats.circ_arcs) * 3; // 3 segments for arcs - 1 for the arc and 2 for caps
                verts += stats.circles; // 1 segment for a circle
                verts += (stats.pline_points - (stats.plines || 0)); // 1 segment for each line segment, stats.plines not always present
                verts += stats.rasters;   // 1 segment for each raster
                verts += (stats.ptri_indices / 3) * 3; // max 3 per triangle for antialiased edges
                var indices;
                // Need to keep this in sync with the F2D parser in lmvtk.
                var vertsPerBuffer = avp.isMobileDevice ? 16383 : 32767;
                if (scope.useInstancing) {
                    // Triangles get one vertex when instanced
                    verts += stats.ptri_indices / 3;
                    indices = 0;    // Don't use indices with instancing
                    vertsPerBuffer /= 4;
                } else {
                    indices = verts * 6 + stats.ptri_indices;
                    verts *= 4;
                    verts += stats.ptri_points;     // verts in poly triangles
                }
                // Calculate memory needed in MB
                var memNeeded = (verts * (VERT_SIZE + WGS.GEOMETRY_OVERHEAD / vertsPerBuffer) + indices * INDEX_SIZE) / MEGA + scope.fileMemorySize;
                // TODO: get this from the loader
                var memoryOpts = scope.memoryOpts;
                if (memoryOpts.onDemandLoading && !memoryOpts.debug.force
                    && memNeeded < memoryOpts.limit) {
                    memoryOpts.onDemandLoading = false;
                    memoryOpts.pageOutGeometryEnabled = false;
                }
                scope.totalGeomSize = memNeeded;
            }
            return scope.memoryOpts.onDemandLoading;
        };

        if (first && onWorkerStart) {
            first = false;
            onWorkerStart();
        }

        var msg;
        if (ew.data && ew.data.type == "F2DBLOB") {
            if (ew.data.hasOwnProperty("f2dSize"))
                scope.fileMemorySize = ew.data.f2dSize / MEGA;
            shouldLoadOnDemand(ew.data.metadata);
            msg = { operation:WORKER_PARSE_F2D,
                data: ew.data.buffer,
                metadata: ew.data.metadata,
                manifest: ew.data.manifest,
                basePath: ew.data.basePath,
                f2dLoadOptions: {
                    modelSpace : options.modelSpace,
                    bgColor: options.bgColor,
                    isMobile: av.isMobileDevice(),
                    useInstancing: scope.useInstancing,
                    onDemandLoading: scope.memoryOpts.onDemandLoading
                },
                url: svfPath
                };
            scope.parsingWorker.doOperation(msg, [msg.data]);
            scope.streamingWorker.terminate();
            scope.streamingWorker = null;

        } else if (ew.data && ew.data.type == "F2DSTREAM") {
            // If we are streaming the file, then we need twice the
            // files size, because the stream worker and the parse
            // worker will keep a copy, until the stream worker is done
            if (ew.data.hasOwnProperty("f2dSize"))
                scope.fileMemorySize = 2 * ew.data.f2dSize / MEGA;
            shouldLoadOnDemand(ew.data.metadata);
            msg = { operation:WORKER_PARSE_F2D_FRAME,
                        data: ew.data.frames,
                        url: svfPath,
                        f2dLoadOptions: {
                            modelSpace : options.modelSpace,
                            bgColor: options.bgColor,
                            isMobile: av.isMobileDevice(),
                            useInstancing: scope.useInstancing,
                            onDemandLoading: scope.memoryOpts.onDemandLoading
                        }
                      };

            //first frame
            if (ew.data.metadata) {
                msg.metadata = ew.data.metadata;
                msg.manifest = ew.data.manifest;
            }

            //last frame?
            if (ew.data.finalFrame) {
                msg.finalFrame = true;
                scope.streamingWorker.terminate();
                scope.streamingWorker = null;
                scope.fileMemorySize /= 2;  // Only one copy of the file now
            }

            if (ew.data.progress)
                scope.viewer3DImpl.signalProgress(100 * ew.data.progress, av.ProgressState.LOADING);

            scope.parsingWorker.doOperation(msg, msg.data ? [msg.data] : undefined);

        } else if (ew.data && ew.data.type == "F2DAssetURL") {
            avp.assets = avp.assets.concat(ew.data.urls);
        } else if (ew.data && ew.data.assetRequest) {
            avp.assets.push(ew.data.assetRequest);
        } else if (ew.data && ew.data.progress) {
            //just ignore progress-only message, it's only needed by the initial worker start notification above
        } else if (ew.data && ew.data.debug) {
            avp.logger.debug(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            scope.streamingWorker.terminate();
            scope.streamingWorker = null;
            if (onDone)
                onDone.call(this, ew.data.error);
        } else {
            avp.logger.error("F2D download failed.", av.errorCodeString(av.ErrorCodes.NETWORK_FAILURE));
            scope.loading = false;
            scope.streamingWorker.terminate();
            scope.streamingWorker = null;
        }
    };



    var onParse = function (ew) {

        if (!scope.isValid()) {
            return;
        }
        
        if (first && onWorkerStart) {
            first = false;
            onWorkerStart();
        }

        var f, i;
        if (ew.data && ew.data.f2d) {
            f = scope.svf = ew.data.f2d;

            terminateParser();
            
            avp.logger.info("Num polylines: " + f.numPolylines);
            avp.logger.info("Line segments: " + f.numLineSegs);
            avp.logger.info("Circular arcs: " + f.numCircles);
            avp.logger.info("Ellipitcal arcs:" + f.numEllipses);
            avp.logger.info("Plain triangles:" + f.numTriangles);
            avp.logger.info("Total # of op codes generated by fydo.parse: " + f.opCount);

            scope.onModelRootLoadDone(scope.svf);

            if (onDone)
                onDone(null, scope.model);

            scope.viewer3DImpl.api.dispatchEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:scope.svf, model:scope.model});
            

            for (i=0; i < f.meshes.length; i++) {
                scope.processReceivedMesh2D(f.meshes[i], i);
            }

            f.meshes = null;

            scope.onGeomLoadDone();

            scope.loading = false;

        }  else if (ew.data && ew.data.f2dframe) {
            var baseIndex = 0;

            if (!ew.data.meshes) {
                //First message from the worker
                scope.svf = ew.data.f2dframe;
                baseIndex = ew.data.baseIndex;
            } else {
                //Update the world box and current mesh index
                //on subsequent messages from the worker.
                var bbox = ew.data.bbox;
                scope.svf.bbox = new THREE.Box3(bbox.min, bbox.max);
                baseIndex = ew.data.baseIndex;
            }

            f = scope.svf;

            if (!f.fragments || !f.fragments.initialized) {
                //First message from the worker,
                //initialize the load states, fragment lists, etc.
                scope.onModelRootLoadDone(f);

                if (onDone) {
                    onDone(null, scope.model);
                }
                scope.viewer3DImpl.api.dispatchEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:f, model:scope.model});

            }

            if (ew.data.meshes && ew.data.meshes.length)
            {
                for (i = 0; i < ew.data.meshes.length; i++) {
                    scope.processReceivedMesh2D(ew.data.meshes[i], baseIndex+i);
                }

                if (scope.pagingProxy && scope.pagingProxy.onDemandLoadingEnabled())
                    fireFragmentsLoadedEvent(scope, ew.data);
            }

            if (ew.data.finalFrame) {
                //Update the F2D properties which are accumulated
                //while reading the F2D stream.
                var cumulativeProps = ew.data.cumulativeProps;
                for (var p in cumulativeProps) {
                    f[p] = cumulativeProps[p];
                }

                terminateParser();

                scope.onGeomLoadDone();

                scope.loading = false;

                if (scope.pagingProxy)
                    scope.pagingProxy.onFinalFrame();
            }

        } else if (ew.data && ew.data.progress) {
            //just ignore progress-only message, it's only needed by the initial worker start notification above
        } else if (ew.data && ew.data.debug) {
            avp.logger.debug(ew.data.message);
        } else if (ew.data && ew.data.canceled && scope.pagingProxy) {
            scope.pagingProxy.cancelAcknowledged();
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            terminateParser();

            avp.logger.error("Error while processing F2d: " + JSON.stringify(ew.data.error.args));

            if (onDone)
                onDone.call(this, ew.data.error);
        } else {
            avp.logger.error("F2D download failed.", av.errorCodeString(av.ErrorCodes.NETWORK_FAILURE));
            //Download failed.
            scope.loading = false;
            terminateParser();
        }
    };

    this.streamingWorker.addEventListener('message', onStream, false);
    this.parsingWorker.addEventListener('message', onParse, false);

    var msg = { operation:WORKER_STREAM_F2D,
        url: svfPath,
        objectIds : options.ids,
        queryParams : this.queryParams };  // For CORS caching issue.

    this.streamingWorker.doOperation(avp.initLoadContext(msg));

    return true;
};



F2DLoader.prototype.processReceivedMesh = function(mdata) {

    //Find all fragments that instance this mesh
    var meshid = mdata.packId + ":" + mdata.meshIndex;

    var svf = this.svf;
    var fragments = svf.fragments;

    var fragIndexes = fragments.mesh2frag[meshid];
    if (fragIndexes === undefined) {
        avp.logger.warn("Mesh " + meshid + " was not referenced by any fragments.");
        return;
    }
    if (!Array.isArray(fragIndexes))
        fragIndexes = [fragIndexes];

    //Convert the received mesh to THREE buffer geometry
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var numInstances = fragIndexes.length;

    var rm = this.model;
    
    //Reuse previous index of this geometry, if available
    rm.getGeometryList().addGeometry(mdata.geometry, numInstances, mdata.meshIndex + 1);

    var ib = mdata.geometry.attributes['index'].array || mdata.geometry.ib;
    var polyCount = ib.length / 3;

    //For each fragment, add a mesh instance to the renderer
    for (var i=0; i<fragIndexes.length; i++) {
        var fragId = 0|fragIndexes[i];

        //We get the matrix from the fragments and we set it back there
        //with the activateFragment call, but this is to maintain the
        //ability to add a plain THREE.Mesh -- otherwise it could be simpler
        rm.getFragmentList().getOriginalWorldMatrix(fragId, this.tmpMatrix);

        if (this.options.placementTransform) {
            this.tmpMatrix = new THREE.Matrix4().multiplyMatrices(this.options.placementTransform, this.tmpMatrix);
        }

        var materialId = fragments.materials[fragId].toString();

        if (fragments.polygonCounts)
            fragments.polygonCounts[fragId] = polyCount;

        var m = this.viewer3DImpl.setupMesh(this.model, mdata.geometry, materialId, this.tmpMatrix);
        rm.activateFragment(fragId, m);
    }

    //don't need this mapping anymore.
    fragments.mesh2frag[meshid] = null;

    //Repaint and progress reporting
    fragments.numLoaded += fragIndexes.length;

    fragments.numLoaded;
};

F2DLoader.prototype.processReceivedMesh2D = function(mesh, mindex) {

    if (this.pagingProxy && !this.pagingProxy.onMeshReceived(mesh, mindex))
        return;

    var mdata = { mesh: mesh, is2d: true, packId : "0", meshIndex: mindex };

    var meshId = "0:" + mindex;

    var frags = this.svf.fragments;

    // Only process the dbids the first time we process the fragment
    if (!frags.fragId2dbId[mindex]) {
        //Remember the list of all dbIds referenced by this mesh.
        //In the 2D case this is 1->many (1 frag = many dbIds) mapping instead of
        // 1 dbId -> many fragments like in the SVF 3D case.
        var dbIds = Object.keys(mdata.mesh.dbIds).map(function(item){return parseInt(item);});
        frags.fragId2dbId[mindex] = dbIds;

        //TODO: dbId2fragId is not really necessary if we have a good instance tree for the 2D drawing (e.g. Revit, AutoCAD)
        //so we can get rid of this mapping if we can convert Viewer3DImpl.highlightFragment to use the same logic for 2D as for 3D.
        for (var j=0; j<dbIds.length; j++) {
            var dbId = dbIds[j];
            var fragIds = frags.dbId2fragId[dbId];
            if (Array.isArray(fragIds))
                fragIds.push(mindex);
            else if (typeof fragIds !== "undefined") {
                frags.dbId2fragId[dbId] = [fragIds, mindex];
            }
            else {
                frags.dbId2fragId[dbId] = mindex;
            }
        }

        mesh.material.modelScale = this.modelScale;
        var viewer = this.viewer3DImpl;
        frags.materials[mindex] = this.viewer3DImpl.matman().create2DMaterial(this.model, mesh.material, false, false, function() { viewer.invalidate(false, true, false); });

        frags.length++;
    }
    frags.mesh2frag[meshId] = mindex;

    this.processReceivedMesh(mdata);

};

F2DLoader.prototype.onModelRootLoadDone = function(svf) {

    //In the 2d case we create and build up the fragments mapping
    //on the receiving end.
    svf.fragments = {};
    svf.fragments.mesh2frag = {};
    svf.fragments.materials = [];
    svf.fragments.fragId2dbId = [];
    svf.fragments.dbId2fragId = [];
    svf.fragments.length = 0;
    svf.fragments.initialized = true;


    svf.geomMemory = 0;
    svf.fragments.numLoaded = 0;
    svf.gpuNumMeshes = 0;
    svf.gpuMeshMemory = 0;

    svf.nextRepaintPolys = 10000;
    svf.numRepaints = 0;

    svf.urn = this.svfUrn;
    svf.acmSessionId = this.acmSessionId;

    svf.basePath = "";
    var lastSlash = this.currentLoadPath.lastIndexOf("/");
    if (lastSlash != -1)
        svf.basePath = this.currentLoadPath.substr(0, lastSlash+1);

    svf.loadOptions = this.options;

    var t1 = Date.now();
    this.loadTime += t1 - this.t0;
    avp.logger.log("SVF load: " + (t1 - this.t0));

    this.t0 = t1;

    //The BBox object loses knowledge of its
    //type when going across the worker thread boundary...
    svf.bbox = new THREE.Box3().copy(svf.bbox);

    //Create the API Model object and its render proxy
    var model = this.model = new av.Model(svf);
    model.loader = this;

    // Let's set the options through for each model that control how memory saving mode start,
    // which decide how to load geometry pack files, and whether paging out if needed.
    // And assume the performance tuning options passed through viewer's config.
    var memoryOpts = this.memoryOpts;

    // So, for now do not support on paging for multiple models. 
    if (this.viewer3DImpl.modelQueue().getModels().length > 0) {
        // If already a model loaded into viewer, then disable paging for the other ones.
        memoryOpts.pageOutGeometryEnabled = false;
    }

    if (memoryOpts.onDemandLoading)
        this.pagingProxy = new F2DPagingProxy(this, memoryOpts);

    model.initialize(this.pagingProxy);

    //We would not load property db when we are on mobile device AND on demand loading is on (which
    //implies the model is not 'normal' in terms of its size.). This is only a temp solution that
    //allow big models loads on mobile without crash. Without property db loading selection could break.
    var shouldLoadPropertyDb = !(this.model.getFragmentList().onDemandLoadingEnabled() && (av.isMobileDevice()));
    if (shouldLoadPropertyDb && !this.options.skipPropertyDb) {
        this.svf.propDbLoader = new WGS.PropDbLoader(this.sharedDbPath, this.model, this.delegate);
    }

    avp.logger.log("scene bounds: " + JSON.stringify(svf.bbox));

    var metadataStats = {
        category: "metadata_load_stats",
        urn: svf.urn,
        layers: svf.layerCount
    };
    avp.logger.track(metadataStats);

    this.viewer3DImpl.signalProgress(5, av.ProgressState.ROOT_LOADED);
    this.viewer3DImpl.invalidate(false, false);
};


F2DLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = true;

    // Don't need these anymore
    this.svf.fragments.entityIndexes = null;
    if (!this.memoryOpts.onDemandLoading)
        this.svf.fragments.mesh2frag = null;

    var t1 = Date.now();
    var msg = "Fragments load time: " + (t1 - this.t0);
    this.loadTime += t1 - this.t0;

    //Load the property database after all geometry is loaded (2D case). For 2D,
    //the fragId->dbId mapping is only fully known once geometry is loaded, as
    //it's built on the fly.
    //TODO: As an optimization we can split the property db logic into two calls -- one to load the files
    //in parallel with the geometry and a second to do the processing.
    if (!this.options.skipPropertyDb)
        this.loadPropertyDb();

    avp.logger.log(msg);

    var modelStats = {
        category: "model_load_stats",
        is_f2d: true,
        has_prism: this.viewer3DImpl.matman().hasPrism,
        load_time: this.loadTime,
        geometry_size: this.model.getGeometryList().geomMemory,
        meshes_count: this.model.getGeometryList().geoms.length,
        urn: this.svfUrn
    };
    avp.logger.track(modelStats, true);

    function sendMessage(data){
        if (av.isBrowser) {
            var handler = window.webkit.messageHandlers.callbackHandler;
            // We add doOperation() function, but on some implementation
            // of the WebWorker, setting a new property on it is not allowed
            // so we fallback onto the wrapped function
            
            // The post message operation has to be called on the instance of handler.
            if (handler.doOperation) {
               handler.doOperation({'command':'assets', data: data});
            }
            else if (handler.postMessage) {
               handler.postMessage({'command':'assets', data: data});
            }

        }
    }

    if (avp.assets) {
        // Callback to ios.
        if (av.isBrowser && window.webkit) {
            sendMessage(avp.assets);
            avp.assets = null;
        }
    }

    this.currentLoadPath = null;
    this.isf2d = undefined;

    this.memoryOpts.onDemandLoading ? this.viewer3DImpl.onDemandLoadComplete(this.model) : this.viewer3DImpl.onLoadComplete(this.model);
};


F2DLoader.prototype.loadPropertyDb = function() {
    if (this.svf.propDbLoader)
        this.svf.propDbLoader.load();
};

F2DLoader.prototype.is3d = function() {
    return false;
};


avp.F2DLoader = F2DLoader;
avp.F2DPagingProxy = F2DPagingProxy;

av.FileLoaderManager.registerFileLoader("f2d", ["f2d"], avp.F2DLoader);


})();

/*
 * ScalarisLoader
 *
 * Loads scalaris geometry files. It is trigger by loading a file with .scalaris extension or by specifying the default file type
 * in the options to loadModel() method.
 *
 * For detailed information on Scalaris Data Model (“neutral format for Simulation & Forge”), refer to the following links:
 * - https://wiki.autodesk.com/display/NFDC/Scalaris+for+Autodesk+Generative+Design
 * - https://wiki.autodesk.com/pages/viewpage.action?spaceKey=MPGART&title=Project+Scalaris
 * - https://pages.git.autodesk.com/dmg-nfdc/ScalarisDataModel/documentation.html
 * - https://git.autodesk.com/MPGART/Scalaris
 *
 * Authors: Parviz Rushenas (Parviz.Rushenas@autodesk.com) & Ania Lipka (Ania.Lipka@autodesk.com)
 */
(function(){

  "use strict";

  var WORKER_LOAD_SCALARIS  = "LOAD_SCALARIS";
  var SCALARIS_PROTO_LOCATION =  "res/protobuf/scalaris.proto";
  var MODEL_UNITS = "meter";
  var ROOT_NODE_NAME = "RootNode";
  var GEOMETRY_NODE_NAME = "Geometry";

  var scalarisLoader = function (delegate, config) {
      this.viewer3DImpl = delegate.viewer3DImpl;
      this.delegate = WGS.FileLoader.copyDelegate(this, delegate);
      this.loading = false;
  };

  scalarisLoader.prototype.dtor = function () {
    this.viewer3DImpl = null;
    this.model  = null;
    this.svf    = null;
    this.logger = null;

    this.loading  = false;
  };

  scalarisLoader.prototype.isValid = function() {
    return this.viewer3DImpl != null;
  };

  scalarisLoader.prototype.loadFile = function(path, options, onDone, onWorkerStart) {
    if (!this.viewer3DImpl) {
      avp.logger.log("Scalaris loader was already destructed. So no longer usable.");
      return false;
    }

    if (this.loading) {
      avp.logger.log("Loading of Scalaris already in progress. Ignoring new request.");
      return false;
    }

    this.loading = true;
    this.viewer3DImpl._addLoadingFile(this);

    this.currentLoadPath = path;
    var basePath = "";
    var lastSlash = this.currentLoadPath.lastIndexOf("/");
    if (lastSlash != -1)
      basePath = this.currentLoadPath.substr(0, lastSlash+1);
    this.basePath = basePath;


    this.options = options;
    this.options.debug = {};
    this.options.preserveView = true; // to preserve the view set by setViewCube

    var scope = this;

    this.initWorkerScriptToken = this.delegate.workerScript.initWorkerScript(function() {
      scope.loadScalarisCB(path, scope.options, onDone, onWorkerStart);
    });

    return true;
  };

  scalarisLoader.prototype.loadScalarisCB = function(path,  options, onDone, onWorkerStart) {
    var first = true;
    var scope = this;
    var w = this.svfWorker = this.delegate.workerScript.createWorkerWithIntercept();

    var onScalarisLoad = function (ew) {
      var cleaner = function() {
        if (w) {
          w.clearAllEventListenerWithIntercept();
          w.terminate();
          scope.svfWorker = null;
          w = null;
        }
      };

      if (first && onWorkerStart) {
        first = false;
        onWorkerStart();
      }

      if (ew.data && ew.data.geometry) {
        // Decompression is done.
        var svf = scope.svf = ew.data.geometry;
        scope.onModelRootLoadDone(svf);

        if (onDone) {
          onDone(null, scope.model);
        }

        scope.viewer3DImpl.api.dispatchEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:svf, model:scope.model});

      } else if (ew.data && ew.data.progress) {
        // Delay onGeomLoadDone so that UI has time to build.
        if (ew.data.progress == 1) {
          setTimeout(function () {
            scope.onGeomLoadDone();
            scope.loading = false;
            cleaner();
          }, 1);
        }
      } else if (ew.data && ew.data.error) {
        scope.loading = false;
        cleaner();
        if (onDone) {
          onDone(ew.data.error, null);
        }
      } else if (ew.data && ew.data.debug) {
        avp.logger.debug(ew.data.message);
      } else {
        avp.logger.error("Scalaris load failed.", av.errorCodeString(av.ErrorCodes.NETWORK_FAILURE));
        // Load failed.
        scope.loading = false;
        cleaner();
      }
    };

    w.addEventListenerWithIntercept(onScalarisLoad);

    var loadContext = {
      url: WGS.pathToURL(path),
      basePath: this.currentLoadPath,
      scalarisProtoPath: avp.getResourceUrl(SCALARIS_PROTO_LOCATION)
    };

    loadContext.operation = WORKER_LOAD_SCALARIS;
    w.doOperation(avp.initLoadContext(loadContext));

    return true;
  };

  scalarisLoader.prototype.onModelRootLoadDone = function(svf) {
    // Root model loading is done, and loader now is attached to model,
    // so can remove the direct reference to it from viewer impl.
    this.viewer3DImpl._removeLoadingFile(this);

    svf.basePath = this.basePath;
    svf.disableStreaming = true;
    svf.geomPolyCount = 0;
    svf.gpuNumMeshes = 0;
    svf.gpuMeshMemory = 0;

    svf.fragments = {
      length : svf.meshCount,
      numLoaded : 0,
      boxes : null,
      transforms : null,
      materials : null,

      fragId2dbId : null,
      entityIndexes : null,
      mesh2frag : null
    };

    svf.animations = null;
    svf.nodeToDbId = {};
    svf.loadOptions = this.options;

    svf.bbox = new THREE.Box3(svf.min, svf.max);

    // Create the API Model object and its render proxy
    var model = this.model = new av.Model(svf);
    if (svf.urn) {
      model.setUUID(svf.urn);
    }
    model.initialize();
    model.loader = this;

    this.viewer3DImpl.signalProgress(5, av.ProgressState.ROOT_LOADED);
    this.viewer3DImpl.invalidate(false, false);
  };

  scalarisLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = true;

    var fragLength = this.svf.fragments.length;
    this.svf.numGeoms = fragLength;

    this.svf.fragments.numLoaded = fragLength;
    this.svf.fragments.boxes = new Float32Array(fragLength*6);
    this.svf.fragments.transforms = new Float32Array(fragLength * 12);
    this.svf.fragments.materials = new Int32Array(fragLength);
    this.svf.fragments.fragId2dbId = new Int32Array(fragLength);
    this.svf.fragments.mesh2frag = new Int32Array(fragLength);

    var ensureChunk = function(geometry) {
      if (geometry.offsets.length === 0) {
        var chunkSize = 21845;
        var numTris = geometry.attributes.index.array.length / 3;
        var offsets = numTris / chunkSize;
        for (var i = 0; i < offsets; i++) {
          var offset = {
            start: i * chunkSize * 3,
            count: Math.min( numTris - ( i * chunkSize ), chunkSize ) * 3
          };
          geometry.addDrawCall(offset.start, offset.count);
        }
      }
    };

    var ensureNormals = function(geometry) {
      if (geometry.attributes.normal.array.length == 0) {
        geometry.attributes.normal.array = new Float32Array(geometry.attributes.position.array.length);
        geometry.computeVertexNormals();
      }
    };

    var commitGeometry = function(geometryData) {
      var geometry = new THREE.BufferGeometry();
      geometry.byteSize = 0;
      geometry.addAttribute('index', new THREE.BufferAttribute(new Uint32Array(geometryData.indices), 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometryData.vertices), 3));
      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometryData.normals), 3));

      if (geometryData.hasOwnProperty('uvs') && geometryData.uvs.byteLength > 0) {
        geometry.byteSize += geometryData.uvs.byteLength;
        geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometryData.uvs), 2));
      }

      if (geometry.attributes.index.array.length > 0 && geometry.attributes.position.array.length > 0) {
        if (geometryData.hasOwnProperty('offsets') && geometryData.offsets.byteLength > 0) {
          geometry.byteSize += geometryData.offsets.byteLength;
          for (var i = 0; i < geometryData.offsets.length; i++) {
            var offset = geometryData.offsets[i];
            geometry.addDrawCall(offset.start, offset.count);
          }
        }

        if (geometryData.min) {
          geometry.boundingBox = new THREE.Box3(new THREE.Vector3(geometryData.min.x, geometryData.min.y, geometryData.min.z),
            new THREE.Vector3(geometryData.max.x, geometryData.max.y, geometryData.max.z));
        } else {
          geometry.computeBoundingBox();
        }
        geometryData.bbox.min = geometryData.min = geometry.boundingBox.min;
        geometryData.bbox.max = geometryData.max = geometry.boundingBox.max;

        ensureChunk(geometry);
        ensureNormals(geometry);

        geometry.byteSize += geometryData.indices.byteLength + geometryData.vertices.byteLength + geometryData.normals.byteLength;
        geometry.polyCount = geometry.attributes.index.array.length / 3;

        return geometry;
      }

      return null;
    };

    var svf = this.svf;

    // Get the THREE.BufferGeometry.
    var geometry = commitGeometry(svf);

    svf.geomPolyCount += geometry.polyCount;

    var meshId = 0;
    var fragId = 0;
    var matId  = null; // no material info for now.

    this.createInstanceTree(fragId);

    var dbId = 2;     // The id of the geometry node in the Instance tree (for this fragment).

    this.model.getGeometryList().addGeometry(geometry, 1 /*numOfInstances*/, meshId);

    var matrix = new THREE.Matrix4();
    var mesh = this.viewer3DImpl.setupMesh(this.model, geometry, matId, matrix);

    svf.fragments.materials[fragId] = matId;
    svf.fragments.fragId2dbId[fragId] = dbId;
    svf.fragments.mesh2frag[meshId] = fragId;

    var bbox = svf.fragments.boxes;
    bbox[0] = svf.min.x;
    bbox[1] = svf.min.y;
    bbox[2] = svf.min.z;
    bbox[3] = svf.max.x;
    bbox[4] = svf.max.y;
    bbox[5] = svf.max.z;

    var trans = svf.fragments.transforms;
    for (var i = 0; i < 12; i++)
      trans[i] = 0;
    trans[0] = trans[4] = trans[8] = 1;

    this.model.activateFragment(fragId, mesh, !!svf.placementTransform);

    this.currentLoadPath = null;

    this.viewer3DImpl.api.setModelUnits(MODEL_UNITS);
    this.viewer3DImpl.onLoadComplete(this.model);
    this.viewer3DImpl.api.fitToView();
  };

  scalarisLoader.prototype.createInstanceTree = function(fragId) {
    var storage = new avp.InstanceTreeStorage(2, 1);

    var rootDbId = 1; // dbId are 1-based.
    var geomDbId = 2;
    var rootChildrenDbIds = [geomDbId];
    var geomChildrenDbIds = [];

    storage.setNode(rootDbId, 0, ROOT_NODE_NAME, 0, rootChildrenDbIds, []);
    storage.setNode(geomDbId, rootDbId, GEOMETRY_NODE_NAME, 0, geomChildrenDbIds, [fragId]);

    var nodeAccess = new avp.InstanceTreeAccess(storage, 0);
    nodeAccess.computeBoxes(this.svf.fragments.boxes);

    this.svf.instanceTree = new avp.InstanceTree(nodeAccess, 1, 1);
  };

  scalarisLoader.prototype.is3d = function() {
    return true;
  };

  av.ScalarisLoader = scalarisLoader;
  av.FileLoaderManager.registerFileLoader("scalaris", ["scalaris"], av.ScalarisLoader);

})();


(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

/** Loader for leaflet image pyramids and simple image files. 
 *   @param {Viewer3DImpl} parent
 */
function LeafletLoader(parent) {

    var _parent = parent.viewer3DImpl;
    
    /** 
     * @callback LoadSuccessCB
     *   @param {RenderModel}
     *
     * @callback LoadErrorCB
     *   @param {number} errorCode
     *   @param {string} errorMsg
     *   @param {number} statusCode
     *   @param {string} statusText
     */

     /*
     * @param {string}        path
     * @param {Object}        [options]              Dictionary with options parsed from query string. 
     * @para  {Object}        [options.loadOptions]  For leaflets, this must contain additional params like tileSize, texWidth etc. (see TexQuadConfig.initFromLoadOptions)
     * @param {number}        [options.acmSessionId] Required when requesting non-public image files. 
     * @param {LoadDoneCB}    onDone 
     */
    this.loadFile = function(path, options, onDone, onWorkerStart) {

        var t0 = Date.now();

        // get leaflet params from loader options. Note that it's no error if we don't find them,
        // because simple image files can be loaded without any extra options
        var config = new avp.TexQuadConfig();
        config.initFromLoadOptions(path, options.loadOptions, function(imageURL, onSuccess, onError) {
            WGS.TextureLoader.loadTextureWithSecurity(imageURL, THREE.UVMapping, onSuccess, options.acmSessionId, avp.initLoadContext, isSimpleImage);
        });

        var iter = null;

        //The Leaflet loader has no long running worker thread initialization,
        //so we can call back the viewer to continue its renderer initialization.
        if (onWorkerStart)
            onWorkerStart();

        //The code below requires the renderer (and the materials manager in particular)
        //to exist, which happens when we call back onWorkerStart above.
        function onLoad() {

            // Create ModelData. Will be returned when calling model.getData() on the data model
            function LeafletModelData(loadOptions) {
                // used by Viewer3DImpl for initial camera adjustment     
                this.bbox     = new THREE.Box3();                

                this.basePath = path;

                // run viewer in 2D mode
                this.is2d = true;

                // get paper extent. If not specified in the load options, use the texture resolution so that
                // measurement works in pixels
                var paperWidth  = (loadOptions && loadOptions.paperWidth >=0.0) ? loadOptions.paperWidth  : config.texWidth;
                var paperHeight = (loadOptions && loadOptions.paperHeight>=0.0) ? loadOptions.paperHeight : config.texHeight;

                // transform for measurement tools
                this.pageToModelTransform = config.getPageToModelTransform(paperWidth, paperHeight);

                // make page dimensions available to viewer and tools. We store this in an own object metadata.page_dimensions.
                // This is done for consistency with F2D, so that functions like Model.getMetaData() and Model.getDisplayUnits() can use it.
                this.metadata = {};
                this.metadata.page_dimensions = {};
                var pd = this.metadata.page_dimensions;
                pd.page_width  = paperWidth;
                pd.page_height = paperHeight;
                pd.page_units  = loadOptions.paperUnits;

                // signal that the model is ready to use, e.g., to do measurements
                this.loadDone = true;
                this.isLeaflet = true;
                _parent.signalProgress(100, av.ProgressState.LOADING);

                // Note: When just loading images, we don't know texWidth at this point, but must
                //       wait for the texture. Therefore, the zoomIn constraint is currently only applied
                //       if we know the size in advance.
                if (config.texWidth > 0) {
                    // store hint to restrict zoom-in when we reach max resolution.
                    this.maxPixelPerUnit = config.texWidth / config.getQuadWidth();
                }
            }

            var modelData = new LeafletModelData(options.loadOptions);
            // To be consistent with other loaders and expected by some code setions,
            // save loadOptions to the model data.
            modelData.loadOptions = options;

            iter.getVisibleBounds(modelData.bbox);

            // Create RenderModel with texQuad iterator
            var model = new av.Model(modelData);
            model.initFromCustomIterator(iter);

            // Track loading time
            iter.callWhenRefined(function(){
                var t1 = Date.now();
                modelData.loadTime = t1 - t0;
                avp.logger.log("SVF load: " + modelData.loadTime); // Use SVF to make output consistent with other loaders
            }.bind(this));

            onDone(null, model);
        }

        // if we have no leaflet params, handle it as a single image
        var isSimpleImage = !config.valid();
        if (isSimpleImage) {
            // when displaying a single image, we don't know the extents in advance.
            // But we need them to determine the bbox for the initial camera placement.
            // Therefore, we defer the loading for this case until the image is loaded.
            // The image dimensions are then derived from the image file.
            config.initForSimpleImage(path, onLoad);
        }

        // Set pixel ratio to the same values as used by WebGLRenderer. In this way, we make full
        // use of the available render target resolution.
        config.pixelRatio = _parent.glrenderer().getPixelRatio();

        // create iterator 
        iter = new avp.ModelIteratorTexQuad(config, _parent.getMaterials());

        // when loading leaflets, we know texWidth/texHeight in advance and can
        // add finish loading right away. 
        if (!isSimpleImage) {
            onLoad();
        }
        
    };
}

// For standard leaflet hierarchies, the root level 0 is the only one with only one tile,
// i.e., there are already 2-4 tiles at level 1. 
// In contrast, the hierarchies produced by cloud translation start at a root resolution of 1x1,
// thus containing several levels that we have to skip. The number of skipped levels is controlled 
// by the 'levelOffset' parameter. 
// The level offset that we need for a hierarchy with a root resolution of 1x1 resolution depends
// on the tileSize and is computed by this function,
LeafletLoader.computeLevelOffset = function(tileSize) {
        
    // when reaching this, we abort the loop, because there is something strange
    // with the tileSize parameter.
    var MaxCycles = 20;
    
    var pixelSize = 1;
    var level     = 0;    
    for (var i=0; i<MaxCycles; i++) {
        // will the next level still fit into a single tile?
        pixelSize *= 2;

        // if no, stop here
        if (pixelSize > tileSize) {
            return level;
        }
        level++;
    }

    avp.logger.log("unexpected leaflet tileSize");
    return 0;
};

LeafletLoader.prototype.is3d = function() {
    return false;
};


Autodesk.Viewing.Private.LeafletLoader = LeafletLoader;

Autodesk.Viewing.FileLoaderManager.registerFileLoader("Leaflet", ["jpeg", "jpg", "png"], avp.LeafletLoader);

})();

// i18next, v1.7.3
// Copyright (c)2014 Jan Mühlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com

AutodeskNamespace('Autodesk.Viewing.i18n');

(function() {

    var debugLocString = null;

    // Set a specific string that will be used for key values when translating
    function setDebugLocString() {
        debugLocString = 'aaaa';
        localize();
    }

    // Nullify debugLocString and run localization
    function clearDebugLocString() {
        debugLocString = null;
        localize();
    }

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }
    
    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }
    
    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, ''); 
        }
    }

    var root = this
      , $ = root.jQuery || root.Zepto
      , i18n = {}
      , resStore = {}
      , currentLng
      , replacementCounter = 0
      , languages = []
      , initialized = false;

    // Export the i18next object for **CommonJS**. 
    // If we're not in CommonJS, add `i18n` to the
    // global object or to jquery.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = i18n;
    } else {
        if ($) {
            $.i18n = $.i18n || i18n;
        }
        root.i18n = root.i18n || i18n;
    }
    // defaults
    var o = {
        lng: undefined,
        load: 'current',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,
        
        resGetPath: 'res/locales/__lng__/__ns__.json',
        resPostPath: 'res/locales/add/__lng__/__ns__',
    
        getAsync: true,
        postAsync: true,
    
        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,
    
        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',
    
        interpolationPrefix: '__',
        interpolationSuffix: '__',
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,

        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,
    
        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
    
        shortcutFunction: 'sprintf' // or: defaultValue
    };

    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }
    
        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }
    
    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";
    
        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }
    
        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }
    
        return object;
    }
    
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };
    
    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }


    // This is taken from https://github.com/sindresorhus/strip-json-comments
    //
    var stripJsonComments = function( str ) {

        var currentChar;
        var nextChar;
        var insideString = false;
        var insideComment = false;
        var ret = '';

        for (var i = 0; i < str.length; i++) {
            currentChar = str[i];
            nextChar = str[i + 1];

            if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
                insideString = !insideString;
            }

            if (insideString) {
                ret += currentChar;
                continue;
            }

            if (!insideComment && currentChar + nextChar === '//') {
                insideComment = 'single';
                i++;
            } else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
                insideComment = false;
                i++;
            } else if (insideComment === 'single' && currentChar === '\n') {
                insideComment = false;
            } else if (!insideComment && currentChar + nextChar === '/*') {
                insideComment = 'multi';
                i++;
                continue;
            } else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
                insideComment = false;
                i++;
                continue;
            }

            if (insideComment) {
                continue;
            }

            ret += currentChar;
        }
        return ret;
    };

    function _ajax(options) {
    
        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }
    
            // If no XHR support was found, throw an error.
            return callback(new Error());
        };
    
        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }
    
            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }
    
            return result.join('&');
        };
    
        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';
    
            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
    
                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }
    
            return result;
        };
    
        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
    
            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);
    
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
    
                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }
    
                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);
    
            return result;
        };
    
        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];
    
            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }
    
            // Return the merged headers.
            return result;
        };

        //
        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }
    
            // Set default parameter values.
            options.doNotCache = options.doNotCache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;

            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);
    
            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }
    
            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }
    
                // Handle caching.
                if(options.doNotCache) {
                    queryString.push('_=' + (new Date()).getTime());
                }
    
                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }
    
                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }
    
                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }
    
            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);
    
                // Open the request.
                xhr.open(method, url, options.async);
    
                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }
    
                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';

                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }
    
                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, data );

                    }
                };
    
                // Actually send the XHR request.
                xhr.send(payload);
            });
        };
    
        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },
    
            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },
    
            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },
    
            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },
    
            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },
    
            headers: function (headers) {
                ajax.headers = headers || {};
            },
    
            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },
    
            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },
    
            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },
    
            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },
    
            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },
    
            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };
    
    
        var methode = options.type ? options.type.toLowerCase() : 'get';
    
        http[methode](options.url, options, function (status, data) {
            if (status === 200) {
                options.success(data, status, null);
            } else {
                options.error(data, status, null);
            }
        });
    }
    
    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },
    
        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },
    
        remove: function(name) {
            this.create(name,"",-1);
        }
    };
    
    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };
    
    
    
    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        toLanguages: function(lng) {
            var languages = [];
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');
    
                lng = o.lowerCaseLng ?
                    parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                    parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
    
                if (o.load !== 'unspecific') languages.push(lng);
                if (o.load !== 'current') languages.push(parts[0]);
            } else {
                languages.push(lng);
            }
    
            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(o.fallbackLng[i]);
            }
    
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }
    };

    function init(options, cb) {
        
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};
        
        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */
    
        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }
    
        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }
    
        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }
    
        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
    
        if (!o.lng) o.lng = f.detectLanguage(); 
        if (o.lng) {
            // set cookie with lng set (as detectLanguage will set cookie on need)
            if (o.useCookie) f.cookie.create(o.cookieName, o.lng, o.cookieExpirationTime, o.cookieDomain);
        } else {
            o.lng =  o.fallbackLng[0];
            if (o.useCookie) f.cookie.remove(o.cookieName);
        }
    
        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);
    
        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }
    
        pluralExtensions.setCurrentLng(currentLng);

        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            return;
        }
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // else load them
        Autodesk.Viewing.i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;
    
            if (cb) cb(lngTranslate);
        });
    }

    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }
    
    function addResourceBundle(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        f.extend(resStore[lng][ns], resources);
    }
    
    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
    }
    
    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }
    
    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }
    
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }
    
            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }
    
        if (lngNeedLoad.length) {
            Autodesk.Viewing.i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;
    
                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {
    
                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }
    
                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];
    
                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) Autodesk.Viewing.i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }
    
    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }
    
        options.lng = lng;
        return init(options, cb);
    }
    
    function lng() {
        return currentLng;
    }

    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;
    
        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
    
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;
    
        f.each(replacementHash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), value);
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.escape(value));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), value);
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }
    
    // append it to functions
    f.applyReplacement = applyReplacement;
    
    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';
    
        var opts = f.extend({}, options);
        delete opts.postProcess;
    
        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
    
    
            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }
    
            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, translated_token);
        }
        return translated;
    }
    
    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }
    
    function needsPlural(options) {
        return (options.count !== undefined && typeof options.count != 'string' && options.count !== 1);
    }
    
    function exists(key, options) {
        options = options || {};
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);
    
        return found !== undefined || found === notFound;
    }
    
    function translate(key, options) {
        options = options || {};
    
        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.');
            var colon = key.indexOf(":");
            if (colon < 0)
                colon = 0;
            else
                colon++;

            var stringToReturn = options.defaultValue || key.substr(colon);
            if (stringToReturn)
                stringToReturn = applyReplacement( stringToReturn, options );
            return stringToReturn;
        }
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }
    
    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }
    
    function _injectSprintfProcessor() {
    
        var values = [];
    
        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }
    
        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }
    
    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }
    
        if (potentialKeys === undefined || potentialKeys === null) return '';
    
        if (typeof potentialKeys == 'string') {
            potentialKeys = [potentialKeys];
        }
    
        var key = potentialKeys[0];
    
        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;

        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (found === undefined && o.sendMissing) {
            if (options.lng) {
                sync.postMissing(lngs[0], ns, key, notFound, lngs);
            } else {
                sync.postMissing(o.lng, ns, key, notFound, lngs);
            }
        }
    
        var postProcessor = options.postProcess || o.postProcess;
        if (found !== undefined && postProcessor) {
            if (postProcessors[postProcessor]) {
                found = postProcessors[postProcessor](found, key, options);
            }
        }

        // return localization test string, if a key is found and debugLocString is enabled
        if (debugLocString && found !== undefined) return debugLocString;
    
        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }
    
        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);
    
            if (postProcessor && postProcessors[postProcessor]) {
                var val = _getDefaultValue(key, options);
                found = postProcessors[postProcessor](val, key, options);
            }
        }
        return (found !== undefined) ? found : notFound;
    }
    
    function _find(key, options) {
        options = options || {};
    
        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;
    
        if (!resStore) { return notFound; } // no resStore to translate from
    
        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;
    
        // passed in lng
        if (options.lng) {
            lngs = f.toLanguages(options.lng);
    
            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;
    
                Autodesk.Viewing.i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }
    
        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;
    
            var contextKey = ns + o.nsseparator + key + '_' + options.context;
    
            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }
    
        if (needsPlural(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.count;
            optionWithoutCount.defaultValue = o.pluralNotFound;
    
            var pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
            var pluralExtension = pluralExtensions.get(lngs[0], options.count);
            if (pluralExtension >= 0) {
                pluralKey = pluralKey + '_' + pluralExtension;
            } else if (pluralExtension === 1) {
                pluralKey = ns + o.nsseparator + key; // singular
            }
    
            translated = translate(pluralKey, optionWithoutCount);
            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } // else continue translation with original/singular key
        }
    
        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;
    
            var l = lngs[i];
    
            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }
    
                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;
    
                found = value;
            }
        }
    
        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;
    
            if (o.fallbackNS.length) {
    
                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
    
                    if (found) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
    
                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
        }
    
        return found;
    }
    function detectLanguage() {
        var detectedLng;
    
        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var parms = query.split('&');
                for (var i=0; i<parms.length; i++) {
                    var pos = parms[i].indexOf('=');
                    if (pos > 0) {
                        var key = parms[i].substring(0,pos);
                        var val = parms[i].substring(pos+1);
                        qsParm[key] = val;
                    }
                }
            })();
            if (qsParm[o.detectLngQS]) {
                detectedLng = qsParm[o.detectLngQS];
            }
        }
    
        // get from cookie
        if (!detectedLng && typeof document !== 'undefined' && o.useCookie ) {
            var c = f.cookie.read(o.cookieName);
            if (c) detectedLng = c;
        }
    
        // get from navigator
        if (!detectedLng && typeof navigator !== 'undefined') {
            detectedLng =  (navigator.language) ? navigator.language : navigator.userLanguage;
        }
        
        return detectedLng;
    }
    var sync = {
    
        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }
    
                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);
    
                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },
    
        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();
    
            if(window.localStorage) {
    
                var todo = lngs.length;
    
                f.each(lngs, function(key, lng) {
                    var local = window.localStorage.getItem('res_' + lng);
    
                    if (local) {
                        local = JSON.parse(local);
    
                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }
    
                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },
    
        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    window.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },
    
        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};
            
            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;


                // Load each file individually.
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        
                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;
    
                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };
                        
                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });

            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };
    
                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    url = Autodesk.Viewing.Private.getResourceUrl(url);

                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data.json());
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "text",
                        async : options.getAsync
                    });
                }    
            }
        },
    
        _fetchOne: function(lng, ns, options, done) {

            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            url = Autodesk.Viewing.Private.getResourceUrl(url);

            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    //[LMV] Skip comments stripping because it's slow and we don't have comments in the localization files
                    var jsonData = data;//stripJsonComments( data );
                    done(null, JSON.parse( jsonData ));
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.log('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }
                    
                    done(error, {});
                },
                dataType: "text",
                async : options.getAsync
            });
        },
    
        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;
    
            var urls = [];
    
            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }
    
            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);
    
                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        }
    };

    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
    var pluralExtensions = {
    
        rules: {
            "ach": {
                "name": "Acholi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "af": {
                "name": "Afrikaans", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ak": {
                "name": "Akan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "am": {
                "name": "Amharic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "an": {
                "name": "Aragonese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ar": {
                "name": "Arabic", 
                "numbers": [
                    0, 
                    1, 
                    2, 
                    3, 
                    11, 
                    100
                ], 
                "plurals": function(n) { return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5); }
            }, 
            "arn": {
                "name": "Mapudungun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ast": {
                "name": "Asturian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ay": {
                "name": "Aymar\u00e1", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "az": {
                "name": "Azerbaijani", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "be": {
                "name": "Belarusian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "bg": {
                "name": "Bulgarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bn": {
                "name": "Bengali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bo": {
                "name": "Tibetan", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "br": {
                "name": "Breton", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "bs": {
                "name": "Bosnian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ca": {
                "name": "Catalan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "cgg": {
                "name": "Chiga", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "cs": {
                "name": "Czech", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "csb": {
                "name": "Kashubian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "cy": {
                "name": "Welsh", 
                "numbers": [
                    1, 
                    2, 
                    3, 
                    8
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3); }
            }, 
            "da": {
                "name": "Danish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "de": {
                "name": "German", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "dz": {
                "name": "Dzongkha", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "el": {
                "name": "Greek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "en": {
                "name": "English", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eo": {
                "name": "Esperanto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es": {
                "name": "Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es_ar": {
                "name": "Argentinean Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "et": {
                "name": "Estonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eu": {
                "name": "Basque", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fa": {
                "name": "Persian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "fi": {
                "name": "Finnish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fil": {
                "name": "Filipino", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fo": {
                "name": "Faroese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fr": {
                "name": "French", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fur": {
                "name": "Friulian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fy": {
                "name": "Frisian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ga": {
                "name": "Irish", 
                "numbers": [
                    1, 
                    2,
                    3,
                    7, 
                    11
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;}
            }, 
            "gd": {
                "name": "Scottish Gaelic", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    20
                ], 
                "plurals": function(n) { return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3); }
            }, 
            "gl": {
                "name": "Galician", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gu": {
                "name": "Gujarati", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gun": {
                "name": "Gun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ha": {
                "name": "Hausa", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "he": {
                "name": "Hebrew", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hi": {
                "name": "Hindi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hr": {
                "name": "Croatian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "hu": {
                "name": "Hungarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hy": {
                "name": "Armenian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ia": {
                "name": "Interlingua", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "id": {
                "name": "Indonesian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "is": {
                "name": "Icelandic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n%10!=1 || n%100==11); }
            }, 
            "it": {
                "name": "Italian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ja": {
                "name": "Japanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jbo": {
                "name": "Lojban", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jv": {
                "name": "Javanese", 
                "numbers": [
                    0, 
                    1
                ], 
                "plurals": function(n) { return Number(n !== 0); }
            }, 
            "ka": {
                "name": "Georgian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kk": {
                "name": "Kazakh", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "km": {
                "name": "Khmer", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kn": {
                "name": "Kannada", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ko": {
                "name": "Korean", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ku": {
                "name": "Kurdish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "kw": {
                "name": "Cornish", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    4
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3); }
            }, 
            "ky": {
                "name": "Kyrgyz", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lb": {
                "name": "Letzeburgesch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ln": {
                "name": "Lingala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "lo": {
                "name": "Lao", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lt": {
                "name": "Lithuanian", 
                "numbers": [
                    1, 
                    2,
                    10
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "lv": {
                "name": "Latvian", 
                "numbers": [
                    1, 
                    2, 
                    0
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2); }
            }, 
            "mai": {
                "name": "Maithili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mfe": {
                "name": "Mauritian Creole", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mg": {
                "name": "Malagasy", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mi": {
                "name": "Maori", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mk": {
                "name": "Macedonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n==1 || n%10==1 ? 0 : 1); }
            }, 
            "ml": {
                "name": "Malayalam", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mn": {
                "name": "Mongolian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mnk": {
                "name": "Mandinka", 
                "numbers": [
                    0, 
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(0 ? 0 : n==1 ? 1 : 2); }
            }, 
            "mr": {
                "name": "Marathi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ms": {
                "name": "Malay", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "mt": {
                "name": "Maltese", 
                "numbers": [
                    1, 
                    2, 
                    11, 
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3); }
            }, 
            "nah": {
                "name": "Nahuatl", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nap": {
                "name": "Neapolitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nb": {
                "name": "Norwegian Bokmal", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ne": {
                "name": "Nepali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nl": {
                "name": "Dutch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nn": {
                "name": "Norwegian Nynorsk", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "no": {
                "name": "Norwegian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nso": {
                "name": "Northern Sotho", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "oc": {
                "name": "Occitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "or": {
                "name": "Oriya", 
                "numbers": [
                    2, 
                    1
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pa": {
                "name": "Punjabi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pap": {
                "name": "Papiamento", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pl": {
                "name": "Polish", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "pms": {
                "name": "Piemontese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ps": {
                "name": "Pashto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt": {
                "name": "Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt_br": {
                "name": "Brazilian Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "rm": {
                "name": "Romansh", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ro": {
                "name": "Romanian", 
                "numbers": [
                    1, 
                    2,
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2); }
            }, 
            "ru": {
                "name": "Russian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "sah": {
                "name": "Yakut", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sco": {
                "name": "Scots", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "se": {
                "name": "Northern Sami", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "si": {
                "name": "Sinhala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sk": {
                "name": "Slovak", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "sl": {
                "name": "Slovenian", 
                "numbers": [
                    5, 
                    1, 
                    2, 
                    3
                ], 
                "plurals": function(n) { return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
            }, 
            "so": {
                "name": "Somali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "son": {
                "name": "Songhay", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sq": {
                "name": "Albanian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sr": {
                "name": "Serbian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "su": {
                "name": "Sundanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sv": {
                "name": "Swedish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sw": {
                "name": "Swahili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ta": {
                "name": "Tamil", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "te": {
                "name": "Telugu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tg": {
                "name": "Tajik", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "th": {
                "name": "Thai", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ti": {
                "name": "Tigrinya", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tk": {
                "name": "Turkmen", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tr": {
                "name": "Turkish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tt": {
                "name": "Tatar", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ug": {
                "name": "Uyghur", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "uk": {
                "name": "Ukrainian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ur": {
                "name": "Urdu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "uz": {
                "name": "Uzbek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "vi": {
                "name": "Vietnamese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "wa": {
                "name": "Walloon", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "wo": {
                "name": "Wolof", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "yo": {
                "name": "Yoruba", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "zh": {
                "name": "Chinese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }
        },
    
        // for demonstration only sl and ar is added but you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;    
        },
    
        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');
    
                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },
    
        get: function(lng, count) {
            var parts = lng.split('-');
    
            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule; 
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i = ext.plurals(c);
                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) { 
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }
                        
            return getResult(parts[0], count);
        }
    
    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };

    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }
    
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
    
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }
    
                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };
    
        str_format.cache = {};
    
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };

        return str_format;
    })();

    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };

    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;

        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }

        return val;
    });

    // medinaf: Added optional argument `domElement` to limit the extent of what DOM needs localization.
    var localize = function(domElement) {
        // Parse data
        function parse( data ) {

            // LMV may attempts to translate text such as "Hello [123]Here"
            // In the presence of square brackets, i18n will attempt to
            // set an attribute on the dom element:
            //
            //   elem.setAttribute(123,'Here');
            //
            //  Notice that "Hello " gets ignored in this typo of scenarios.
            //  The above code will fail because '123' is not a valid attribute.
            //
            // LMV does not care about this feature. Disabling it.
            return [null, data];
/*
            var attribute, value;

            var dataSplit = data.split(/\[|\]/);
            if (dataSplit.length === 1) {
                attribute = null;
                value = dataSplit[0];
            }
            else if (dataSplit.length===3) {
                attribute = dataSplit[1];
                value = dataSplit[2];
            }
            return [attribute, value];
*/
        };

        var rootNode = domElement || document;
        Array.prototype.forEach.call (rootNode.querySelectorAll ('[data-i18n]'), function (element){
            var dataToTranslate = element.getAttribute('data-i18n');
            var parsed  = parse( dataToTranslate );
            var attributeName  = parsed[0];
            var stringToTrans  = parsed[1];

            var translatedString = Autodesk.Viewing.i18n.translate(stringToTrans);
            if (translatedString)
            {
                if (attributeName) {
                    element.setAttribute( attributeName, translatedString );
                }
                else {
                    element.textContent = translatedString;
                }
            }
            else
            {
                if (attributeName) {
                    element.setAttribute( attributeName, stringToTrans );
                }
                else {
                    element.textContent = stringToTrans;
                }
            }
        });
    };

    // public api interface
    Autodesk.Viewing.i18n.init = init;
    Autodesk.Viewing.i18n.setLng = setLng;
    Autodesk.Viewing.i18n.preload = preload;
    Autodesk.Viewing.i18n.addResourceBundle = addResourceBundle;
    Autodesk.Viewing.i18n.removeResourceBundle = removeResourceBundle;
    Autodesk.Viewing.i18n.loadNamespace = loadNamespace;
    Autodesk.Viewing.i18n.loadNamespaces = loadNamespaces;
    Autodesk.Viewing.i18n.localize = localize;
    Autodesk.Viewing.i18n.setDefaultNamespace = setDefaultNamespace;
    Autodesk.Viewing.i18n.t = translate;
    Autodesk.Viewing.i18n.translate = translate;
    Autodesk.Viewing.i18n.exists = exists;
    Autodesk.Viewing.i18n.detectLanguage = f.detectLanguage;
    Autodesk.Viewing.i18n.pluralExtensions = pluralExtensions;
    Autodesk.Viewing.i18n.sync = sync;
    Autodesk.Viewing.i18n.functions = f;
    Autodesk.Viewing.i18n.lng = lng;
    Autodesk.Viewing.i18n.addPostProcessor = addPostProcessor;
    Autodesk.Viewing.i18n.options = o;
    Autodesk.Viewing.i18n.setDebugLocString = setDebugLocString;
    Autodesk.Viewing.i18n.clearDebugLocString = clearDebugLocString;

})();
// Viewer3D offers public methods for developers to use.
// Viewer3DImpl is the implementation file for Viewer3D and is only used by Viewer3D.js
// 
// Viewer3D does things like parameter validation.
// Viewer3DImpl does the actual work, by interfacing with other internal components, such as the MaterialManager.

var av = Autodesk.Viewing,
    avp = Autodesk.Viewing.Private;

var ENABLE_DEBUG = false; // avp.ENABLE_DEBUG || false;

(function() {

"use strict";

//default parameters for WebGL initialization
av.InitParametersSetting = {
    canvas: null,
    antialias: false,
    alpha: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: true,
    stencil: false,
    depth: false,
    devicePixelRatio: null
};


//progress state
av.ProgressState = {
    ROOT_LOADED : 0,
    LOADING : 1,
    RENDERING: 2
};

/** @constructor */
function Viewer3DImpl(thecanvas, theapi)
{
    var _this = this;

    //Frame time cutoffs in milliseconds. We target the middle value,
    //but adjust the CPU-side work in the give min/max range
    //once we measure actual frame times (including async GPU work, system load, etc).
    //NOTE: These are doubled for mobile devices at construction time (end of this file).
    var MAX_FRAME_BUDGET = 1000 / 15,
        TARGET_FRAME_TIME = 1000 / 30,
        MIN_FRAME_BUDGET = 1000 / 120; //We aren't hoping for 120 fps -- this is just how often tick() gets called
                                     //not counting GPU latency, etc.

    var _currentLightPreset = -1;
    var _oldLightPreset = -1;

    var _worldUp;
    var _worldUpName = "y";

    var _reqid, _needsResize, _newWidth, _newHeight, _materials;
    var _webglrender, _renderer;

    var _shadowMaps;

    // Default direction in world-space from which we get the most light from. Needed for shadow casting.
    // The default is only used if no direction is specified by light preset or model.
    var _shadowLightDirDefault = null; // {THREE.Vector3}
    var _shadowLightDir        = null; //

    var _lightDirDefault = null;

    var _needsClear = false,
        _needsRender = false,
        _overlayDirty = false;

    var _progressEvent = {type:Autodesk.Viewing.PROGRESS_UPDATE_EVENT, state:Autodesk.Viewing.ProgressState.LOADING, percent:0};

    var _sceneDirty = false;
    var _neededPresent = false; // True if previous frame needed to present.

    // A "silent render" means to do a full, but interruptible, render in the background. Display the result on completion.
    // The idea is to make a good-quality render after a progressive render occurs, or after some new content has been loaded,
    // or some other situation where we don't want to "lose progress," that is, we don't want to do a progressive render but
    // rather want to add to or modify an existing render on the screen.
    var _deferredSilentRender = false;
    var _immediateSilentRender = false;

    var _cameraUpdated;

    var _explodeScale = 0;

    var _lastHighResTimeStamp = 0;

    var _frameTimeAvg = 1000.0 / 60.0;
    var _frameTimeSamples = 0;

    var _isLoading = true;  // turned off in onLoadComplete()

    var _groundShadow, _groundReflection;

    var _envMapBackground = false;

    var _modelQueue;

    var _lightsInitialized        = false;
    var _defaultLightIntensity    = 1.0;
    var _defaultDirLightColor     = null; // {THREE.Color}
    var _defaultAmbientColor      = null; //

    var _lmvDisplay = av.getGlobal(); // return 'window', or something else for NodeJs context that won't work anyways.

    // render command system
    var _rcs;

    var _memoryLimit;

    var _pagingOptions = {
        visibleIdCB: function() {
            return _renderer ? _renderer.copyOcclusionIds() : null;
        },
        occlusionTestCB: function(boxes, threshold, fragIds, useInstancing, packId) {
            return _renderer ? _renderer.occlusionTest(boxes, threshold, fragIds, useInstancing, packId) : Promise.resolve(true);
        }
    };

    if (thecanvas) {
        setInterval(function() {
            // Only start reporting the framerate to ADP when there's been "enough" samples
            if (_isLoading || _frameTimeSamples < 60) {
                return;
            }
            _this.track({ name: 'fps', value: Number(_this.fps().toFixed(2)), aggregate: 'last' });
        }, 30000);
    }

    this.api = theapi;
    this.canvas = thecanvas;
    this.loader = null;

    //Slower initialization pieces can be delayed until after
    //we start loading data, so they are separated out here.
    this.initialize = function() {

        _worldUp = new THREE.Vector3(0,1,0);
        _modelQueue = new avp.RenderScene();

        //TODO: node webgl renderer
        _webglrender = createRenderer(thecanvas);
        if (!_webglrender && !av.isNodeJS) {
            return;
        }

        _renderer = new avp.RenderContext();
        _renderer.init(_webglrender, thecanvas ? thecanvas.clientWidth : 0, thecanvas ? thecanvas.clientHeight : 0);
        this.use2dInstancing = av.isMobileDevice() && this.glrenderer().supportsInstancedArrays();

        _materials = new avp.createMaterialManager(_webglrender);

        //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
        // this.camera = new THREE.PerspectiveCamera( VIEW_ANGLE, thecanvas.clientWidth/thecanvas.clientHeight, NEAR, FAR);
        // this.cameraChangedEvent = {type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: this.camera};
        //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
        avp.init_UnifiedCamera(THREE);
        this.camera = new av.UnifiedCamera(thecanvas ? thecanvas.clientWidth : 512, thecanvas ? thecanvas.clientHeight : 512);
        this.lightsOn = false;
        // we'll fill this in later, in initLights.
        this.lights = [];
        // pass in when lightsOn is false;
        this.no_lights = [];

        _defaultDirLightColor = new THREE.Color().setRGB(1,1,1);
        _defaultAmbientColor  = new THREE.Color().setRGB(1,1,1);

        // this.camera = this.unicam.getOrthographicCamera();
        this.cameraChangedEvent = this.camera.getCameraChangedEvent();

        _shadowLightDirDefault = new THREE.Vector3(1,1,1); // which does not match the _lightDirDefault
        _shadowLightDir        = new THREE.Vector3().copy(_shadowLightDirDefault);
        _lightDirDefault = new THREE.Vector3(-1,0,1);   // a horizontal light, which is not a good default shadowd direction

        //This scene will just hold the camera and lights, while
        //we keep groups of progressively rendered geometry in
        //separate geometry scenes.
        this.scene = new THREE.Scene();
        this.sceneAfter = new THREE.Scene();
        this.sceneAfter.sortObjects = false;

        this.renderAfters = new avp.RenderCallbacks();

        this.overlayScenes = {};

        this.selectionMaterial2d = null;

        this.selectionMaterialBase = new THREE.MeshPhongMaterial({specular:0x080808, ambient:0, opacity:1.0, transparent:false});
        this.selectionMaterialTop = new THREE.MeshPhongMaterial({specular:0x080808, ambient:0, opacity:0.15, transparent:true});
        this.selectionMaterialTop.packedNormals = true;
        this.selectionMaterialBase.packedNormals = true;
        createSelectionScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);

        // no override materials for the scene for selected point clouds, because it overwrites the point size setting.
        // instead we overwrite the material for the duplicated geometry in this.highlightFragment()
        this.createOverlayScene("selection_points", null, null);

        this.selectionMeshes = {};

        this.fadeMaterial = new THREE.MeshPhongMaterial({color:0xffffff, opacity:0.1, reflectivity: 0, transparent:true, depthWrite:false});
        this.fadeMaterial.packedNormals = true;
        _materials.addInstancingSupport(this.fadeMaterial);
        _materials.addMaterial("__fadeMaterial__", this.fadeMaterial, true);

        this.highlightMaterial = new THREE.MeshPhongMaterial({specular:0x080808, ambient:0, opacity:1.0, transparent:false});
        this.highlightMaterial.packedNormals = true;
        _materials.addInstancingSupport(this.highlightMaterial);
        _materials.addMaterial("__highlightMaterial__", this.highlightMaterial, true);
        this.setSelectionColor(0x6699ff);

        //Settings exposed to GUI:
        this.progressiveRender = true;
        this.swapBlackAndWhite = false;

        this.targetFrameBudget = TARGET_FRAME_TIME;

        // How many ticks pass in between updates. Make this half as many for mobile because the frame budget is doubled.
        // 1 means that we display every frame
        this.frameDisplayRate = 5;
        if (av.isMobileDevice()) {
            MAX_FRAME_BUDGET *= 2;          // Increase to match TARGET_FRAME_TIME
            MIN_FRAME_BUDGET /= 2;          // GPUs are slower on mobile, so allow the frame budget to be smaller
            TARGET_FRAME_TIME *= 2;         // GPUs are slower on mobile use a longer target frame time
            this.targetFrameBudget /= 2;    // Even though the target's doubled, start the budget smaller and have it work up to the target (ask Cleve)
            this.frameDisplayRate /= 2;     // since time per tick is doubled (in the long run), halve the number of ticks to give the same wall-clock delay interval
        }
        // How much time between checks on a full frame for any interrupt signal.
        this.interruptBudget = 1e10;

        this.controls = {
            update: function(timeStamp) {
                this.camera.lookAt( this.camera.target );
                this.camera.updateProjectionMatrix();
                this.camera.dirty = false;
            },
            handleResize: function() {},
            recordHomeView: function() {},
            uninitialize: function() {},
            isToolActivated: function() { return false; }
        };

        this.selector = new avp.MultiModelSelector(this);

        this.visibilityManager = new avp.MultiModelVisibilityManager(this);

        this.showGhosting = true;
        this.showOverlaysWhileMoving = true;
        this.skipAOWhenMoving = false;

        this.keyFrameAnimator = null;
        this.zoomBoundsChanged = true;

        var cc = avp.LightPresets[avp.DefaultLightPreset].bgColorGradient;
        this.setClearColors(cc[0], cc[1], cc[2], cc[3], cc[4], cc[5]);

        _groundShadow = new av.Shaders.GroundShadow(_webglrender);
        _groundShadow.enabled = true;

        _rcs = new RenderCommandSystem();

        // TODO_NOP: hack register materials for cutplanes
        _materials.addMaterialNonHDR("groundShadowDepthMaterial", _groundShadow.getDepthMaterial());
        _materials.addOverrideMaterial("normalsMaterial", _renderer.getDepthMaterial());
        _materials.addOverrideMaterial("edgeMaterial", _renderer.getEdgeMaterial());

        //just meant to do an initial clear to the background color we want.
        _renderer.beginScene(this.scene, this.camera, this.noLights, true);
        _renderer.composeFinalFrame(true, av.isIE11);

        this._loaderDelegate = {
            // Object loader can use to fire events and listen for events
            eventTarget: this.api,
            // Web worker object
            workerScript: avp.workerScript,
            // WebGLRenderer
            webGLRenderer: this.glrenderer(),
            // The material manager
            matman: this.matman(),
            // The render scene that will hold the loaded model
            renderScene: this.modelQueue(),
            // The model class
            model: av.Model,

            // Initialize message to a web worker
            initLoadContext: avp.initLoadContext,
            // Request that the application redraw the display.
            requestRedraw: function(needsClear) {
                _this.invalidate(needsClear, true);
            },
            // Report a network failure
            reportError: function(code, msg) {
                avp.logger.error(msg, av.errorCodeString(code));
            },
            // Signal progress of the load
            signalProgress: function(progress) {
                _this.signalProgress(progress, av.ProgressState.LOADING);
            },
            // Load the property data base
            loadPropertyDb: function(sharedDbPath, model) {
                var svf = model.getData();
                svf.propDbLoader = new WGS.PropDbLoader(sharedDbPath, model, model.loader.delegate);
                svf.propDbLoader.load();
            },
            // Load the textures for a model
            loadModelTextures: function(model) {
                WGS.TextureLoader.loadModelTextures(model.loader.delegate, model);
            },
            // Extra properties for loaders not converted to WGS
            viewer3DImpl: this,
        };

        this._loaderDelegate.eventTarget.addEventListener(WGS.FILE_LOAD_STARTED, function(event) {
            _this._addLoadingFile(event.loader);
        }, false);
        this._loaderDelegate.eventTarget.addEventListener(WGS.GEOMETRY_DOWNLOAD_COMPLETE, function(event) {
            if (event.memoryLimited)
                _this.onDemandLoadComplete(event.model);
            else
                _this.onLoadComplete(event.model);
        }, false);

        // Enable and disable feature based on whether we are memory limited.
        _memoryLimit = function() {
            // Are there any memory limited models in the scene.
            var memoryLimited = !!_modelQueue.getMemoryInfo();
            // Disable/enable features based on result.
            _materials.toggleDepthWriteTransparent(!memoryLimited);
            _renderer.setMemoryLimited(memoryLimited);
            if (memoryLimited) {
                this.toggleGroundReflection(false);
                this.toggleGroundShadow(false);
            }
        }.bind(this);
        this.api.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, _memoryLimit);
        this.api.addEventListener(av.MODEL_UNLOADED_EVENT, _memoryLimit);
    };

    function createRenderer(canvas) {

        if (!canvas)
            return null;

        //TODO: improve the pixel scale heuristics below
        var dpr = window.devicePixelRatio;
        if (!dpr) dpr = 1;

        //High density display -- turn off antialiasing since
        //it's not worth the slowdown in that case.
        //if (dpr >= 2.0)
        //    _settings.antialias = false;

        //Expose the pramaters to outside so that we could set these params on HTML.
        var params = av.InitParametersSetting;
        params.canvas=canvas;
        params.devicePixelRatio=dpr;

        var renderer = new avp.FireflyWebGLRenderer(params);

        if (!renderer.context)
            return null;

        renderer.autoClear = false;

        //Turn off scene sorting by THREE -- this is ok if we
        //do progressive draw in an order that makes sense
        //transparency-wise. If we start drawing using a frustum culling
        //r-tree or there are problems with transparency we'd have to turn on sorting.
        renderer.sortObjects = false;

        return renderer;
    }

    //Bridge between the render queue and render context
    //For passing pieces of model to the renderer during
    //timed progressive rendering, while also taking into account
    //the current rendering mode of the viewer
    function renderSomeCallback(scene) {

        //Ideally, here we only want the piece of the
        //render function that specifically renders geometries,
        //and none of the camera update stuff that we already do
        //once in beginProgressive() -- but this requires
        //some refactoring of THREE.WebGLRenderer.
        var phase = _rcs.phase;
        var wantColor = true;
        var wantSAO = phase == avp.RENDER_NORMAL;
        var wantID = (_renderer.settings.idbuffer || _renderer.settings.occlusionid) && phase != avp.RENDER_HIDDEN;

        // Need to handle occlusion ids. If we need occlusionids, then don't include transparent objects
        if (wantID && _renderer.settings.occlusionid &&
            scene instanceof avp.RenderBatch && scene.sortObjects) {
            wantID = false;
        }

        if (phase == avp.RENDER_HIDDEN)
            scene.overrideMaterial = _this.fadeMaterial;
        else if (phase == avp.RENDER_HIGHLIGHTED)
            scene.overrideMaterial = _this.highlightMaterial;

        _renderer.renderScenePart(scene, wantColor, wantSAO, wantID);

        scene.overrideMaterial = null;

    }

    function updateFPS(highResTimeStamp) {
        _frameTimeSamples++;

        if ( (_lastHighResTimeStamp <= highResTimeStamp) && (_lastHighResTimeStamp > 0) ) {
            _frameTimeAvg = _frameTimeAvg * 0.8 + (highResTimeStamp - _lastHighResTimeStamp) * 0.2;
        }

        if (_this.fpsCallback)
            _this.fpsCallback(_this.fps());
    }

    function updateAnimations(highResTimeStamp) {
        if (_this.keyFrameAnimator) {
            var delta = _lastHighResTimeStamp > 0 ? (highResTimeStamp - _lastHighResTimeStamp) / 1000 : 0;
            var updateFlags = _this.keyFrameAnimator.update(delta);
            if (updateFlags) {
                _this.sceneUpdated(true);
                if (updateFlags & _this.keyFrameAnimator.UPDATE_CAMERA)
                    return true;
            }
        }
        return false;
    }

    function updateCanvasSize() {
        if (_needsResize) {
            _this.camera.aspect = _newWidth/_newHeight;
            _this.camera.clientWidth = _newWidth;
            _this.camera.clientHeight = _newHeight;
            _renderer.setSize(_newWidth,_newHeight);
            _this.controls.handleResize();
            if (_groundReflection)
                _groundReflection.setSize(_newWidth, _newHeight);
            _this.invalidate(true, true, true);
            _needsResize = false;
            _this.api.dispatchEvent({
                type: av.VIEWER_RESIZE_EVENT,
                width: _newWidth,
                height: _newHeight
            });
        }
    }

    this.renderGroundShadow = function(target) {

        // If shadow maps are active, we don't use _groundShadow for the ground. Instead, the ground is
        // rendered using the shadow map as well.
        if (_shadowMaps) {
            if (_shadowMaps.state == avp.SHADOWMAP_VALID) {
                _shadowMaps.renderGroundShadow(_this.camera, target || _renderer.getColorTarget());
            }
        } else {
            _groundShadow.renderShadow(_this.camera, target || _renderer.getColorTarget());
            _groundShadow.rendered = true;
        }
    };

    // Set any information needed for the ground plane reflection, drop shadow, or shadow map projection
    function updateGroundTransform() {
        // if we're not using the ground shadow or reflection, or it's a 2D drawing, return
        if (!_groundShadow.enabled && !_groundReflection || _this.is2d)
            return;

        // Get the box of all the scene's data
        var groundBox;
        if (_this.model && !_this.model.isLoadDone()) {
            groundBox = _this.model.getData().bbox;
        }
        else {
            groundBox = _this.getVisibleBounds(true, false);
        }
        // If there's nothing to see, return
        if (!groundBox)
            return;

        var camera = _this.camera;
        var bbox = groundBox.clone();

        var rightAxis = new THREE.Vector3(1, 0, 0);

        var shadowDir = _shadowLightDir.clone();

        // Transform bbox, rightAxis, and shadowDir using worldUpTransform. For the resulting box, we
        // can safely assume that y is the up-direction
        if (camera.worldUpTransform) {
            bbox.applyMatrix4(camera.worldUpTransform);
            rightAxis.applyMatrix4(camera.worldUpTransform);
            shadowDir.applyMatrix4(camera.worldUpTransform);
        }

        // expand the box downwards by 0.5%. The effect of this is just that the
        // ground plane does not touch the world box, but is slightly below it
        bbox.min.y -= 0.005 * (bbox.max.y - bbox.min.y);

        if (_shadowMaps) {
            _shadowMaps.expandByGroundShadow(bbox, shadowDir);
        }

        // get size and center
        var bsize   = bbox.size();
        var bcenter = bbox.center();

        // apply some adjustments specific for drop-shadow
        if (!_shadowMaps) {
            // add some horizontal margin so that blurring is not clipped at the boundaries
            bsize.x *= 1.25;
            bsize.z *= 1.25;

            // expand to square, because the texture is squared as well
            bsize.x = bsize.z = Math.max(bsize.x, bsize.z);
        }

        // Rotate center back to world-coords.
        if (camera.worldUpTransform) {
            var worldUpInverse = new THREE.Matrix4().getInverse(camera.worldUpTransform);
            bcenter.applyMatrix4(worldUpInverse);

            // Note that we leave size vector as it is. I.e., only the center is transformed back to world-coords.
            // The size vector keeps as it is, i.e. the bbox defined by (center, size) is still aligned with
            // the rotated axes. In other worlds
            //  - size.x is the extent along worldUpTransform * (1,0,0) = rightAxis
            //  - size.y is the extent along worldUpTransform * (0,1,0) = camera.worldUp
            //  - size.z is the extent along worldUpTransform * (0,0,1)
        }

        _groundShadow.setTransform(
            bcenter,
            bsize,
            camera.worldup,
            rightAxis
        );

        if (_groundReflection) {
            var groundPos = (new THREE.Vector3()).subVectors(bcenter, camera.worldup.clone().multiplyScalar(bsize.y/2));
            _groundReflection.setTransform(groundPos, camera.worldup, bsize);
        }

        if (_shadowMaps) {
            _shadowMaps.setGroundShadowTransform(bcenter, bsize, camera.worldup, rightAxis);
        }
    }

    function updateScene() {
        if (_sceneDirty) {
            // If the model had changed, the ground-plane, etc., may have changed, so recompute
            updateGroundTransform();
            _groundShadow.setDirty();
            _sceneDirty = false;
            return true;
        } else {
            return false;
        }
    }

    function updateOverlays(highResTimeStamp) {

        //Update the selection set cloned meshes
        for (var id in _this.selectionMeshes) {

            var m = _this.selectionMeshes[id];
            if (m.model) {
                var fragList = m.model.getFragmentList();

                // If the proxy uses original geometry of the fragment, update its matrix.
                // If the geometry does not match, it is a consolidated or instanced mesh.
                // For these, the matrix is already baked into vertex buffer or
                // index buffer. We don't support animation for these.
                if (m.geometry === fragList.getGeometry(m.fragId)) {
                    fragList.getWorldMatrix(m.fragId, m.matrix);
                }
            }
        }

    }

    function invalidateShadowMap() {
        if (_shadowMaps) {
            _shadowMaps.state = avp.SHADOWMAP_NEEDS_UPDATE;
        }
    }

    // The render command system is what actually does the render. The idea here is that each tick() checks if anything causes a new
    // render. If so, then we make a new list of commands to perform, then start performing them. For a full render without interruptions,
    // this is overkill - we could just lockstep execute them all. Where the command list comes into its own is that it can be continued.
    // For progressive rendering we want 
    // Rather than pepper the rendering sequence of the code with lots of "if" statements that
    function RenderCommandSystem() {
        this.highResTimeStamp = -1;
        // did something get rendered that would change the screen (almost always true when rendering occurs)?
        this.screenDrawn = false;
        // did a Present get done?
        this.screenHasChanged = false;
        // how much time we are given to render things during each execution, in ms.
        this.frameBudget = 0;
        // how much time we have left to render stuff during this tick(), in ms.
        this.frameRemaining = 0;
        // what type of render is happening currently
        this.phase = avp.RENDER_NORMAL;
        // show the amount of the scene rendered. TODO this doesn't really work right with ghosting or shadow mapping on, as those also affect it.
        this.signalProgressByRendering = false;

        // How many ticks have executed the current command list. Good for knowing if we're on the first frame (tick 0).
        this.tickCount = 0;
        // average time spent rendering a tick() TODO - needs to be revisited and thought through: if a batch is not loaded, it displays really fast!
        this.beginFrameAvg = 0;
        // exactly what it says, the time stamp passed in on the previous tick().
        this.lastBeginFrameTimeStamp = 0;

        // various types of rendering
        this.RENDERMODE_FULL = 0;
        this.RENDERMODE_PROGRESSIVE = 1;
        this.RENDERMODE_SILENT = 2;
        // type of rendering being done.
        this.renderType = this.RENDERMODE_FULL;

        // First frame budget
        // If it's progressive and the first frame, try to finish the ground shadow in the allocated time
        this.INITIAL_GROUND_SHADOW = 0.2;

        // Internal command iterator state
        // is there a command list to execute?
        this.cmdListActive = false;
        // what command we are executing
        this.cmdIndex = 0;
        // was execution terminated for this tick()?
        this.continueExecution = true;
        // are there "CMD_ALWAYS_DO" commands in the command list? If so, we need to traverse the whole command list each tick.
        this.encounteredAlwaysDo = false;
        // did the full render finish? If not, then ignore overlay and present updates until it has
        this.finishedFullRender = true;
        // did the ground shadow get computed in the post-process for deferred rendering?
        this.groundShadowInPost = false;
        // did any previous or current frame trigger the overlay to be drawn?
        this.drawOverlay = false;
        
        // true means parameters can be set on the command
        this.cmdIsOpen = false;

        // how long the array is (so that if new commands/params are needed, they get allocated first).
        this.allocArraySize = 0;
        // how many commands are in the active command list
        this.cmdListLength = 0;
        // the command and parameters set for the command
        this.cmdList = [];
        this.paramList = [];

        // command states
        this.CMD_NORMAL_SEQUENCE = 0;
        this.CMD_DO_AFTER = 1;
        this.CMD_ALWAYS_DO = 2;

        this.isActive = function () {
            return this.cmdListActive;
        };

        this.setFrame = function (timeBudget) {
            this.frameBudget = timeBudget;
        };

        // signal the beginning of a new set of commands
        this.beginCommandSet = function () {
            this.cmdListActive = true;
            this.cmdIndex = 0;
            this.cmdListLength = 0;
            this.encounteredAlwaysDo = false;
            this.tickCount = 0;
            this.screenDrawn = false;
            this.screenHasChanged = false;
        };

        // signal the end
        this.endCommandSet = function () {
            if ( this.cmdIsOpen ) {
                this.cmdIsOpen = false;
                // close previous command - really, increment just to get the final count
               this.cmdListLength++;
            }
        };

        // Set the parameter on the currently-executed parameter. Meant for the commands above.
        this._internalSetParam = function (indexString, val) {
            this.paramList[this.cmdIndex][indexString] = val;
        };


        this.addCommand = function (func, executionLevel) {
            if ( this.cmdIsOpen ) {
                // close previous command
                this.cmdListLength++;
            }
            this.cmdIsOpen = true;
            while ( this.allocArraySize <= this.cmdListLength ) {
                this.cmdList[this.cmdListLength] = {};
                this.paramList[this.cmdListLength] = {};
                this.allocArraySize++;
            }
            this.cmdList[this.cmdListLength] = func;
            this.paramList[this.cmdListLength].executionLevel = executionLevel || this.CMD_NORMAL_SEQUENCE;
            this.encounteredAlwaysDo = this.encounteredAlwaysDo || ( executionLevel === this.CMD_ALWAYS_DO );

            // return value so if we want to jump to this command, we know where to go.
            return this.cmdListLength;
        };

        // note that we're a bit sloppy with parameter setting. Since the parameter set at an index location
        // gets reused, you may see parameters in the parameter object that have nothing to do with this
        // command, since this parameter set might have been used for another command at some other time.
        // Basically, if a command doesn't use the parameter, then ignore it.
        this.setParam = function (indexString, val) {
            if ( this.cmdIsOpen ) {
                this.paramList[this.cmdListLength][indexString] = val;
            } else {
                if ( ENABLE_DEBUG ) {
                    avp.logger.error( "ERROR: cannot set param when no command is open!");
                }
            }
        };

        // This method is meant for use during execution of a command, so gets the parameter from the currently-active command.
        this.getParam = function (indexString) {
            if (ENABLE_DEBUG) {
                if ( this.paramList[this.cmdIndex][indexString] === undefined ) {
                    avp.logger.error( "ERROR: parameter " + indexString + " was never set for this command! Go fix it.");
                }
            }
            return this.paramList[this.cmdIndex][indexString];
        };

        // return true if done running all commands.
        this.executeCommandList = function() {
            if ( _rcs.cmdListActive ) {
                // go through command list, interrupting as needed.

                // set frame budget
                this.frameRemaining = this.frameBudget;

                if ( ENABLE_DEBUG ) {
                    // reality check
                    if ( this.cmdIsOpen ) {
                        avp.logger.error( "ERROR: should call endCommandSet before executing");
                    }
                }
                this.continueExecution = true;
                var restartIdx;
                // not at end of command list? We always go through the whole command list, as there may be "always do"
                // commands, such as a Present().
if (ENABLE_DEBUG) {
    if ( this.tickCount === 0 ) { console.log("==================="); }
    console.log("Running commands for " + ((_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE)? "progressive" :
        ( (_rcs.renderType === _rcs.RENDERMODE_FULL) ? "full" : "silent") ) +
        " render, for tick count " + this.tickCount);
}

                // Are there any "always do" commands in this command set, that must be done before we continue our command sequence?
                // Currently needed by smooth navigation, to turn off AO during the render sequence.
                if ( this.encounteredAlwaysDo ) {
                    var idx = 0;
                    while ( idx < this.cmdIndex ) {
                        // Is this a command we should always do?
                        if ( this.paramList[idx].executionLevel >= _rcs.CMD_ALWAYS_DO ) {
                            // Commands we always do are assumed to never abort, so we don't check for failure.
if (ENABLE_DEBUG) { console.log("  ALWAYS DO command " + idx + ": " + this.cmdList[idx].name ); }
                            this.cmdList[idx]();
                        }
                        idx++;
                    }
                }
                    
                while ( this.cmdIndex < this.cmdListLength ) {
                    // if we are to continue execution, easy;
                    // if not, then check if the next command is an "always do after", such as a Present().
                    if ( this.continueExecution ||
                        ( this.paramList[this.cmdIndex].executionLevel >= _rcs.CMD_DO_AFTER ) ) {
                        // we're supposed to execute this command, so do it and see what it says
if (ENABLE_DEBUG) { console.log("  command " + this.cmdIndex + ": " + this.cmdList[this.cmdIndex].name + " and " + _rcs.frameRemaining + " frame budget remaining" ); }

                        if ( this.cmdList[this.cmdIndex]() ) {
                            // true means stop executing, out of time (typically),
                            // so restart execution at this command the next tick()
if (ENABLE_DEBUG) { console.log("  >>> out of tick time with " + _rcs.frameRemaining); }
                            restartIdx = this.cmdIndex;
                            // signal to not execute any "normal sequence" commands for the rest of the command list.
                            this.continueExecution = false;
                        }
                    }
                    // Go to next command until we hit the end of the list;
                    // we always continue, since there could be "always do" or "do after"
                    // commands in the list that need to be executed.
                    this.cmdIndex++;
                }

                // out of time or aborted for some other reason? We'll be back later...
                if ( this.continueExecution ) {
                    // did all commands, so we're done
                    this.cmdListActive = false;
                } else {
                    // set where to continue the work next tick()
                    this.cmdIndex = restartIdx;
                }
                this.tickCount++;

                return !this.continueExecution;
            } else {
                // not active, so "done"
                return true;
            }
        };
    }

    // Here's the system:
    // If ground shadow is done - well, that's easy, just blit it before beauty pass
    // If not done
    // 	If we are doing a full render
    //     Render the whole shadow first (possibly tick limited), blit it to screen, then continue to beauty pass
    //     Else we are doing progressive
    //        if this is the first frame:
    //           if the number of objects in the scene is low (10?),
    //              render the drop shadow, figuring we can rendering the rest of the scene in a single frame
    //           else
    //              don't bother rendering anything in later ticks (we used to waste time rendering a few each tick)	
    //        if this is a later frame:
    // 			 render just the beauty pass, until done. Don't bother with the shadow now, as it won't get used.
    //        When we get to the end of progressive:
    //           If needed, render the ground shadow until done. Once done, signal that a re-render is needed.
    // TODO - currently the on-demand loading system always does an ID map creation during rendering; it would be good to defer
    // this on non-MRT GPUs, i.e., do it after all normal rendering is done.
    function cmdGenerateGroundShadow() {
        // three cases: full render, quick out for progressive, continue as possible for progressive.
        if ((_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE)) {
            if ( _rcs.getParam("GenerateGroundShadow.afterBeauty") ) {
                // Rendering the ground shadow after all progressive rendering is done. Signal redraw if it finishes.
                _rcs.frameRemaining = _groundShadow.prepareGroundShadow(_this.modelQueue(), 0, _rcs.frameRemaining);
                // was this the call that rendered it fully?
                if ( _groundShadow.getStatus() == avp.GROUND_RENDERED ) {
                    // Do we need to rerender? This needs to happen if we're not using reflection insertion.
                    // TODO: someday perhaps make ground shadows more "full featured" and merge behind, like ground reflections do?
                    if ( _rcs.getParam("GenerateGroundShadow.signalRedraw") ) {
                        _this.requestSilentRender();
                        if (ENABLE_DEBUG ) {
                            console.log(" $$$$ SIGNAL FULL GROUND SHADOW REDRAW");
                        }
                        // don't need to continue, since we know we need to fully redraw on next tick
                        return true; // TODO could signal abort rest of command stream, since we know we invalidate. It's just a bit inefficient otherwise.
                    }
                    // note for ground reflection, so it can decide on deferred silent rendering.
                    _rcs.groundShadowInPost = true;
                }
            } else {
                // If this is the first frame, try to render the drop shadow in a small amount of time.
                // Else, don't waste time on the drop shadow.
                if ( _rcs.tickCount === 0 ) {
                    // render 10 objects TODO - expose 10 as some other number?
                    //_rcs.frameRemaining = 
                    _groundShadow.prepareGroundShadow(_this.modelQueue(), 10);
                    // TODO or this way, which does possibly give flicker:
                    //_rcs.frameRemaining = _groundShadow.prepareGroundShadow(_this.modelQueue(), _rcs.frameRemaining, _rcs.INITIAL_GROUND_SHADOW);
                    //var minRemaining = _rcs.frameBudget * (1-_rcs.INITIAL_GROUND_SHADOW);
                    //if ( _rcs.frameRemaining < minRemaining ) {
                    //     _rcs.frameRemaining = minRemaining;
                    //}
                }
            }
        } else {
            // full render, just do it fully.
            _rcs.frameRemaining = _groundShadow.prepareGroundShadow(_this.modelQueue(), 0, _rcs.frameRemaining);
        }

        // rendering can continue if there's time left
        return (_rcs.frameRemaining < 0) && ( _groundShadow.getStatus() === avp.GROUND_UNFINISHED );
    }

    function cmdBlitGroundShadow() {
        //Render the ground shadow after screen clear
        if ( _groundShadow.getStatus() !== avp.GROUND_UNFINISHED )
            _this.renderGroundShadow();
        return false;
    }

    function cmdGenerateGroundReflection() {
        // three cases: full render, quick out for progressive, continue as possible for progressive.
        if ((_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE)) {
            // is this pass happening after the beauty pass is completed?
            if ( _rcs.getParam("GenerateGroundReflection.afterBeauty") ) {
                // Rendering the ground reflection after all progressive rendering is done.
                _rcs.frameRemaining = _groundReflection.prepareGroundReflection(_groundShadow, _this, false, 0, _rcs.frameRemaining);
                // was this the call that rendered it fully?
                if ( _groundReflection.getStatus() == avp.GROUND_RENDERED ) {
                    _rcs.screenDrawn = true;
                    // If we're done, we should also check to see if a silent render is needed for ground shadows.
                    // If ground shadows were finished in these post-render passes (rare - only on animation or explode,
                    // for complex scenes), transparent objects in the scene will not show the shadows properly through
                    // their transparent objects, LMV-2508.
                    // TODO - nicer still would be to see if the scene actually has any transparent objects. If not,
                    // then we don't need this separate re-render.
                    // TODO Also, note this isn't a perfect system: in practice you really want to have the ground reflection
                    // entirely done before rendering atop it, so that what is seen through transparent objects is fully
                    // folded in. However, this problem is much less obvious in the scenes tested - missing ground shadows
                    // are more obvious.
                    if (_rcs.groundShadowInPost && _materials.hasTransparentMaterial()) {
                        _this.requestDeferredSilentRender();
                    }
                }
            } else {
                // If this is the first frame, try to render the reflection in a small amount of time.
                // Else, don't waste time on the reflection.
                if ( _rcs.tickCount === 0 ) {
                    // render 10 objects TODO - expose 10 as some other number? Or use a budget? Or...?
                    //_rcs.frameRemaining =
                    _groundReflection.prepareGroundReflection(_groundShadow, _this, true, 10);
                    // TODO or this way, which does possibly give flicker:
                    //_rcs.frameRemaining = _groundReflection.prepareGroundReflection(_this.modelQueue(), _rcs.frameRemaining, _rcs.INITIAL_GROUND_SHADOW);
                    //var minRemaining = _rcs.frameBudget * (1-_rcs.INITIAL_GROUND_SHADOW);
                    //if ( _rcs.frameRemaining < minRemaining ) {
                    //     _rcs.frameRemaining = minRemaining;
                    //}
                }
            }
        } else {
            // full render, just do it fully.
            _rcs.frameRemaining = _groundReflection.prepareGroundReflection(_groundShadow, _this, false, 0, _rcs.frameRemaining);
        }

        // rendering can continue if there's time left, or if we actually finished display and should present, even though we're out of time.
        // TODO we could revise commands to be of "takes time" and "doesn't take time", so that we abort if and only if we're out of time
        // and hit a "takes time" command.
        return (_rcs.frameRemaining < 0) && ( _groundReflection.getStatus() === avp.GROUND_UNFINISHED );
    }

    /**
     * Progressive update of the shadow map:
     *
     *   a) For small models that can be rendered within a single frame, the shadow map will always be rendered first,
     *      so that shadows will not flicker on and off during animations, on scene changes, or when changing the light direction.
     *   b) For large models, seeing something is more important than shadows. Therefore, we render without shadows
     *      first and only do work on the shadow map if everything else is finished.
     *
     *  Whether we take a) or b) is determined on-the-fly: We use a) if we succeed updating the whole ShadowMap
     *  within a single frame time budget.
     */
    function cmdUpdateShadowMap() {

        // We are either starting an update of the shadow map, or are continuing to render it in this tick.

        // This section is always entered in the first frame if the shadow map is not available yet.
        if (_shadowMaps.state===avp.SHADOWMAP_NEEDS_UPDATE) {

            // start shadow map update. This call may end in two ways:
            //  - In case a), the shadowmap could already be finished within the startUpdate() call. Therefore, the
            //    shadow map will already be available and will be used in this frame.
            //    In this case, there is nothing more to do and all subsequent calls to updateShadowMap will
            //    do nothing.
            //  - in case b), the shadow map is not available. In this case, we first wait until the rendering
            //    without shadows is finished. (see next section)
            _rcs.frameRemaining = _shadowMaps.startUpdate(_modelQueue, _rcs.frameRemaining, _this.camera, _shadowLightDir, _materials);

        } else if (_shadowMaps.state==avp.SHADOWMAP_INCOMPLETE) {

            // continue shadow map update as long as we have time
            _rcs.frameRemaining = _shadowMaps.continueUpdate(_modelQueue, _rcs.frameRemaining, _materials);

            // if we're done and this is a progressive render, then this shadow generation is happening at the end.
            // In such a case we need to re-render (similar to ground shadows and reflections).
            if (_shadowMaps.state == avp.SHADOWMAP_VALID) {

                // TODO - may wish to make this a deferred silent render, so that reflection etc. is completed, then shadows come in later.
                _this.requestSilentRender();
                if (ENABLE_DEBUG ) {
                    console.log(" $$$$ SIGNAL FULL SHADOW MAP REDRAW");
                }
                // don't need to continue, since we know we need to fully redraw on next tick
                return true; // TODO could signal abort rest of command stream, since we know we invalidate. It's just a bit inefficient otherwise.
            }
        }
        return (_rcs.frameRemaining < 0.0) && (_shadowMaps.state !== avp.SHADOWMAP_VALID);
    }

    function cmdResetShadowMap() {
        _shadowMaps.state = avp.SHADOWMAP_NEEDS_UPDATE;
    }

    function cmdBeginScene() {
        if (_rcs.signalProgressByRendering)
            _this.signalProgress(0, av.ProgressState.RENDERING); //zero out the progress bar for when rendering begins

        if ((_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE)) {
            //Measure actual frame time between two consecutive initial frames.
            //This is used to correct measured per-scene times to what they actually take
            //once the async processing of the graphics thread is taken into account.
            if (_rcs.lastBeginFrameTimeStamp > 0) {
                var delta = _rcs.highResTimeStamp - _rcs.lastBeginFrameTimeStamp;
                _rcs.beginFrameAvg = 0.75 * _rcs.beginFrameAvg + 0.25 * delta;
            }
            _rcs.lastBeginFrameTimeStamp = _rcs.highResTimeStamp;

            //Adjust frame time allowance based on actual frame rate,
            //but stay within the given boundaries.
            if (_rcs.beginFrameAvg < TARGET_FRAME_TIME && _rcs.frameBudget < MAX_FRAME_BUDGET) {
                _this.targetFrameBudget += 1;
                if ( _this.targetFrameBudget > MAX_FRAME_BUDGET ) {
                    _this.targetFrameBudget = MAX_FRAME_BUDGET;
                }
            }
            else if (_rcs.beginFrameAvg > TARGET_FRAME_TIME && _rcs.frameBudget > MIN_FRAME_BUDGET) {
                _this.targetFrameBudget -= 1;
                if ( _this.targetFrameBudget < MIN_FRAME_BUDGET ) {
                    _this.targetFrameBudget = MIN_FRAME_BUDGET;
                }
            }
        }

        _this.updateCameraMatrices();

        // clear the color and depth targets
        var clear = _rcs.getParam("BeginScene.clear");
        _renderer.beginScene(_this.scene, _this.camera, _this.lightsOn ? _this.lights : _this.no_lights, clear);

        _rcs.screenDrawn = _rcs.screenDrawn || clear;

        // Check if the camera changed, and if so, signal.
        if ( _rcs.getParam("BeginScene.signalCameraChanged") ) {
            // Tells view cube to update, for example.
            _this.api.dispatchEvent(_this.cameraChangedEvent);     
        }

        return false;
    }

    function cmdBeginPhase() {
        // If nothing is highlighted just skip the highlighted phase
        _rcs.phase = _rcs.getParam("BeginPhase.phase");
        if ( ENABLE_DEBUG ) {
            console.log( "     render phase is now " + _rcs.phase);
        }

        // Start rendering the scene by resetting the rendering queue.
        // This sets up the view frustum intersector and begins scene iteration.
        _modelQueue.reset(_this.camera, _rcs.phase, _rcs.getParam("BeginPhase.moved"));

        return false;
    }

    function cmdMainRender() {
        if (!_modelQueue.isEmpty() && !_modelQueue.isDone()) {

            _rcs.screenDrawn = true;

            //Render some geometry with the current render mode (highlighted, normal, or ghosted)
            _rcs.frameRemaining = _modelQueue.renderSome(renderSomeCallback, _rcs.frameRemaining, _pagingOptions);

            // TODO - cmdMainRender gets used by a number of systems - what sort of progress should really happen here?
            if (_rcs.signalProgressByRendering) {
                _this.signalProgress(100.0 * _modelQueue.getRenderProgress(), av.ProgressState.RENDERING);
                if ( ENABLE_DEBUG ) {
                    console.log( "  %%% percent done " + (100 * _modelQueue.getRenderProgress()));
                }
            }
        }
        // if there is time left, continue on (return false), else return true, which means "stop for now"
        return !_modelQueue.isDone();
    }

    // render sectioning, if any, and any additional buffers needed, such as ID.
    function cmdScenePartRender() {
        _rcs.phase = avp.RENDER_FINISHED;
        _renderer.renderScenePart(_this.sceneAfter, true, true, true);

        _this.renderAfters.render();

        // TODO: bad, renderScenePart does not return the amount of time used to render. It should, so we know the remaining budget.
        // TODO: to be honest, we should actually do a performance.now() at the beginning of any command list set, and
        // use *that* to track the time truly remaining. highResTimeStamp that is passed in is not trustworthy. But there's also the
        // "average batch time" that gets set, to minimize flicker. A creaky system that works, mostly.
        return false;
    }

    function cmdFinishAllRendering() {
        // in case some system is querying the phase
        _rcs.phase = avp.RENDER_FINISHED;

        return false;
    }

    function cmdSignalProcessingDone() {
        //if (_rcs.signalProgressByRendering)
        _this.signalProgress(100.0, av.ProgressState.RENDERING);
    }

    function cmdRenderOverlays() {
        // Render selection highlight / pivot / HUD overlays and other overlay geometry
        // This is stuff that goes into the separate overlay render buffer. It does rely on the z-buffer being properly populated,
        // so is normally rendered after the beauty pass (or highlighting pass) is performed. As such, we need to rerender it on
        // every progressive pass.

        // If there was an overlay dirty (i.e., someone hovered over something in the middle of a progressive render), note that the
        // overlay must now be drawn from here on out.
        if ( _this.isOverlayDirty() ) {
            // avoid having successive passes 
            _this.clearOverlayDirtyFlag();
            _rcs.drawOverlay = true;
        }

        // draw if needed
        if ( _rcs.drawOverlay ) {

            // If there is geometry, and we're done rendering it, OR we need to always render the overlay while moving, make the overlay
            if ((!_modelQueue.isEmpty() && _modelQueue.isDone()) || _this.showOverlaysWhileMoving) {
                _this.renderOverlays();
                _rcs.screenDrawn = true;
            } else {
                // overlay update not needed (no geometry, or to be done only at end): clear once, and turn off drawing it since we need to clear only once.
                _renderer.clearAllOverlays();
                _rcs.drawOverlay = false;
            }
        }

        return false;
    }

    // if we're fading in the rollover highlight, we just need to compose the final frame.
    // This command forces PostAndPresent to happen.
    function cmdForcePresent() {
        _rcs.screenDrawn = true;
    }

    function cmdPostAndPresent() {
        //Run post-processing and present to the front buffer
        if ( _rcs.screenDrawn &&
            // present if we're done rendering, or if progressive and this is a displayable frame
            (_rcs.phase === avp.RENDER_FINISHED || ((_rcs.tickCount % _this.frameDisplayRate) === 0))) {
            // present image
            _renderer.composeFinalFrame(!_rcs.getParam("PostAndPresent.performAO"));
            _rcs.screenHasChanged = true;
            // reset
            _rcs.screenDrawn = false;

            updateFPS(_rcs.highResTimeStamp);

            _this.api.dispatchEvent({type: av.RENDER_PRESENTED_EVENT});
        }

        return false;    // TODO - could actually measure time at this point
    }

    // Smooth navigation overrides
    // TODO - I don't really like toggle SAO off and on during a single tick, it is a little
    // costly (how much?), but it's the safest option.
    function cmdSuppressAO() {
        if ( ENABLE_DEBUG ) {
            if ( _renderer.getAOEnabled() === false ) {
                // AO should be on and we should be suppressing it.
                avp.logger.error("AO should be on at this point!");
            }
        }
        _renderer.setAOEnabled(false);
        return false;
    }
    function cmdRestoreAO() {
        if ( ENABLE_DEBUG ) {
            if ( _renderer.getAOEnabled() === true ) {
                // AO should be off and we should be restoring it.
                avp.logger.error("AO should be off at this point!");
            }
        }
        _renderer.setAOEnabled(true);
        return false;
    }
    function cmdSignalRedraw() {
        _this.requestSilentRender();
        return false;
    }
    function cmdFinishedFullRender() {
        _rcs.finishedFullRender = true;
        return false;
    }

    //Main animation loop -- update camera,
    //advance animations, render if needed.
    function tick(highResTimeStamp)
    {
        // tick() does three main operations:
        // 1. Determine if anything has changed that would trigger a new render.
        // 2. If a new render of any sort is needed, set the command system to do it.
        // 3. Check if there is a command set to run, and if so, run it.

        // TODO We have a high-res time stamp from performance.now(), but, interestingly enough,
        // it comes in about 100 ticks later than whatever number we get when we call
        // performance.now() right here. TODO - how's that work? Why this mis-sync?

        _rcs.highResTimeStamp = highResTimeStamp = highResTimeStamp || 0;   // TODO sometimes highResTimeStamp is zero. What?

        ///////////////////////////////////////////////
        // Determine if anything has changed that would cause a new render to be performed

        // Texture uploads of newly received textures;
        // Any texture change causes a full redraw.
        var res = _materials.updateMaterials();
        _this.invalidate(res.needsClear, res.needsRender, res.overlayDirty);

        // Perform animations, return true if something animated -- this has to be done
        // before the scene update below
        var animationMoved = updateAnimations(highResTimeStamp);

        // update controls (e.g. view cube, home button, orbit, key press) and see if that has affected the view
        var controlsMoved = _this.controls.update(highResTimeStamp);

        // see if more data was loaded.
        var sceneChanged = _modelQueue && _modelQueue.update(highResTimeStamp);

        var moved = controlsMoved || animationMoved || _cameraUpdated || sceneChanged;
        _pagingOptions.moved = moved;
        // reset and record state of this frame
        _cameraUpdated = false;
        // Did the window resize since last tick?
        var canvasSizeUpdated = _needsResize;
        // checks _needsResize to see if an update is needed.
        updateCanvasSize();

        _needsClear = _needsClear || moved;
        _overlayDirty = _overlayDirty || moved;
        //var needsPresent = false;

        var rollover = false;
        if (_overlayDirty) {
            // Update the selection set cloned meshes (does no rendering, yet)
            updateOverlays(highResTimeStamp);
        } else {
            // If the overlay is not dirty, fade in the overlay update over time (rollover highlighting becomes stronger).
            // If the value changes, the _blendPass needs to be redone - the overlay itself did not change, so
            // does not need to be rerendered.
            if ( _renderer.overlayUpdate() && !_overlayDirty ) {
                // special case where all that is needed is the rollover hightlight blend pass
                _overlayDirty = rollover = true;
            }
            //needsPresent = _renderer.overlayUpdate();
        }

        // TODO - what is this? By adding on demand loading geometry, the progress of rendering now
        // will proceed back and forth a few times.
        _rcs.signalProgressByRendering = _this.model && (_this.model.isLoadDone() ||
            (_this.model.getData().partPacksLoadDone === true));

        // Has the geometry changed since the last frame?
        // Note this is not the same as just the camera moving, it indicates
        // that meshes have changed position, e.g., during explode, animation, etc.
        // The main effect is that the ground plane and shadow bounds may have changed, so adjust their location and bounds.
        if (updateScene()) {
            // if the scene was indeed dirty, we'll need to render from the start
            _needsClear = true;
        }

        // If _needsClear is false at this point, nothing changed from outside. However, we might still
        // have to set _needsClear to true if the previous frame cannot be resumed. This happens when
        // when we rendered some transparent shapes before all opaque ones were rendered.
        var somethingChanged = _needsClear;
        var lastFrameValid = _modelQueue.frameResumePossible();
        _needsClear = _needsClear || !lastFrameValid;

        ///////////////////////////////////////////////
        // If a new render of any sort is needed, set the command system to do it.
        //
        // Store parameters that should not change on successive ticks, but rather control function.
        //
        // Add Command related params:
        // CMD_ALWAYS_DO - always do, no matter what. Executed every tick.
        // CMD_DO_AFTER - used in the command loop; if a command times out, any commands immediately after the timeout will be
        //              executed. This then makes progressive rendering possible: we render, timeout, and the next command(s) such as blend and present will be done.
        //              If executed, it will be executed again later when we get the next tick.
        // CMD_NORMAL_SEQUENCE - execute until done, don't come back to it once it's fully executed in the command list.
        
        // Is there anything at all that triggers a rerender?
        // if this is an immediate silent render, go do it. Else, check if we're still rendering; if not, then a deferred silent render can launch.
        _immediateSilentRender = _immediateSilentRender || ( _deferredSilentRender && !_rcs.cmdListActive );
        if ( _needsClear || _needsRender || _overlayDirty || _immediateSilentRender ) {

            // For rendering purposes, rcs.drawOverlay is set true whenever any (new) overlay dirty is noticed during progressive rendering.
            _rcs.drawOverlay = _overlayDirty;

            // restart rendering?
            if ( _needsClear || _needsRender || _immediateSilentRender ) {

                // There are three types of render:
                // 1) full render - not (currently) interruptible, runs until completion, "locks" application
                // 2) progressive render - show a bit more each tick, runs unless interrupted by a move, control, etc.
                // 3) silent render - a full render that is done unless interrupted. Display at end if not interrupted by any other render request.
                var frameBudget;
                var movedStatus = somethingChanged ? WGS.RESET_RELOAD : WGS.RESET_NORMAL;
                if ( _needsClear || _needsRender ) {
                    if ( _this.progressiveRender ) {
                        _rcs.renderType = _rcs.RENDERMODE_PROGRESSIVE;
                        frameBudget = _this.targetFrameBudget;
                    } else {
                        _rcs.renderType = _rcs.RENDERMODE_FULL;
                        // How much time to spend rendering the data; 1e10 is an arbitrarily large number of milliseconds, i.e., progressive is off
                        frameBudget = _this.interruptBudget;
                    }
                } else {
                    // Must be a silent render - really, it's the same as a full render, but has a time limit per tick
                    _rcs.renderType = _rcs.RENDERMODE_SILENT;
                    frameBudget = _this.targetFrameBudget;
                    // we must clear, just as on a full render
                    _needsClear = true;
                    movedStatus = WGS.RESET_REDRAW;
                }

                //if (ENABLE_DEBUG) { console.log(" COMMAND CREATION: clearing: " + _needsClear + ", rendering: " + _needsRender); }

                _deferredSilentRender = _immediateSilentRender = false;

                _rcs.setFrame(frameBudget);

                // set to true when the render is truly done
                _rcs.finishedFullRender = false;

                _rcs.beginCommandSet();

                // Set up commands for the entire sequence of possible render states. The most important thing here is to not overthink it.
                // Each command gets executed. If it runs out of time, it returns "true". On the next tick command processing will continue
                // at the same command (it's up to the command itself to keep track of where it left off). The tricky part is if a command
                // needs to be run after renders every tick, "CMD_DO_AFTER", e.g. draw overlays and present when progressive rendering is on.

                // Otherwise, just lay out the worst-case scenario for drawing the scene, "if this didn't finish here, early on, do the rest
                // later". This happens with ground reflections, for example. There's some logic in the commands themselves that check if it's
                // the first tick, for example, or if it's a progressive tick or a full-render tick.

                // Ground shadow is computed separately, if needed, so check if the feature is in use at all.
                // It is if the flag is on, it's not 2D, and we're not loading (if we are loading, the ground shadow will change
                // anyway, so we don't render it then).
                var useGroundShadow = _groundShadow.enabled && !_this.is2d && !_isLoading;
                var useGroundReflection = (!!_groundReflection) && !_this.is2d && !_isLoading;

                // build a list to do the main full pass
                var cameraChanged = moved || canvasSizeUpdated;

                // Smooth Navigation: if it's on, and "moved" is happening, and AO is on, AO is temporarily turned off in the renderer.
                // We also note this status, and use a special CMD_DO_AFTER command to turn AO back on at the end of every command execution
                // (i.e., tick that this command set runs). This avoids headaches with some other system turning off AO in between ticks -
                // it can now safely do so, without the tick() turning it back on when execution is completed or aborted.
                var suppressAO = moved && _this.skipAOWhenMoving && _renderer.getAOEnabled();

                // -----------------------------------------------------------------------------
                // Start creation of a set of commands to execute over this and following ticks.

                // Highlighting from the model browser needed?
                _rcs.addCommand(cmdBeginScene);
                _rcs.setParam("BeginScene.signalCameraChanged", cameraChanged);
                _rcs.setParam("BeginScene.clear", _needsClear);

                // for Smooth Navigation - turned on later by cmdRestoreAO as an CMD_ALWAYS_DO.
                // We let the clear above clear the SAO buffer, since if we're using smooth navigation
                // we know the SAO there will be invalid. This avoids the case where we're in a long
                // smooth-navigation render which gets interrupted by a "needs present" render (a rollover
                // highlight) which stops the full render we signalled for from completing.
                if ( suppressAO ) {
                    _rcs.addCommand(cmdSuppressAO, _rcs.CMD_ALWAYS_DO);
                }

                // is there any geometry to render?
                if ( _modelQueue ) {

                    // is shadow map needed? Generate only if not progressive.
                    if (_shadowMaps && _shadowMaps.state !== avp.SHADOWMAP_VALID) {
                        _rcs.addCommand(cmdUpdateShadowMap);
                    }

                    // is ground shadow computed at this point? If not, and this is a full
                    // render, or this is a progressive render and it looks likely to finish,
                    // draw it.
                    if (useGroundShadow) {
                        _rcs.addCommand(cmdGenerateGroundShadow);
                        _rcs.setParam("GenerateGroundShadow.afterBeauty", false);
                        _rcs.setParam("GenerateGroundShadow.signalRedraw", false);
                    }

                    // if doing ground reflection, generate it now
                    if (useGroundReflection) {
                        // tell reflection system it needs to start from scratch once the commands start
                        _groundReflection.setDirty();

                        _rcs.addCommand(cmdGenerateGroundReflection);
                        _rcs.setParam("GenerateGroundReflection.afterBeauty", false);
                    }
                    // Blit ground shadow first, if in use and ground reflection not in use.
                    // If ground reflection is in use, the shadow is composited with its target instead.
                    // If we are truly not clearing, then don't blit ground shadow, as it was already
                    // displayed in the previous frame (possibly incorrect for this frame, but the user
                    // asked to have no clear, so...). See LMV-2571
                    else if (useGroundShadow) {
                    //else if (useGroundShadow && !_needsClear) {
                        _rcs.addCommand(cmdBlitGroundShadow);
                    }


                    if ( _modelQueue.hasHighlighted() ) {
                        // set phase and reset
                        _rcs.addCommand(cmdBeginPhase);
                        _rcs.setParam("BeginPhase.phase", avp.RENDER_HIGHLIGHTED);
                        _rcs.setParam("BeginPhase.moved", movedStatus);
                        // need to gather frags for the iterator, etc. only once
                        movedStatus = false;
        
                        // draw the highlighting
                        _rcs.addCommand(cmdMainRender);

                    }
    
                    // beauty pass
                    _rcs.addCommand(cmdBeginPhase);
                    _rcs.setParam("BeginPhase.phase", avp.RENDER_NORMAL);
                    _rcs.setParam("BeginPhase.moved", movedStatus);
                    // need to gather frags for the iterator, etc. only once
                    movedStatus = false;
                    _rcs.addCommand(cmdMainRender);

                    // ghosting is done after the ground reflection is generated and merged, as it
                    // draws transparent atop all.
                    if ( !_modelQueue.areAllVisible() && _this.showGhosting) {

                        // if we are progressive rendering, and are generating ground reflections, we do ghosting
                        // after the ground reflection is done. Else, do it now, as part of the full render, since
                        // we know everything's done.
                        // TODO I can imagine changing this logic - seems like we should have just one "ghosting
                        // after everything" bit of code insertion. The reason there is a split is that for full
                        // rendering we know the ground reflection is done at this point and can simply render atop,
                        // directly. For progressive rendering we need to wait for the reflection to finish, blend it
                        // in under, then ghost.
                        if ( !useGroundReflection || (_rcs.renderType !== _rcs.RENDERMODE_PROGRESSIVE) ) {
                            // show ghosting - highly transparent, so must be rendered last, atop everything else
                            // TODO note that we don't do cmdScenePartRender here, though it might be nice to
                            // show sectioning. I don't really understand, but if we do add it here, the ghosted objects
                            // are drawn normally. I guess these objects need to be drawn again for sectioning?
                            _rcs.addCommand(cmdBeginPhase);
                            _rcs.setParam("BeginPhase.phase", avp.RENDER_HIDDEN);
                            _rcs.setParam("BeginPhase.moved", movedStatus);
            
                            _rcs.addCommand(cmdMainRender);
                        }
                        // note that all (possibly basic, for progressive) rendering is truly done.
                        _rcs.addCommand(cmdFinishAllRendering);
                    } else {
                        // Render sectioning, if any, and any additional buffers needed, such as ID.
                        // TODO for progressive rendering, it seems like we should do this *after* any Present(), if
                        // the buffers are not needed immediately. This command also notes rendering is done.
                        _rcs.addCommand(cmdScenePartRender);
                    }

                    if (_rcs.signalProgressByRendering) {
                        _rcs.addCommand(cmdSignalProcessingDone);
                    }
                }

                // Overlay is always rendered. In this way if we *do* get an overlay dirty while progressive rendering,
                // the overlay will get updated.
                // This must be done after the passes above, because our global rule is "draw if z-depth matches"
                // and the z-depths must be established before the highlighted objects get drawn.
                // render them. Always do this for progressive rendering, even if we stop early, since these are important.
                _rcs.addCommand(cmdRenderOverlays, (_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE) ? _rcs.CMD_DO_AFTER : _rcs.CMD_NORMAL_SEQUENCE );


                // We always need a present, since we know we're doing something. Also antialiasing and whatever blending is needed.
                // Always do this for progressive rendering.
                _rcs.addCommand(cmdPostAndPresent, (_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE) ? _rcs.CMD_DO_AFTER : _rcs.CMD_NORMAL_SEQUENCE);
                _rcs.setParam("PostAndPresent.performAO", _renderer.getAOEnabled() && !suppressAO);

                // If this is a progressive render, make the last thing to happen the ground shadow, which if not done by now will trigger
                // a rerender once it is fully created.
                if ((_rcs.renderType === _rcs.RENDERMODE_PROGRESSIVE) && _modelQueue) {

                    if (_shadowMaps && _shadowMaps.state !== avp.SHADOWMAP_VALID) {
                        // start shadow map generation from beginning
                        _rcs.addCommand(cmdResetShadowMap);
                        _rcs.addCommand(cmdUpdateShadowMap);
                    }

                    // Ground shadows are an entirely separate render, happening concurrently with the main renderer, and
                    // done after the progressive render is performed, if not completed by then. The full render does it
                    // as part of its rerender.

                    // If we are done with progressive and the ground shadow is not done, do them now.
                    if (useGroundShadow) {
                        _rcs.addCommand(cmdGenerateGroundShadow);
                        _rcs.setParam("GenerateGroundShadow.afterBeauty", true);
                        // don't signal a redraw if the ground reflection is about to be finished and merged, too.
                        _rcs.setParam("GenerateGroundShadow.signalRedraw", !useGroundReflection);
                        // TODO really need to fix progress meter, but at least we should show 100% done
                        if (_rcs.signalProgressByRendering) {
                            _rcs.addCommand(cmdSignalProcessingDone);
                        }
                    }

                    // if the ground shadows and reflection are not done, do them now.
                    if (useGroundReflection) {
                        _rcs.groundShadowInPost = false;

                        // Note that ground shadow is guaranteed to be done at this point, so will be merged in correctly.
                        _rcs.addCommand(cmdGenerateGroundReflection);
                        _rcs.setParam("GenerateGroundReflection.afterBeauty", true);

                        // ghosting is done after the ground reflection is generated and merged, as it
                        // draws transparent atop all. Note that sectioning is already done.
                        if ( !_modelQueue.areAllVisible() && _this.showGhosting) {
                            // show ghosting - highly transparent, so must be rendered last, atop everything else
                            // TODO note that we don't do cmdScenePartRender here, though it might be nice to
                            // show sectioning. I don't really understand, but if we do add it here, the ghosted objects
                            // are drawn normally. I guess these objects need to be drawn again for sectioning?
                            _rcs.addCommand(cmdBeginPhase);
                            _rcs.setParam("BeginPhase.phase", avp.RENDER_HIDDEN);
                            _rcs.setParam("BeginPhase.moved", movedStatus);
            
                            _rcs.addCommand(cmdMainRender);
                        }

                        // if it's done, perform a present
                        _rcs.addCommand(cmdFinishAllRendering);
                        _rcs.addCommand(cmdPostAndPresent);
                        _rcs.setParam("PostAndPresent.performAO", _renderer.getAOEnabled() && !suppressAO);
                        if (_rcs.signalProgressByRendering) {
                            _rcs.addCommand(cmdSignalProcessingDone);
                        }
                    }
                }

                // Smooth Navigation - if on, then we need to always turn the renderer back to AO at the end of any tick;
                // it will get turned back off the next tick by the renderer.
                if ( suppressAO ) {
                    _rcs.addCommand(cmdRestoreAO, _rcs.CMD_ALWAYS_DO);
                    // If we get to this command, we've done all we can during smooth navigation and should now signal for a full redraw
                    // without smooth navigation. This works because "moved" should be false on the next tick (unless of course the
                    // user moved the view) and so a full or progressive render will occurs with smooth navigation off.
                    _rcs.addCommand(cmdSignalRedraw);
                }

                _rcs.addCommand(cmdFinishedFullRender);

                _rcs.endCommandSet();

                // if we reenter, by turning these off, we then will not rebuild the command list
                _needsClear = false;
                _needsRender = false;
                // Avoid having updateOverlays() called every tick during a progressive rendering by turning off the overlay dirty flag. 
                // If we get a later overlayDirty, this will trigger updateOverlays() at the start of tick(), and will als cause the
                // cmdRenderOverlays to trigger during a progressive render.
                _overlayDirty = false;
            }
            ////////////////////////////////////////////////////////////////////////////

            // only case left is that overlay is dirty
            else {

                // Possibly draw the overlay, only.
                // Check if we've finished a render. If we are, we set up a short render to update the overlay.
                // We ignore overlay dirty if we're in the middle of a (more than one tick) render, since the render itself will update the overlay.
                if ( _rcs.finishedFullRender ) {

                    _rcs.beginCommandSet();

    if (ENABLE_DEBUG) { console.log("=====\nOVERLAY DIRTY");}

                    if ( rollover ) {
                        // Do just the blend pass, having already adjusted the uniform for fading in.
                        _rcs.addCommand(cmdForcePresent);

                    } else {
                        // full overlay render and display

                        // just the overlay needs to be re-rendered
                        _rcs.addCommand(cmdRenderOverlays, true);

                    }
                    
                    // we always need a present, since we know we're doing something.
                    _rcs.addCommand(cmdPostAndPresent, true);
                    // don't need to think about AO, since we are just fading in.
                    _rcs.setParam("PostAndPresent.performAO", _renderer.getAOEnabled());

                    _rcs.endCommandSet();

                    // Avoid having updateOverlays() called every tick during a progressive rendering by turning off the overlay dirty flag. 
                    // If we get a later overlayDirty, this will trigger updateOverlays() at the start of tick(), and will als cause the
                    // cmdRenderOverlays to trigger during a progressive render.
                    // Note that if we get an overlayDirty and rendering is occurring, _overlayDirty won't get cleared, which is good:
                    // we want the command system to detect this and turn on overlay rendering at that point.
                    _overlayDirty = false;
                }
            }
        }

        ///////////////////////////////////////////////
        // Run the command list, if any.
        _rcs.executeCommandList();

        ///////////////////////////////////////////////
        // Some signalling thing, here for some undocumented reason. TODO
        // we do things a bit different, we might want to be checking _rcs.justFinished this tick or whatever.
        if (_neededPresent !== _rcs.screenHasChanged) {
            _neededPresent = _rcs.screenHasChanged;
            _this.api.dispatchEvent({type: av.FINAL_FRAME_RENDERED_CHANGED_EVENT, value: {finalFrame: !_rcs.cmdListActive}});
        }

        // used to determine FPS
        _lastHighResTimeStamp = _rcs.highResTimeStamp;
    }

    // webVR has a requestAnimationFrame handler specific to HMD displays 
    this.setLmvDisplay = function(display) {
        _lmvDisplay = display;
    };

    this.run = function() {
        //Begin the render loop (but delay first repaint until the following frame, so that
        //data load gets kicked off as soon as possible
        _reqid = 0;
        setTimeout(function(){
            (function animloop(highResTimeStamp) {
                _reqid = _lmvDisplay.requestAnimationFrame(animloop);
                tick(highResTimeStamp);
            })();
        }, 1);
    };

    this.toggleProgressive = function(value) {
        this.progressiveRender = value;
        _needsClear = true;
    };

    /**
     * Render visible meshes first, then hidden objects
     * @param {Bool} enable
     */
    this.toggleVizBuffer = function(value) {
        var renderer = this.glrenderer();
        if (renderer && this.isvizCacheEnabled !== value) {
            this.isvizCacheEnabled = value;
            if (this.model && renderer) {
                this.model.isvizCacheEnabled = value;
                this.model.readbackTargetIdCallback = this.renderer().readbackTargetId;
                renderer.setIdBufferSource(value ? WGS.FRAGMENT_ID : WGS.DB_ID);
            }
            _needsClear = true;
        }
    };

    this.toggleSwapBlackAndWhite = function(value) {
        this.swapBlackAndWhite = value;
        _renderer.toggleSwapBlackAndWhite(value);
        _needsClear = true;
    };

    this.toggleGhosting = function(value) {
        this.showGhosting = value;
        _needsClear = true;
    };

    this.toggleOverlaysWhileMoving = function(value) {
        this.showOverlaysWhileMoving = value;
    };

    this.togglePostProcess = function(useSAO, useFXAA) {
        _renderer.initPostPipeline(useSAO, useFXAA);
        this.fireRenderOptionChanged();
        _needsClear = true;
    };


    this.preloadPostProcessStyle = function(style) {
        _renderer.preloadPostProcessStyle(style);
    };

    this.setPostProcessParameter = function(token,value) {
        _renderer.setPostProcessParameter(token,value);
        this.fireRenderOptionChanged();
        // TODO just need the post-process to run, but there's no such mode, so must redraw all
        this.invalidate(true);
    };

    this.toggleGroundShadow = function(value) {
        if (_groundShadow.enabled === value)
            return;

        _groundShadow.enabled = value;
        _groundShadow.clear();
        if ( value ) {
            _groundShadow.setDirty();
        }
        // if we're turning on the ground shadow, we need to set up the ground plane
        updateGroundTransform();
        this.fireRenderOptionChanged();
        this.invalidate(true, false, false);
    };

    this.setGroundShadowColor = function(color) {
        if (!_groundShadow.enabled) return;

        _groundShadow.setColor(color);
        this.invalidate(true, false, false);
    };

    this.setGroundShadowAlpha = function(alpha) {
        if (!_groundShadow.enabled) return;

        _groundShadow.setAlpha(alpha);
        this.invalidate(true, false, false);
    };

    this.toggleGroundReflection = function(enable) {
        if ((enable && !!_groundReflection) ||
            (!enable && !_groundReflection))
            return;

        if (enable) {
            _groundReflection = new av.Shaders.GroundReflection(_webglrender, this.canvas.clientWidth, this.canvas.clientHeight, { clearPass: _renderer.getClearPass() });
            _groundReflection.setClearColors(this.clearColorTop, this.clearColorBottom, av.isAndroidDevice() || av.isIOSDevice());
            _groundReflection.toggleEnvMapBackground(_envMapBackground);
            _groundReflection.setEnvRotation(_renderer.getEnvRotation());
            // if we're turning on the ground reflection, we need to set up the ground plane
            updateGroundTransform();
        }
        else {
            _groundReflection.cleanup();
            _groundReflection = undefined;
        }

        this.fireRenderOptionChanged();
        this.invalidate(true, false, false);
    };

    this.setGroundReflectionColor = function(color) {
        if (!_groundReflection) return;

        _groundReflection.setColor(color);
        this.invalidate(true, false, false);
    };

    this.setGroundReflectionAlpha = function(alpha) {
        if (!_groundReflection) return;

        _groundReflection.setAlpha(alpha);
        this.invalidate(true, false, false);
    };

    this.toggleEnvMapBackground = function(value) {
        _envMapBackground = value;
        _renderer.toggleEnvMapBackground(value);

        if (_groundReflection) {
            _groundReflection.toggleEnvMapBackground(value);
        }
        this.invalidate(true, true, false);
    };

    this.isEnvMapBackground = function() {
        return _envMapBackground;
    };

    this.setOptimizeNavigation = function(value) {
        this.skipAOWhenMoving = value;
    };

    // If we have selection meshes, this function makes sure that they use exactly the same
    // geometry as we used in the main scene rendering. This is needed to avoid z-buffer artifacts
    // when using consolidation.
    function updateSelectionProxies() {
        for (var id in _this.selectionMeshes) {
            var proxy = _this.selectionMeshes[id];

            // Updating proxies is only relevant when using consolidtion. Otherwise, we always use the original
            // fragment geometry and can keep static proxy geometry.
            if (proxy.model && proxy.model.isConsolidated()) {
                proxy.model.updateRenderProxy(proxy, proxy.fragId);
            }
        }
    }

    this.renderOverlays = function() {

        updateSelectionProxies();

        //The overlays (selection, pivot, etc) get lighted using
        //the default lights, even if IBL is on
        var lightsOn = this.lightsOn;
        if (!lightsOn)
            this.toggleLights(true, true);

        var oldIntensity;
        if (this.dir_light1) {
            oldIntensity = this.dir_light1.intensity;
            this.dir_light1.intensity = 1;
        }

        _renderer.renderOverlays(this.overlayScenes, this.lightsOn ? this.lights : this.no_lights);

        if (!lightsOn)
            this.toggleLights(false, true);

        if (this.dir_light1)
            this.dir_light1.intensity = oldIntensity;
    };

    this.setLayerVisible = function (layerIndexes, visible) {
        this.matman().setLayerVisible(layerIndexes, visible);
        this.invalidate(true);
    };

    this.isLayerVisible = function (layerIndex) {
        return this.matman().isLayerVisible(layerIndex);
    };

    this.getVisibleLayerIds = function() {
        var data = this.model.getData();
        var lmap = data.layersMap;
        var visibleLayerIds = [];
        for (var layerIndex in lmap) {
            if ( this.isLayerVisible(layerIndex) ) {
                visibleLayerIds.push( lmap[layerIndex] ); // map from (index) into (id)
            }
        }
        return visibleLayerIds;
    };

    // Find model's bounds, including ground plane, if needed.
    // Fit near and far planes to the model.
    this.updateCameraMatrices = (function() {

        var tmpCameraMatrix;
        var tmpViewMatrix;
        var tmpBox;

        function init_three() {
            tmpCameraMatrix = new THREE.Matrix4();
            tmpViewMatrix = new THREE.Matrix4();
            tmpBox = new THREE.Box3();
        }

        return function() {

        if (!tmpBox)
            init_three();

        var camera = this.camera;

        //NOTE: This is not computing the same matrix as what we use for rendering,
        //in cases where we are in ORTHO mode and the camera is inside the model,
        //which would result in negative near plane. For the purposes of computing
        //the near/far planes, we have to skip the logic that adjusts the view matrix
        //based on the near/far planes. See UnifiedCamera.updateMatrix for the related
        //adjustment to the view matrix.
        tmpCameraMatrix.compose( camera.position, camera.quaternion, camera.scale );
        tmpViewMatrix.getInverse( tmpCameraMatrix );

        //TODO: Would be nice if this got called by the world up tool instead,
        //so that we don't have to update it every frame.
        if (camera.worldup)
            this.setWorldUp(camera.worldup);

        //Fix near and far to fit the current view
        if (this.model) {
            var worldBox = this.getVisibleBounds(true, _overlayDirty);
            tmpBox.copy(worldBox);

            //If reflection is on, then we need to double the worldBox size in the Y
            //direction, the reflection direction, otherwise the reflected view can be
            //clipped.
            if ( _groundReflection ) {
                // Increase bounding box to include ground reflection geometry. The idea
                // here is to extend the bounding box in the direction of reflection, based
                // on the "up" vector.
                var tmpVecReflect = new THREE.Vector3();
                tmpVecReflect.multiplyVectors( tmpBox.max, camera.worldup );
                var tmpVecMin = new THREE.Vector3();
                tmpVecMin.multiplyVectors( tmpBox.min, camera.worldup );
                tmpVecReflect.sub( tmpVecMin );
                // tmpVecReflect holds how much to increase the bounding box.
                // Negative values means the "up" vector is upside down along that axis,
                // so we increase the maximum bounds of the bounding box in this case.
                if ( tmpVecReflect.x >= 0.0 ) {
                    tmpBox.min.x -= tmpVecReflect.x;
                } else {
                    tmpBox.max.x -= tmpVecReflect.x;
                }
                if ( tmpVecReflect.y >= 0.0 ) {
                    tmpBox.min.y -= tmpVecReflect.y;
                } else {
                    tmpBox.max.y -= tmpVecReflect.y;
                }
                if ( tmpVecReflect.z >= 0.0 ) {
                    tmpBox.min.z -= tmpVecReflect.z;
                } else {
                    tmpBox.max.z -= tmpVecReflect.z;
                }
            }

            // Expand the bbox based on ground shadow. Note that the horizontal extent of the ground shadow
            // may be significantly larger for flat shadow light directions.
            if (_shadowMaps && _shadowMaps.groundShapeBox) {
                tmpBox.union(_shadowMaps.groundShapeBox);
            }

            //Transform the world bounds to camera space
            //to estimate the near/far planes we need for this frame
            tmpBox.applyMatrix4(tmpViewMatrix);

            //Expand the range by a small amount to avoid clipping when
            //the object is perfectly aligned with the axes and has faces at its boundaries.
            var sz = 1e-5 * (tmpBox.max.z - tmpBox.min.z);

            //TODO: expand for ground shadow. This just matches what the
            //ground shadow needs, but we need a better way to take into account
            //the ground shadow scene's bounds
            var expand = (tmpBox.max.y - tmpBox.min.y) * 0.5;

            var dMin = -(tmpBox.max.z+sz)-expand;
            var dMax = -(tmpBox.min.z-sz)+expand;

            //Camera is inside the model?
            if (camera.isPerspective) {
                // dMin might be OK, or might be negative. If it's negative,
                // give it a value of 1/10,000 of the entire scene's size relative to this view direction,
                // or 1, whichever is *smaller*. It's just a heuristic.
                dMin = Math.max(dMin, Math.min(1, Math.abs(dMax - dMin) * 1e-4));

                if ( dMax < 0 ) {
                    // near and far planes should always be positive numbers for perspective
                    dMax = 1e-4;
                }
                // One more attempt to improve the near plane: make it 1/100,000 of the distance of the
                // far plane, if that's higher.
                // See https://wiki.autodesk.com/display/LMVCORE/Z-Buffer+Fighting for reasoning.
                // 1e-4 is generally good below, but inside Silver Cross we get a lot of near clipping. So, 1e-5.
                dMin = Math.max(dMin, dMax * 1e-5);
            } else {
                //TODO:
                //Do nothing in case of ortho. While this "fixes" near plane clipping too aggressively,
                //it effectively disallows moving through walls to go inside the object.
                //So we may need some heuristic based on how big we want the object to be
                //on screen before we let it clip out.
                //dMin = Math.max(dMin, 0);
            }

            //The whole thing is behind us -- nothing will display anyway?
            dMax = Math.max(dMax, dMin);

            camera.near = dMin;
            camera.far = dMax;
            camera.updateProjectionMatrix();

            //Update the line width scale with the
            //new pixels per unit scale
            var distance, pixelsPerUnit;
            if (this.model.is2d())
            {
                //Here we base pixel scale on the point at the center of the view.
                //However, this might not always be the most appropriate point,
                //e.g. at oblique angles or when the drawing is off to one side.
                //It might make more sense to base the scale on the distance of the
                //camera to the nearest part of the world bounding box, which requires
                //a more generic ray-aabb test.
                var groundPt = this.intersectGroundViewport(new THREE.Vector3(0,0,1));

                if (groundPt)
                    distance = camera.position.distanceTo(groundPt);
                else
                    distance = camera.position.distanceTo(worldBox.center()); //degenerate case: camera direction is parallel to the ground plane

                //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
                //so here we don't need separate code path for ortho.
                pixelsPerUnit = _renderer.settings.deviceHeight / (2 * distance * Math.tan(THREE.Math.degToRad(camera.fov * 0.5)));

                //If we want to take into account devicePixelRatio for line weights (so that lines are not too thin)
                //we can do this here, but it's less esthetically pleasing:
                //pixelsPerUnit /= _webglrenderer.getPixelRatio();

                _materials.updatePixelScale(pixelsPerUnit);

                // AutoCAD drawings are commonly displayed with white lines on a black background. Setting reverse swaps (just)
                // these two colors.
                _materials.updateSwapBlackAndWhite(this.swapBlackAndWhite);
            } else {

                //If there is a cutting plane, get a point on that plane
                //for by the pixel scale computation.
                var cp = _materials.getCutPlanesRaw();

                var pt;
                if (cp && cp.length) {
                    var p = cp[0];

                    var dir = camera.target.clone().sub(camera.position).normalize();
                    var denominator = dir.dot(p);

                    if (denominator === 0)
                        pt = worldBox.center();
                    else {
                        var t = - ( camera.position.clone().dot( p ) + p.w ) / denominator;
                        pt = worldBox.clampPoint(dir.multiplyScalar(t).add(camera.position));
                    }
                } else {
                    pt = worldBox.center();
                }

                distance = camera.position.distanceTo(pt);

                //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
                //so here we don't need separate code path for ortho.
                pixelsPerUnit = _renderer.settings.deviceHeight / (2 * distance * Math.tan(THREE.Math.degToRad(camera.fov * 0.5)));

                _materials.updatePixelScale(pixelsPerUnit);
            }

        }
    };
    })();

    this.initLights = function()
    {
        this.dir_light1 = new THREE.DirectionalLight(_defaultDirLightColor, _defaultLightIntensity);

        this.dir_light1.position.copy( _lightDirDefault );

        //Note this color will be overridden by various light presets
        this.amb_light = new THREE.AmbientLight(_defaultAmbientColor);

        // Set this list only once, so that we're not constantly creating and deleting arrays each frame.
        // See https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript for why.
        // use this.no_lights empty array if no lights are needed.
        this.lights = [this.dir_light1, this.amb_light];

        //We do not add the lights to any scene, because we need to use them
        //in multiple scenes during progressive render.
        //this.scene.add(this.amb_light);

        // Attach the light to the camera, so that the light direction is applied in view-space.
        // Note:
        //
        //  1. For directional lights, the direction where the light comes from is determined by
        //     lightPosition - targetPosition, both in in world-space.
        //  2. The default target of dir lights is the world origin.
        //  3. Transforming the light object only affects the light position, but has no effect on the target.
        //
        // The goal is to rotate the lightDir with the camera, but keep it independent
        // of the camera position. Due to 3. above, we must also attach the light's target object to the camera.
        // Otherwise, the camera position would incorrectly be added to the light direction.
        this.camera.add(this.dir_light1);
        this.camera.add(this.dir_light1.target);

        _lightsInitialized = true;
    };

    this.toggleLights = function(state, isForOverlay) {

        //This can happen during initial construction
        if (!this.amb_light)
            return;

        // Don't create or remove arrays, as that's bad to do during rendering.
        // Instead, later use lightsOn to decide which array to use.
        this.lightsOn = state;

        //Update the light colors based on the current preset
        var preset = avp.LightPresets[_currentLightPreset];
        var ac = preset.ambientColor;
        var dc = preset.directLightColor;

        ac = ac || _defaultAmbientColor.toArray();
        dc = dc || _defaultDirLightColor.toArray();

        if (this.lightsOn) {
            if (isForOverlay && this.amb_light)
                this.amb_light.color.setRGB(dc[0]*0.5,dc[1]*0.5,dc[2]*0.5);
            else if (this.amb_light) {
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
            }

            if (this.dir_light1) {
                this.dir_light1.color.setRGB(dc[0],dc[1],dc[2]);
            }
        }
        else
        {
            //Restores the ambient for the main scene after drawing overlays
            if (this.amb_light && isForOverlay)
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
        }
    };

    //Forces the view controller to update when the camera
    //changes programmatically (instead of via mouse events).
    this.syncCamera = function(syncWorldUp)
    {
        this.camera.updateProjectionMatrix();

        if( syncWorldUp )
            this.setWorldUp( this.api.navigation.getWorldUpVector() );

        _cameraUpdated = true;
    };


    this.setViewFromFile = function(model, skipTransition) {

        var camera;

        var defaultCamera = model.getDefaultCamera();

        if (defaultCamera) {

            camera = defaultCamera;

        } else {

            //Model has no default view. Make one up based on the bounding box.

            camera = {};

            var bbox = model.getBoundingBox();
            var size = bbox.size();
            camera.target = bbox.center();

            if (!model.is2d())
            {
                camera.isPerspective = true;
                camera.fov = this.camera.fov;
                camera.up = this.camera.up.clone();

                camera.position = camera.target.clone();
                camera.position.z += 1.5 * Math.max(size.x, size.y, size.z);
            }
            else {
                camera.isPerspective = false;

                var pageAspect = size.x / size.y;
                var screenAspect = this.camera.aspect;

                //Fit the page to the screen
                if (screenAspect > pageAspect)
                    camera.orthoScale = size.y;
                else
                    camera.orthoScale = size.x / screenAspect;

                //2D case -- ground plane / up vector is Z
                camera.up = new THREE.Vector3(0,0,1);

                camera.position = camera.target.clone();
                camera.position.z += camera.orthoScale;

                //This is to avoid freaking out the camera / controller with co-linear up and direction
                camera.target.y += 1e-6 * size.y;

            }

        }

        this.setViewFromCamera(camera, skipTransition);
    };

    //Camera is expected to have the properties of a THREE.Camera.
    this.adjustOrthoCamera = function(camera) {

        if (!camera.isPerspective && this.model) {
            var bbox = this.model.getBoundingBox();
            var size = bbox.size();

            var at = camera.target.clone().sub(camera.position);
            var targetDistance = at.length();
            if (targetDistance > 1000 * size.length()) {

                //Sometimes (Revit) the camera target is unspecified/infinite
                //for ortho. So we pick target and distance such that
                //initial view and orbit is about right by using a target point that is a similar
                //distance away as camera->bbox center, but is in the
                //direction of the at vector (which is not necessarily looking at the center)
                var dist = camera.position.distanceTo(bbox.center());
                camera.target.copy(camera.position).add(at.normalize().multiplyScalar(dist));
            }
            else {
                //UnifiedCamera does not actually look at the orthoScale property. It bases
                //the ortho projection on value derived from the position-target distance and an
                //assumed field of view. For a well defined ortho view, we expect that
                //the eye-target distance and ortho scale are equal. Some extractors have historically
                //defined only one of these in a sane way (e.g. the other code path in this if condition).

                if (Math.abs(targetDistance - camera.orthoScale) / targetDistance > 1e-5) {

                    avp.logger.warn("Ortho scale does not match eye-target distance. One of them is likely wrong, but which one?");

                    //This checks for ortho camera views defined in Revit bubbles. Unlike the same view in the SVF,
                    //the one in the bubble sets orthoHeight and FOV to trivial values that make no sense, while
                    //target distance is correct.
                    var isLikelyRevitView = (camera.fov === 0 && camera.orthoScale === 1);

                    //Assume ortho scale is correct if we are not in the Revit situation above
                    var orthoScaleIsCorrect = !isLikelyRevitView;
                    if (orthoScaleIsCorrect) {
                        //This line applies orthoScale (assumed correct) to target distance (incorrect)
                        camera.position.copy(camera.target).add(at.normalize().multiplyScalar(-camera.orthoScale));
                    } else {
                        //do nothing, target distance is correct and will be used by UnifiedCamera
                    }
                }


            }
        }
    };

    /**
     * Switches to a new view based on a given camera. If the current orbiting mode is constrained,
     * the up vector may be adjusted.
     *
     * @param {THREE.Camera} camera Input camera.
     * @param {boolean} skipTransition Switch to the view immediately instead of transitioning.
     */
    this.setViewFromCamera = function(camera, skipTransition)
    {
        this.adjustOrthoCamera(camera);

        // If the current orbiting mode is unconstrained (the 'freeorbit' tool),
        // use exact camera settings, otherwise (the 'orbit' tool) snap the up vector to a world axis.
        // However, if this is the initial load and the model has a free orbit navigation mode defined
        // we will use the exact camera settings no matter if the free orbit tool is active or not.
        // Note #1: that 'freeorbit' vs. 'orbit' tools are active even when the FusionOrbit extension is used.
        // Note #2: isToolActivated is not available in node-lmv, so we stub it to always return false
        var navModeHint = this.model.getMetadata('navigation hint', 'value', null);
        var useExactCamera = this.controls.isToolActivated('freeorbit')  || 
                             (skipTransition && navModeHint === "Freeorbit");

        var upVectorArray = this.model ? this.model.getUpVector() : null;

        var worldUp;
        if (upVectorArray) {
            worldUp = new THREE.Vector3().fromArray(upVectorArray);
        } else {
            worldUp = useExactCamera ? camera.up.clone() : av.Navigation.snapToAxis(camera.up.clone());
        }

        if (useExactCamera) {
            if (this.api.prefs)
                this.api.prefs.set('fusionOrbitConstrained', worldUp.equals(camera.up));
        } else {
            camera.up = worldUp;
        }

        var navapi = this.api.navigation;
        if ( navapi) {

            var tc = this.camera;

            if (!skipTransition) {
                tc.isPerspective = camera.isPerspective;

                if( !camera.isPerspective ) {
                    tc.saveFov = camera.fov;    // Stash original fov
                    camera.fov = av.UnifiedCamera.ORTHO_FOV;
                }

                if (useExactCamera) {
                    navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, camera.up, worldUp);
                } else {
                    var up = navapi.computeOrthogonalUp(camera.position, camera.target);
                    navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, up, worldUp);
                }
            } else {
                //This code path used during initial load -- it sets the view directly
                //without doing a transition. Transitions require that the camera is set explicitly

                tc.up.copy(camera.up);
                tc.position.copy(camera.position);
                tc.target.copy(camera.target);
                if( camera.isPerspective ) {
                    tc.fov = camera.fov;
                }
                else {
                    tc.saveFov = camera.fov;    // Stash original fov
                    tc.fov = av.UnifiedCamera.ORTHO_FOV;
                }
                tc.isPerspective = camera.isPerspective;
                tc.orthoScale = camera.orthoScale;
                tc.dirty = true;

                navapi.setWorldUpVector(useExactCamera ? worldUp : tc.up);
                navapi.setView(tc.position, tc.target);
                navapi.setPivotPoint(tc.target);

                this.syncCamera(true);
            }
        }
        _cameraUpdated = true;
    };

    this.setViewFromViewBox = function(model, viewbox, name, skipTransition)
    {
        if (!model.is2d()) {
            return;
        }


        var camera = {};

        var bbox = model.getBoundingBox();

        var box = {
            width: viewbox[2] - viewbox[0],
            height: viewbox[3] - viewbox[1]
        };
        box.aspect = box.width / box.height;
        box.centerX = viewbox[0] + box.width / 2;
        box.centerY = viewbox[1] + box.height / 2;

        var screenAspect = this.camera.aspect;

        //Fit the viewbox to the screen
        if (screenAspect > box.aspect)
            camera.orthoScale = box.height;
        else
            camera.orthoScale = box.width / screenAspect;

        camera.isPerspective = false;
        camera.position = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z + camera.orthoScale);
        camera.target = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z);
        camera.target.y += 1e-6 * box.height;

        camera.up = new THREE.Vector3(0,0,1);

        this.setViewFromCamera(camera, skipTransition);
    };

    this.setWorldUp = function(upVector) {

        if (_worldUp.equals(upVector))
            return;

        _worldUp.copy(upVector);

        // get the (max) up axis and sign
        var maxVal = Math.abs(upVector.x);
        _worldUpName = "x";
        if (Math.abs(upVector.y) > maxVal) {
            _worldUpName = "y";
            maxVal = Math.abs(upVector.y);
        }
        if (Math.abs(upVector.z) > maxVal) {
            _worldUpName = "z";
        }

        var getRotation = function(vFrom, vTo) {
            var rotAxis = (new THREE.Vector3()).crossVectors(vTo, vFrom).normalize();  // not sure why this is backwards
            var rotAngle = Math.acos(vFrom.dot(vTo));
            return (new THREE.Matrix4()).makeRotationAxis(rotAxis, rotAngle);
        };

        var identityUp = new THREE.Vector3(0,1,0);
        _this.camera.worldUpTransform = getRotation(identityUp, upVector);

        this.sceneUpdated(false);
    };


    this.addModel = function(model)
    {
        if (!model)
            return;

        //Is it the first model being loaded into the scene?
        var isOverlay = !!this.model;
        var is2d = model.is2d();

        if (!this.model) {
            this.model = model;

            if (!is2d)
                this.toggleVizBuffer(this.isvizCacheEnabled);
            _renderer.setUnitScale(model.getUnitScale());

        }

        //Create a render list for progressive rendering of the
        //scene fragments
        _modelQueue.addModel(model);
        this.selector.addModel(model);
        this.visibilityManager.addModel(model);

        if (is2d)
        {
            //In case of a 2D drawing
            //initialize the common line shader
            //and the layers texture

            var data = model.getData();
            _materials.initLayersTexture(data.layerCount, data.layersMap);

            var idMatName = _materials.create2DMaterial(model, { useInstancing: this.use2dInstancing }, true, false, function() { _this.invalidate(false, true, false); });
            var idMaterial = _materials.findMaterial(model, idMatName);

            _renderer.enter2DMode(idMaterial);

            if (!isOverlay) {
                this.is2d = true;

                //Rememeber the light preset so we can restore is
                //when we unload the 2d sheet -- the light preset for 2d
                //is not persisted.
                _oldLightPreset = _currentLightPreset;
                this.setLightPreset(avp.DefaultLightPreset2d);

                var svf = model.getData();
                if (svf.hidePaper) {
                    var bg = svf.bgColor;
                    var r = (bg>>16)&0xff;
                    var g = (bg >>8)&0xff;
                    var b = bg&0xff;
                    this.setClearColors(r,g,b,r,g,b );
                }
            }
        }

        if (this.api.navigation) {
            this.api.navigation.setIs2D(is2d && !isOverlay);
            this.api.setActiveNavigationTool(); // use default nav tool

            // For leaflet, restrict 2D navigation, so that we cannot zoom/pan away from the image
            // and stop zoom-in when reaching max resolution.
            var modelData = model.getData();
            if (modelData.isLeaflet) {
                this.api.navigation.setConstraints2D(modelData.bbox, modelData.maxPixelPerUnit);
            }
            else {
                // If it is not a leaflet model, clear constrain 2d. 
                // Otherwise, it will leak to the next model that viewer could open up.
                this.api.navigation.setConstraints2D();
            }
        }


        if (!isOverlay && !model.getData().loadOptions.preserveView) {
            this.setViewFromFile(model, true);
            this.controls.recordHomeView();
        }

        this.setupLighting(model);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };


    this.setupLighting = function(model) {
        
        model = model || this.model;

        if (!model || model.is2d()) {
            return;
        }

        // grab the environment preset data from the file.
        //This will usually be set for Fusion files.
        if (!this.setLightPresetFromFile(model)) {
            //When switching from a 2D sheet back to a 3D view,
            //we restore the environment map that was used for the
            //last 3D view displayed. The operation is delayed until here
            //so that switching between 2D sheets does not incur this unnecessary overhead.
            if (_oldLightPreset >= 0) {
                this.setLightPreset(_oldLightPreset, true);
                _oldLightPreset = -1;
            } else {
                this.setLightPreset(_currentLightPreset, false);
            }
        }

        this.setAOHeuristics(model);
    };

    this.getSvfMaterialId = function (fragId) {
        return this.model.getFragmentList().getSvfMaterialId(fragId);
    };

    this.getMaterials = function() { return _materials; };


    //Creates a THREE.Mesh representation of a fragment. Currently this is only
    //used as vehicle for activating a fragment instance for rendering once its geometry is received
    //or changing the fragment data (matrix, material). So, it's mostly vestigial.
    this.setupMesh = function(model, threegeom, materialId, matrix) {

        var svf = model.getData();

        var m = {
            geometry: threegeom,
            matrix: matrix,
            isLine: threegeom.isLines,
            isWideLine: threegeom.isWideLines,
            isPoint: threegeom.isPoints,
            is2d: threegeom.is2d
        };

        m.material = this.matman().setupMaterial(model, threegeom, materialId);

        return m;
    };

    function _initAnim(model) {

        var svf = model.getData();
        // Init animations
        function initAnimations() {
            if (svf.animations) {
                _this.keyFrameAnimator = new avp.KeyFrameAnimator(_this, svf.animations.duration);
                for (var a in svf.animations.animations) {
                    _this.keyFrameAnimator.add(svf.animations.animations[a]);
                }
                _this.keyFrameAnimator.goto(0);
                _this.api.dispatchEvent({ type: av.ANIMATION_READY_EVENT });
            }
            _this.api.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, initAnimations);
        }
        // init animations after object tree created and geometry loaded
        if (model.isObjectTreeCreated()) {
            initAnimations();
        } else {
            _this.api.addEventListener(av.OBJECT_TREE_CREATED_EVENT, initAnimations);
        }

    }

    this.onDemandLoadComplete = function(model) {
        // This one will be called on an SVF file with the on demand loading enabled.
        // Quite similar as onLoadComplete, but with some difference,

        _isLoading = false;
        
        this.signalProgress(100, av.ProgressState.LOADING);

        if ( (_groundShadow && _groundShadow.enabled) || _groundReflection ) {
            // TODO: may need this instead - test with ground shadow
            //             this.sceneUpdated(false);
            this.invalidate(false, true);
        }

        //In the case of 2d drawing, initialize the dbIds texture
        //to be used for selection highlighting. Initially,
        //nothing is highlighted
        if (this.is2d) {
            var selectionTexture = _materials.initSelectionTexture(model.getData().maxObjectNumber);
            var selMatName = _materials.create2DMaterial(model, { useInstancing: this.use2dInstancing }, false, selectionTexture, function() { _this.invalidate(false, true, false); });
            this.selectionMaterial2d = _materials.findMaterial(model, selMatName);

            this.createOverlayScene("selection2d", this.selectionMaterial2d);
        }

        var svf = model.getData();
        if (svf.hasLines) {
            _materials.togglePolygonOffset(true);
            _renderer.setDepthMaterialOffset(_materials.getPolygonOffsetOn(), _materials.getPolygonOffsetFactor(), _materials.getPolygonOffsetUnits());
        }

        // do a silent render in case a transparent object got loaded and rendered ahead of an opaque one.
        if ( _materials.hasTransparentMaterial() ) {
            this.requestDeferredSilentRender();
        }

        // Init animations
        _initAnim(model);

        // Fire the event so we know the on demand requested geometry are loaded done.
        this.api.dispatchEvent({
            type: av.GEOMETRY_LOADED_EVENT,
            model: model,
            onDemandLoad: true
        });
    };

    // Gets called by the active Loader
    this.onLoadComplete = function (model)
    {
        _isLoading = false;

        this.signalProgress(100, av.ProgressState.LOADING);

        // Only if ground shadows or reflections are on do we need to emit a refresh.
        if ( (_groundShadow && _groundShadow.enabled) || _groundReflection ) {
            this.sceneUpdated(false);
        }

        //In the case of 2d drawing, initialize the dbIds texture
        //to be used for selection highlighting. Initially,
        //nothing is highlighted
        if (this.is2d) {
            var selectionTexture = _materials.initSelectionTexture(model.getData().maxObjectNumber);
            var selMatName = _materials.create2DMaterial(model, { useInstancing: this.use2dInstancing }, false, selectionTexture, function() { _this.invalidate(false, true, false); });
            this.selectionMaterial2d = _materials.findMaterial(model, selMatName);

            this.createOverlayScene("selection2d", this.selectionMaterial2d);
        }

        var svf = model.getData();

        var geomList = _modelQueue.getGeometryList();
        if (geomList) {
            _modelQueue.getGeometryList().printStats();
        }

        //If the model has line geometries
        //set polygon offset on the solid materials
        //so that we avoid z-fighting between solids and
        //their outlines.
        if (svf.hasLines) {
            _materials.togglePolygonOffset(true);
            _renderer.setDepthMaterialOffset(_materials.getPolygonOffsetOn(), _materials.getPolygonOffsetFactor(), _materials.getPolygonOffsetUnits());
        }

        if (!model.hasGeometry()) {
            avp.logger.warn("Loaded model has no geometry.");
        }
        // do a silent render in case a transparent object got loaded and rendered ahead of an opaque one.
        else if ( _materials.hasTransparentMaterial() ) {
            this.requestSilentRender();
        }

        // Init animations
        _initAnim(model);


        // Fire the event so we know the geometry is done loading.
        this.api.dispatchEvent({
            type: av.GEOMETRY_LOADED_EVENT,
            model: model
        });
    };

    this.onTextureLoadComplete = function(model) {
        // Fire the event so we know the textures for a model are done loading.
        this.api.dispatchEvent({
            type: av.TEXTURES_LOADED_EVENT,
            model: model
        });
    };

    this.signalProgress = function(percent, progressState)
    {
        if (_progressEvent.percent === percent && _progressEvent.state === progressState)
            return;
        _progressEvent.percent = percent;
        _progressEvent.state = progressState;
        this.api.dispatchEvent(_progressEvent);
    };

    this.resize = function(w, h) {
        _needsResize = true;
        _newWidth = w;
        _newHeight = h;
    };


    this.unloadModel = function(model) {

        if (!this.removeModel(model)) {
            // model not found
            return;
        }

        if (model.loader)
            model.loader.dtor();
    };


    this._addLoadingFile = function(svfLoader) {
        if (!this.loaders) {
            this.loaders = [];
        }
        this.loaders.push(svfLoader);
    };

    this._removeLoadingFile = function(svfLoader) {
        if (this.loaders) {
            var idx = this.loaders.indexOf(svfLoader);
            if (idx >= 0) {
                this.loaders.splice(idx, 1);
            }
        }
    };


    /** Removes a model from this viewer, but (unlike unload) keeps the RenderModel usable,
     *  so that it can be added to this or other viewers later.
     *   @param {RenderModel}
     *   @returns {bool} True if the model was known and has been successfully removed.
     */
    this.removeModel = function(model) {

        if (!_modelQueue.removeModel(model)) {
            return false;
        }

        if (this.keyFrameAnimator) {
            this.keyFrameAnimator.destroy();
            this.keyFrameAnimator = null;
        }

        // Note that this just discards the GPU resources, not the model itself.
        model.dtor(this.glrenderer());

        _materials.cleanup(model);

        this.selector.removeModel(model);
        this.visibilityManager.removeModel(model);

        if (model === this.model) {
            this.model = null;

            if (!_modelQueue.isEmpty())
                this.model = _modelQueue.getModels()[0];
        }

        this.api.dispatchEvent({type: av.MODEL_UNLOADED_EVENT, model: model});

        this.invalidate(true, true, true);

        return true;
    };

    this.unloadCurrentModel = function() {
        //Before loading a new model, restore states back to what they
        //need to be when loading a new model. This means restoring transient
        //changes to the render state made when entering 2d mode,
        //like light preset, antialias and SAO settings,
        //and freeing GL objects specific to the old model.
        if (this.is2d) {
            this.is2d = undefined;
            this.selectionMaterial2d = null;
            this.removeOverlayScene("selection2d");
            _renderer.exit2DMode();

            //Restore the state, but do not actually switch it here, because
            //we don't want to spend the time on it
            //when switching from 2d to 2d. See corresponding
            //logic in addModel().
            _currentLightPreset = _oldLightPreset;
        }

        _renderer.beginScene(this.scene, this.camera, this.lightsOn ? this.lights : this.no_lights, true);
        _renderer.composeFinalFrame(true);

        // Destruct any ongoing loaders, in case the loading starts, but the model root hasn't created yet.
        if (this.loaders) {
            this.loaders.forEach(function(loader) {
                loader.dtor();
            });
            this.loaders = [];
        }

        var models = _modelQueue.getModels();
        for (var i=models.length-1; i>=0; i--)
            this.unloadModel(models[i]);
    };

    var createSelectionScene = function(name, materialPre, materialPost) {
        materialPre.depthWrite = false;
        materialPre.depthTest = true;
        materialPre.side = THREE.DoubleSide;

        materialPost.depthWrite = false;
        materialPost.depthTest = true;
        materialPost.side = THREE.DoubleSide;

        // make selection material support instanced geometry
        _materials.addInstancingSupport(materialPre);
        _materials.addInstancingSupport(materialPost);

        _this.createOverlayScene(name, materialPre, materialPost);
    };

    this.createOverlayScene = function(name, materialPre, materialPost, camera) {
        if (materialPre) {
            _materials.addOverrideMaterial(name+"_pre", materialPre);
        }

        if (materialPost) {
            _materials.addOverrideMaterial(name+"_post", materialPost);
        }

        var s = new THREE.Scene();
        s.__lights = this.scene.__lights;
        this.overlayScenes[name] = {
            scene : s,
            camera: camera,
            materialPre : materialPre,
            materialPost : materialPost
        };
    };

    this.removeOverlayScene = function (name) {

        var overlay = this.overlayScenes[name];
        if (overlay) {
            delete this.overlayScenes[name];
            this.invalidate(false, false, true);
        }
    };

    this.addOverlay = function(overlayName, mesh) {
        this.overlayScenes[overlayName].scene.add(mesh);
        this.invalidate(false, false, true);
    };

    this.addMultipleOverlays = function(overlayName, meshes) {
        for (var i in meshes) {
            if (!meshes.hasOwnProperty(i)) continue;
            this.addOverlay(overlayName, meshes[i]);
        }
    };

    this.removeOverlay = function(overlayName, mesh) {
        if (this.overlayScenes[overlayName]) {
            this.overlayScenes[overlayName].scene.remove(mesh);
            this.invalidate(false, false, true);
        }
    };

    this.removeMultipleOverlays = function(overlayName, meshes) {
        for (var i in meshes) {
            if (!meshes.hasOwnProperty(i)) continue;
            this.removeOverlay(overlayName, meshes[i]);
        }
    };

    this.clearOverlay = function(overlayName) {

        if (!this.overlayScenes[overlayName])
            return;

        var scene = this.overlayScenes[overlayName].scene;
        var obj, i;
        for (i = scene.children.length - 1; i >= 0; --i) {
            obj = scene.children[ i ];
            if (obj) {
                scene.remove(obj);
            }
        }

        this.invalidate(false, false, true);
    };

    this.setClearColors = function(r,g,b, r2, g2, b2) {
        this.clearColorTop = new THREE.Vector3(r/255.0,g/255.0,b/255.0);
        this.clearColorBottom = new THREE.Vector3(r2/255.0,g2/255.0,b2/255.0);

        //If we are using the background color as environment also,
        //create an environment map texture from the new colors
        //This is too magical and should not be necessary here -- it's done when calling setLightPreset with a light preset
        //that does not use explicit cube map.
        /*
        if (!_materials._reflectionMap || _materials._reflectionMap.isBgColor) { // TODO: don't access internal members of matman
            var cubeMap = this.loadCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
            _renderer.setCubeMap(cubeMap);
            _renderer.toggleEnvMapBackground(_envMapBackground);
            this.invalidate(true);
        }
        */

        _renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
        if (_groundReflection) _groundReflection.setClearColors(this.clearColorTop, this.clearColorBottom, av.isAndroidDevice() || av.isIOSDevice());
        _needsClear = true;
        this.fireRenderOptionChanged();
    };

    //Similar to THREE.Box3.setFromObject, but uses the precomputed bboxes of the
    //objects instead of doing it per vertex.
    var _box3;
    function computeObjectBounds(dst, object) {

        _box3 = _box3 || new THREE.Box3();

        object.updateMatrixWorld( true );

        object.traverse( function ( node ) {

            var geometry = node.geometry;

            if (geometry !== undefined && geometry.visible) {

                if (!geometry.boundingBox)
                    geometry.computeBoundingBox();

                _box3.copy(geometry.boundingBox);
                _box3.applyMatrix4(node.matrixWorld);
                dst.union(_box3);
            }

        } );
    }

    function getOverlayBounds() {
        var bounds = new THREE.Box3();
        var overlays = _this.overlayScenes;

        for (var key in overlays) {
            if (!overlays.hasOwnProperty(key))
                continue;

            computeObjectBounds(bounds, overlays[key].scene);
        }

        //Also add the root scene -- people add overlays there too
        computeObjectBounds(bounds, _this.scene);

        return bounds;
    }

    this.getVisibleBounds = function(includeGhosted, includeOverlays) {
        var result = new THREE.Box3();
        if (!_modelQueue.isEmpty()) {
            computeObjectBounds(result, this.scene);
            result = _modelQueue.getVisibleBounds(includeGhosted).union(result);

            if (includeOverlays) {
                result = getOverlayBounds().union(result);
            }
        }
        return result;
    };

    this.getFitBounds = function( ignoreSelection )
    {
        var bounds;

        // If there is a valid selection, use its bounds
        if( !ignoreSelection && this.selector !== null) {
            bounds = this.selector.getSelectionBounds();
        }

        // Otherwise, if there is a valid isolation, use its bounds
        if(!bounds || bounds.empty()) {
            bounds = this.getVisibleBounds();
        }
        //console.log("  getFitBounds bounds are " + + bounds.min.x +", "+ bounds.min.y + " to " + bounds.max.x +", "+ bounds.max.y);

        return bounds;
    };

    this.getRenderProxy = function(model, fragId) {
        //currently there is a single model so the mapping
        //of fragId to render mesh is 1:1.
        return model.getFragmentList().getVizmesh(fragId);
    };

    /**
     * Create a promise for a mesh with downloaded geometry
     * 
     * When the promise fulfills the argument to the fulfillment function is an
     * object with model and fragId properties that identify the mesh. We cannot
     * fulfill using the mesh, because it may be shared and we can't guarantee
     * execution order of independent promises.
     * 
     * Promises returned by this function can be canceled using
     * Viewer3DImpl.cancelPromisedRenderProxy(promise). A canceled promise is always
     * rejected. The canceled property of the argument to the rejection function
     * is true when a promise is canceled.
     * @param {Model} model - The model containing the fragment
     * @param {number} fragId - Fragment ID.
     * @returns {Promise} Promise for the mesh for the given fragment.
     */
    this.promiseRenderProxy = function(model, fragId) {
        //currently there is a single model so the mapping
        //of fragId to render mesh is 1:1.
        var promise = model.getFragmentList().promiseVizmesh(fragId);
        promise.lmv_model = model;
        return promise;
    };

    /**
     * Cancel a promise returned by promiseVizmesh
     * 
     * Canceled promised always rejects and the canceled property of the argument
     * to the rejection function is set to true.
     * @param {Promise} promise - Promise to be canceled
     * @returns {boolean} - True if the promise is canceled. False if it isn't canceled.
     */
    this.cancelPromisedRenderProxy = function(promise) {
        // Don't cancel a promise we didn't make
        if (!promise.lmv_model)
            return false;
        return promise.lmv_model.getFragmentList().cancelPromisedVizmesh(promise);
    };

    this.getFragmentProxy = function(model, fragId) {
        return new avp.FragmentPointer(model.getFragmentList(), fragId);
    };

    this.getRenderProxyCount = function(model) {
        return model.getFragmentList().getCount();
    };

    this.getRenderProxyDbIds = function(model, fragId) {
        return model.getFragmentList().getDbIds(fragId);
    };

    this.isWholeModelVisible = function(model) {
        return _modelQueue ? _modelQueue.areAllVisible() : true;
    };

    this.isNodeVisible = function(nodeId, model) {
        return this.visibilityManager.isNodeVisible(model, nodeId); // swapped arguments
    };

    this.highlightObjectNode = function(model, dbId, value, simpleHighlight) {

        if (model.is2d()) {
            _materials.highlightObject2D(dbId, value); //update the 2d object id texture
            this.invalidate(false, false, true);
        }

        var scope = this;
        var map = model.getData().instanceTree || model.getData().fragmentMap;

        //TODO: There can be instance tree in the case of 2D drawing, but
        //we do not currently populate the node tree with the virtual fragment ids
        //that map 2d objects to 2d consolidated meshes, hence the use of dbId2fragId in the else condition
        if (map && !model.is2d()) {

            map.enumNodeFragments(dbId, function(fragId) {
                scope.highlightFragment(model, fragId, value, simpleHighlight);
            }, false);

        } else {
            var fragId = dbId;

            if (model.is2d())
                fragId = model.getData().fragments.dbId2fragId[dbId];

            if (Array.isArray(fragId))
                for (var i=0; i<fragId.length; i++)
                    scope.highlightFragment(model, fragId[i], value, simpleHighlight);
            else
                scope.highlightFragment(model, fragId, value, simpleHighlight);

        }

    };

    this.highlightFragment = function(model, fragId, value, simpleHighlight) {

        var mesh = this.getRenderProxy(model, fragId);

        if (!mesh)
            return;

        //And also add a mesh to the overlays in case we need that.
        //For 2D that is always the case, while for 3D it's done
        //for "fancy" single-selection where we draw an outline for the object
        //as post-processing step.
        var useOverlay = !simpleHighlight || mesh.is2d || mesh.isPoint;

        var highlightId = model.id + ":" + fragId;

        if (useOverlay) {
            var overlayName = "selection";
            if (model.is2d()) overlayName += "2d";
            if (mesh.isPoint) overlayName += "_points";

            if (value)
            {
                // Make sure the geometry is in memory
                var promise = this.promiseRenderProxy(model, fragId);
                var _this = this;
                this.selectionMeshes[highlightId] = promise;
                promise.then( function(id) {
                    // OK the geometry was downloaded
                    var selectionProxy;
                    var mesh = _this.getRenderProxy(id.model, id.fragId);
                    // Make sure it all worked
                    if (!mesh || !mesh.geometry)
                        return;

                    if (mesh.isPoint) {
                        // using an override material would overwrite the point size for
                        // each point cloud, so we apply the selection colour to the
                        // duplicated geometry here instead by copying the material
                        var selectionMaterial = mesh.material.clone();
                        selectionMaterial.color = _this.selectionMaterialBase.color;
                        selectionMaterial.needsUpdate = true;
                        selectionProxy = new THREE.Mesh(mesh.geometry, selectionMaterial);
                    } else {
                        selectionProxy = new THREE.Mesh(mesh.geometry, mesh.material);
                    }

                    selectionProxy.matrix.copy(mesh.matrixWorld);
                    selectionProxy.matrixAutoUpdate = false;
                    selectionProxy.matrixWorldNeedsUpdate = true;

                    selectionProxy.frustumCulled = false;
                    selectionProxy.model = model;
                    selectionProxy.fragId = fragId;

                    id.model.getFragmentList().lockGeometry(fragId);
                    _this.addOverlay(overlayName, selectionProxy);

                    _this.selectionMeshes[highlightId] = selectionProxy;
                } ).catch( function(error) {
                    if (!error.canceled) {
                        delete _this.selectionMeshes[highlightId];
                    }
                } );
            }
            else if (this.selectionMeshes.hasOwnProperty(highlightId)) {
                var proxy = this.selectionMeshes[highlightId];
                if (proxy instanceof Promise)
                    this.cancelPromisedRenderProxy(proxy);
                else {
                    model.getFragmentList().unlockGeometry(fragId);
                    this.removeOverlay(overlayName, proxy);
                }
                delete this.selectionMeshes[highlightId];
            }
        }

        if (!useOverlay || !value) {
            //Case where highlighting was done directly in the primary render queue
            //and we need to repaint to clear it. This happens when multiple
            //nodes are highlighted using e.g. right click in the tree view
            if (model.setHighlighted(fragId, value)) //or update the vizflags in the render queue for 3D objects
                this.invalidate(true);
        }
    };

    this.explode = function(scale) {

        if(scale == _explodeScale)
            return;

        _explodeScale = scale;

        _modelQueue.explode(scale);

        //force a repaint and a clear
        this.sceneUpdated(true);

        this.api.dispatchEvent({type:av.EXPLODE_CHANGE_EVENT, scale: scale});
    };

    /**
     * Gets the last applied explode scale
     */
    this.getExplodeScale = function()
    {
        return _explodeScale;
    };


    /* simple function to set the brightness of the ghosting.
     * Simply sets another colour that is better for brighter environments
     */
    this.setGhostingBrightness = function(darkerFade)
    {
        if (darkerFade) {
            this.fadeMaterial.color = new THREE.Color(0x101010);
        }
        else {
            this.fadeMaterial.color =  new THREE.Color(0xffffff);
        }
        this.fadeMaterial.needsUpdate = true;
    };


    this.loadCubeMapFromColors = function(ctop, cbot) {
        var texture = avp.CreateCubeMapFromColors(ctop, cbot);
        texture.isBgColor = true;
        _materials.setReflectionMap(texture);
        return texture;
    };

    this.loadCubeMap = function(path, exposure) {

        this._reflectionMapPath = path;

        var mapDecodeDone = function(map) {

            //If setCubeMap was called twice quickly, it's possible that
            //a texture map that is no longer desired loads after the one that was
            //set last. In such case, just make the undesirable disappear into the void.
            if (path !== _this._reflectionMapPath)
                return;

            _materials.setReflectionMap(map);
            _this.invalidate(true);

            if (!map) {
               _this.loadCubeMapFromColors(_this.clearColorTop, _this.clearColorBottom);
            } else if (!avp.LightPresets[_currentLightPreset].useIrradianceAsBackground) {
                _renderer.setCubeMap(map);
            }
        };

        return WGS.TextureLoader.loadCubeMap(path, exposure, mapDecodeDone);
    };


    this.loadIrradianceMap = function(path, exposure) {

        this._irradianceMapPath = path;

        var mapDecodeDone = function(map) {

            //If setCubeMap was called twice quickly, it's possible that
            //a texture map that is no longer desired loads after the one that was
            //set last. In such case, just make the undesirable disappear into the void.
            if (path !== _this._irradianceMapPath)
                return;

            _materials.setIrradianceMap(map);
            _this.invalidate(true);

            if (avp.LightPresets[_currentLightPreset].useIrradianceAsBackground)
                _renderer.setCubeMap(map);
        };

        return WGS.TextureLoader.loadCubeMap(path, exposure, mapDecodeDone);

    };



    this.setLightPreset = function(index, force)
    {
        // make sure that lights are created
        if (!_lightsInitialized) {
            this.initLights();
        }

        if (_currentLightPreset === index && !force)
            return;

        // Reset index in cases the index out of range.
        // This could happen, if we update the light preset list and user
        // has a local web storage which stores the last accessed preset index which is potentially
        // out of range with respect to the new preset list.
        if (index < 0 || avp.LightPresets.length <= index) {
            index = avp.DefaultLightPreset;
        }

        _currentLightPreset = index;
        var preset = avp.LightPresets[index];

        //if the light preset has a specific background color, set that
        //This has to be done first, because the encironment map may use
        //the background colors in case no environment map is explicitly given.
        var c = preset.bgColorGradient;
        if (!c)
            c = avp.BackgroundPresets["Custom"];
        this.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5]);

        if (preset && preset.path) {

            var pathPrefix = "res/environments/" + preset.path;
            var reflPath = avp.getResourceUrl(pathPrefix + "_mipdrop." + (preset.type || "") + ".dds");
            var irrPath =  avp.getResourceUrl(pathPrefix + "_irr." + (preset.type || "") + ".dds");

            this.loadIrradianceMap(irrPath, preset.E_bias);
            this.loadCubeMap(reflPath, preset.E_bias);


            //Set exposure that the environment was baked with.
            //This has to be known at baking time and is applied
            //by the shader.
            _materials.setEnvExposure(-preset.E_bias);
            _renderer.setEnvExposure(-preset.E_bias);

            this.setTonemapExposureBias(preset.E_bias);
            this.setTonemapMethod(preset.tonemap);

            this.setGhostingBrightness(preset.darkerFade);
        }
        else {
            var cubeMap = this.loadCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
            _renderer.setCubeMap(cubeMap);
            _materials.setIrradianceMap(null);
            //_materials.setReflectionMap(cubeMap); //will be set by the loadCubeMapFromColors call

            //Set exposure that the environment was baked with.
            //This has to be known at baking time and is applied
            //by the shader.
            _materials.setEnvExposure(-preset.E_bias || 0);
            _renderer.setEnvExposure(-preset.E_bias || 0);

            this.setTonemapExposureBias(preset.E_bias || 0);
            this.setTonemapMethod(preset.tonemap || 0);

            this.setGhostingBrightness(preset.darkerFade);

            _renderer.toggleEnvMapBackground(_envMapBackground);


            this.invalidate(true);
        }


        //To begin with, get the SAO defaults from the shader uniforms definition
        //Note the scaling we apply to inverse scaling done by the setAOOptions API internally.
        //This is not pretty....
        var saoRadius = av.Shaders.SAOShader.uniforms.radius.value;
        var saoIntensity = av.Shaders.SAOShader.uniforms.intensity.value;

        //Check if the preset overrides the SAO settings
        if (preset.hasOwnProperty("saoRadius"))
            saoRadius = preset.saoRadius;
        if (preset.hasOwnProperty("saoIntensity"))
            saoIntensity = preset.saoIntensity;
        _renderer.setAOOptions(saoRadius, saoIntensity);

        var lightIntensity = _defaultLightIntensity;
        if (preset.lightMultiplier !== null && preset.lightMultiplier !== undefined) {
            lightIntensity = preset.lightMultiplier;
        }

        // init primary light direction used for shadows
        _shadowLightDir.copy(_shadowLightDirDefault);
        if (preset.lightDirection) {
            // The presets describe the direction away from the light, while _shadowLightDir
            // is the direction pointing to the light.
            _shadowLightDir.fromArray(preset.lightDirection).negate();
        }

        // changing the shadow light direction invalidates the shadow-map
        if (_shadowMaps) {
            invalidateShadowMap();
        }

        if (this.dir_light1) {
            this.dir_light1.intensity = lightIntensity;

            if (preset.lightDirection) {
                this.dir_light1.position.set( -preset.lightDirection[0], -preset.lightDirection[1], -preset.lightDirection[2] );
            } else {
                // set to default, otherwise the environment will inherit the direction from whatever previous environment was chosen
                this.dir_light1.position.copy( _lightDirDefault );
            }

        }

        _materials.setEnvRotation(preset.rotation || 0.0);
        _renderer.setEnvRotation(preset.rotation || 0.0);

        if (_groundReflection) _groundReflection.setEnvRotation(preset.rotation || 0.0);

        // toggle lights on/off based on lightMultiplier
        this.toggleLights(lightIntensity !== 0.0);

        this.invalidate(true, false, true);

        this.fireRenderOptionChanged();
    };

    this.setLightPresetFromFile = function(model)
    {
        if (!model || model.is2d()) {
            return false;
        }

        var style = model.getMetadata('renderEnvironmentStyle', 'value', null);
        if ((style === null) || (style ===""))
            return false;

        // TODO add more control for environments
        // the user cannot set anything expect the style from current UI
        // currently only the style can be selected.
        // TODO We cannot control these values so comment out for now
        var grndReflection = model.getMetadata('renderEnvironmentGroundReflection', 'value', null);
        if (grndReflection !== null) {
            if (this.api.prefs.hasTag('groundReflection', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): groundReflection is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'groundReflection');
                this.api.setGroundReflection(grndReflection);
            }
        }

        var grndShadow = model.getMetadata('renderEnvironmentGroundShadow', 'value', null);
        if (grndShadow !== null) {
            if (this.api.prefs.hasTag('groundShadow', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): groundShadow is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'groundShadow');
                this.api.setGroundShadow(grndShadow);
            }
        }
        var ambientShadows = model.getMetadata('renderEnvironmentAmbientShadows', 'value', null);
        if (ambientShadows !== null) {
            if (this.api.prefs.hasTag('ambientShadows', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): ambientShadows is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'ambientShadows');
                // kludgey, but maintains previous API linking these two different algorithms together
                this.api.setQualityLevel(ambientShadows, _renderer.getAntialiasing());
            }
        }
        var displayLines = model.getMetadata('renderEnvironmentDisplayLines', 'value', null);
        if (displayLines !== null) {
            if (this.api.prefs.hasTag('lineRendering', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): lineRendering is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'lineRendering');
                this.api.hideLines(!displayLines);
            }
        }
        var displayPoints = model.getMetadata('renderEnvironmentDisplayPoints', 'value', null);
        if (displayPoints !== null) {
            if (this.api.prefs.hasTag('pointRendering', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): pointRendering is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'pointRendering');
                this.api.hidePoints(!displayPoints);
            }
        }


        var preset = avp.LightPresets.filter(function(lightPreset){
            return lightPreset.name === style;
        });
        preset = preset[0] || null;
        if (preset) {
            if (this.api.prefs.hasTag('lightPreset', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): lightPreset is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'lightPreset');

                // Create an env based on an existing preset
                // and add it at the end of the official list
                var env = avp.ModelSettingsEnvironment;
                if (!env) {
                    env = avp.ModelSettingsEnvironment = {};
                    avp.LightPresets.push(env);
                }

                // Copy existing Preset into custom Model-Loaded preset
                avp.copyLightPreset(preset, env);

                // Override Name for use in UI
                env.name = '(Custom: Model defined)'; // TODO: Localize

                // Override Environment Exposure Values
                var exposureBias = model.getMetadata('renderEnvironmentExposureBias', 'value', null);
                var exposureBase = model.getMetadata('renderEnvironmentExposureBase', 'value', null);
                if (exposureBias !== null && exposureBase !== null ) {
                    env.E_bias = exposureBias + exposureBase;
                }

                // Override Environment Background Color
                // Note that there's a specific preset for background color
                var bgColor = model.getMetadata('renderEnvironmentBackgroundColor', 'value', null);
                if (this.api.prefs.hasTag('backgroundColorPreset', 'ignore-producer')) {
                    avp.logger.debug('setLightPresetFromFile(): backgroundColorPreset is locked. No changes.');
                } else if (bgColor) {
                    env.bgColorGradient = [
                        255.0 * bgColor[0], 255.0 * bgColor[1], 255.0 * bgColor[2],
                        255.0 * bgColor[0], 255.0 * bgColor[1], 255.0 * bgColor[2]
                    ];
                }

                // Override Environment Rotation
                var envRotation = model.getMetadata('renderEnvironmentRotation', 'value', null); //assumed radians
                if (envRotation !== null) {
                    env.rotation = envRotation;
                }

                var i = avp.LightPresets.indexOf(env);
                this.setLightPreset(i, true);
            }
        }

        var bgEnvironment = model.getMetadata('renderEnvironmentBackgroundFromEnvironment', 'value', null);
        if (bgEnvironment !== null) {
            if (this.api.prefs.hasTag('envMapBackground', 'ignore-producer')) {
                avp.logger.debug('setLightPresetFromFile(): envMapBackground is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'envMapBackground');
                this.api.setEnvMapBackground(bgEnvironment);
            }
        }

        // Important to return the model defined preset
        return preset;
    };

    this.setLightPresetForAec = function() {

        //Find the AEC light preset
        var presetName = avp.DefaultLightPresetAec || "Boardwalk";
        var idx = -1;
        for (var i=0; i<avp.LightPresets.length; i++) {
            if (avp.LightPresets[i].name === presetName) {
                idx = i;
                break;
            }
        }

        if (idx >= 0) {
            if (this.api.prefs.hasTag('lightPreset', 'ignore-producer')) {
                avp.logger.debug('setLightPresetForAec(): lightPreset is locked. No changes.');
            } else {
                this.api.prefs.tag('no-storage', 'lightPreset');

                this.setLightPreset(idx, true);
            }
        }


        //If allowed, display the environment as background (most likely the irradiance map will be used
        //by the AEC presets, so it will be almost like a color gradient)
        if (this.api.prefs.hasTag('envMapBackground', 'ignore-producer')) {
            avp.logger.debug('setLightPresetForAec(): envMapBackground is locked. No changes.');
        } else {
            this.api.prefs.tag('no-storage', 'envMapBackground');
            this.api.setEnvMapBackground(true);
        }

        //If allowed, display edge topology
        if (this.api.prefs.hasTag('edgeRendering', 'ignore-producer')) {
            avp.logger.debug('setLightPresetForAec(): edgeRendering is locked. No changes.');
        } else {
            this.api.prefs.tag('no-storage', 'edgeRendering');
            this.api.setDisplayEdges(!av.isMobileDevice());
        }


        return true;
    };


    this.setAOHeuristics = function(model) {

        //Decide on what SSAO settings to use.

        //TODO: it may be better to integrate SAO settings into the
        //environment/light preset, however this would require knowledge of the model units.
        //Starting to take into account the units for existing data would change the AO
        //that people are used to seeing, so the choice here is to only take into account
        //units

        if (model.isAEC()) {
            var metersPerModelUnit = model.getUnitScale();
            var largeRadius = (metersPerModelUnit > 0.3);

            if (largeRadius) {
                //AEC model in meters or feet -- probably building
                //use room-sized radius
                _renderer.setAOOptions(4.0 / metersPerModelUnit, 1.0, 0.625);
            } else {
                //AEC model in inches or cm -- most likely a factory floor with lots
                //of small things / pipes / nuts / bolts, use smaller radius.
                _renderer.setAOOptions(0.25 / metersPerModelUnit, 1.0, 0.625);
            }
        } else {

            // Compute a rough size for the model, so that we can set a reasonable AO radius.
            // This simple approach is reasonable for mechanical models, but is probably too
            // large a value for architectural models, where the viewer is inside the model
            // and so the model itself is relatively large compared to the viewer.
            var bbox = model.getData().bbox;
            var diagonalLength = bbox.size().length();

            // 10 works well as a default for most models, including
            // architectural scenes. Surprising! But, for small models,
            // where for some reason the model is not in "human-sized units",
            // 0.05 says the ambient occlusion should extend 5% of the
            // diagonal length of the model.
            // The 10 here should match the SAOShader.js radius of 10.
            _renderer.setAOOptions(Math.min(10.0,0.05*diagonalLength));

        }


    };


    this.setTonemapMethod = function (index) {

        if (index == _renderer.getToneMapMethod())
            return;

        _renderer.setTonemapMethod(index);
        _materials.setTonemapMethod(index);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };

    this.setTonemapExposureBias = function (bias) {

        if (bias == _renderer.getExposureBias())
            return;

        _renderer.setTonemapExposureBias(bias);
        _materials.setTonemapExposureBias(bias);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };


    /**
     * Unloads model, frees memory, as much as possible.
     */
    this.dtor = function() {
        window.cancelAnimationFrame(_reqid);

        this.api.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, _memoryLimit);
        this.api.removeEventListener(av.MODEL_UNLOADED_EVENT, _memoryLimit);

        this.unloadCurrentModel();

        // this.controls is uninitialized by Viewer3D, since it was initialized there
        this.controls = null;
        this.canvas = null;

        this.loader = null;

        this.selector.dtor();
        this.selector = null;

        this.model = null;
        this.visibilityManager = null;

        _modelQueue = null;
        _renderer = null;
        _materials.dtor();
        _materials = null;
    };

    this.hideLines = function(hide){
        if (_modelQueue && !_modelQueue.isEmpty()) {
            _modelQueue.hideLines(hide);
            this.sceneUpdated(true);
            return true;
        }
        return false;
    };

    this.hidePoints = function(hide){
        if (_modelQueue && !_modelQueue.isEmpty()) {
            _modelQueue.hidePoints(hide);
            this.sceneUpdated(true);
            return true;
        }
        return false;
    };

    this.setDisplayEdges = function(show) {

        _renderer.toggleEdges(show);

        //If edges are turned off, turn off polygon offset also.
        //Except if the model has line geometries in the scene, then do not turn off
        //polygon offset.
        var needsPO = show;

        if (!show) {
            // return false, not undefined
            needsPO = !!(this.model && this.model.getData().hasLines);
        }

        _materials.togglePolygonOffset(needsPO);
        _renderer.setDepthMaterialOffset(_materials.getPolygonOffsetOn(), _materials.getPolygonOffsetFactor(), _materials.getPolygonOffsetUnits());

        this.invalidate(true);
    };

    this.getCutPlanes = function() {
        return _materials.getCutPlanes();
    };

    this.setCutPlanes = function(planes) {
        _materials.setCutPlanes(planes);
        this.sceneUpdated();
        this.api.dispatchEvent({type:av.CUTPLANES_CHANGE_EVENT, planes: planes});
    };

    this.fireRenderOptionChanged = function() {

        //If SAO is changing and we are using multiple
        //render targets in the main material pass, we have
        //to update the materials accordingly.
        _materials.toggleMRTSetting(_renderer.mrtFlags());

        this.api.dispatchEvent({type:av.RENDER_OPTION_CHANGED_EVENT});
    };

    this.viewportToRay = function(vpVec, ray) {
        var camera = this.camera;

        // set two vectors with opposing z values
        vpVec.z = -1.0;
        var end = new THREE.Vector3( vpVec.x, vpVec.y, 1.0 );
        vpVec = vpVec.unproject(camera);
        end = end.unproject( camera );

        // find direction from vector to end
        end.sub( vpVec ).normalize();

        if (!ray)
            ray = new THREE.Ray();

        ray.set(!camera.isPerspective ? vpVec : camera.position, end);

        return ray;
    };

    // Add "meshes" parameter, after we get meshes of the object using id buffer,
    // then we just need to ray intersect this object instead of all objects of the model.
    this.rayIntersect = function(ray, ignoreTransparent, dbIds, modelIds, intersections) {
        var result = _modelQueue.rayIntersect(ray.origin, ray.direction, ignoreTransparent, dbIds, modelIds, intersections);

        if (this.sceneAfter.children.length) {
            var raycaster = new THREE.Raycaster(ray.origin, ray.direction, this.camera.near, this.camera.far);
            var intersects = [];
            avp.VBIntersector.intersectObject(this.sceneAfter, raycaster, intersects, true);

            if (intersects.length) {
                if (!result || intersects[0].distance < result.distance) {
                    result = intersects[0];
                }
            }
        }

        if (!result)
            return null;

        var fragId = result.fragId,
            intersectPoint = result.point,
            face = result.face,
            model = result.model;

        var dbId = result.dbId;
        if (dbId === undefined && fragId !== undefined /* 0 is a valid fragId */) {

            dbId = model.getFragmentList().getDbIds(fragId);
            var fragmentMap = model.getData().instanceTree || model.getData().fragmentMap;

            if (!fragmentMap) {
                //Case where there is no dbid to fragment id map. Create a 'virtual' node
                //with node Id = fragment Id, so that selection works like
                //each scene fragment is a scene node by itself.
                dbId = fragId;
            }
        }

        return { dbId: dbId, fragId: fragId, "intersectPoint":intersectPoint, "face":face, "model":model };
    };

    this.castRayViewport = function() {

        var _ray;

        // Add "meshes" parameter, after we get meshes of the object using id buffer,
        // then we just need to ray intersect this object instead of all objects of the model.
        return function (vpVec, ignoreTransparent, dbIds, modelIds, intersections) {

            _ray = _ray || new THREE.Ray();

            if (!_modelQueue) {
                return {};
            }

            this.viewportToRay(vpVec, _ray);

            return this.rayIntersect(_ray, ignoreTransparent, dbIds, modelIds, intersections);
        };

    }();

    this.clientToViewport = function (clientX, clientY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            ((clientX + 0.5) / rect.width) * 2 - 1,
           -((clientY + 0.5) / rect.height) * 2 + 1, 1 );
    };

    this.viewportToClient = function (viewportX, viewportY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            (viewportX + 1) * 0.5 * rect.width  - 0.5,
            (viewportY - 1) *-0.5 * rect.height - 0.5, 0 );
    };

    this.castRay = function (clientX, clientY, ignoreTransparent) {
        // Use the offsets based on the client rectangle, which is relative to the browser's client
        // rectangle, unlike offsetLeft and offsetTop, which are relative to a parent element.
        //
        return this.castRayViewport(this.clientToViewport(clientX, clientY),ignoreTransparent);
    };


    this.intersectGroundViewport = function(vpVec) {

        var camera = this.camera;

        var worldUp = "z";

        //In 2D mode, the roll tool can be used to change the orientation
        //of the sheet, which will also set the world up vector to the new orientation.
        //However, this is not what we want in case of a 2d sheet -- its ground plane is always Z.
        //TODO: It's not clear if checking here or in setWorldUp is better. Also I don't see
        //a way to generalize the math in a way to make it work without such check (e.g. by using camera up only).
        if (!this.is2d) {
            worldUp = _worldUpName;
        }

        var vector = vpVec;

        // set two vectors with opposing z values
        vector.z = -1.0;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
        vector = vector.unproject( camera );
        end = end.unproject( camera );

        // find direction from vector to end
        end.sub( vector ).normalize();

        var dir = end;

        //Is the direction parallel to the ground plane?
        //Then we fail.
        if (Math.abs(dir[worldUp]) < 1e-6)
            return null;

        var rayOrigin;
        if (camera.isPerspective) {
            rayOrigin = camera.position;
        }
        else {
            rayOrigin = vector;
        }

        var baseElev = this.model ? this.model.getBoundingBox().min[worldUp] : 0;

        var distance = (baseElev - rayOrigin[worldUp]) / dir[worldUp];

        //2D drawing, intersect the plane
        dir.multiplyScalar(distance);
        dir.add(rayOrigin);

        return dir;
    };

    this.intersectGround = function(clientX, clientY) {
        return this.intersectGroundViewport(this.clientToViewport(clientX, clientY));
    };


    this.hitTestViewport = function(vpVec, ignoreTransparent) {

        var result;

        if (_this.is2d) {

            var dbId;
            var ids = [];
            if (av.isMobileDevice()) {
                // Set the detection area to 44*44 pixel rectangle according to Apple's iOS Human Interface Guidelines
                dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 45, ids);
            }
            else {
                // Set the detection area to 5*5 pixel search rectangle
                dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 5, ids);
            }

            if (dbId <= 0)
                return null;

            //Note this function will destructively modify vpVec,
            //so it's unusable after that.
            var point = this.intersectGroundViewport(vpVec);

            var model = _modelQueue.findModel(ids[1]) || _this.model;

            //var node = dbId ? { dbId : dbId, fragIds : _this.model.getData().fragments.dbId2fragId[dbId] } : null;
            result = {
                intersectPoint : point,
                dbId : dbId,
                fragId : model.getData().fragments.dbId2fragId[dbId],
                model : model
            };
        }
        else {

            result = this.castRayViewport(vpVec, ignoreTransparent);

        }

        return result;
    };


    this.hitTest = function(clientX, clientY, ignoreTransparent) {

        return _this.hitTestViewport(this.clientToViewport(clientX, clientY), ignoreTransparent);

    };

    this.snappingHitTestViewport = function(vpVec, ignoreTransparent) {

        var result, point, dbId;

        if (this.model && this.model.getData().isLeaflet) {
            point = this.intersectGroundViewport(vpVec);
            result = { intersectPoint : point };
        }
        else if (_this.is2d) {

            if (av.isMobileDevice()) {
                //Set the detection area to 44*44 pixel rectangle according to Apple's iOS Human Interface Guidelines
                //Notice: The amount of pixels per line should correspond to pixelSize in setDetectRadius of Snapper.js,
                //the shape of detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
                dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 101);
            }
            else {
                //Notice: The amount of pixels per line should correspond to pixelSize in setDetectRadius of Snapper.js,
                //the shape of detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.
                dbId = _renderer.idAtPixels(vpVec.x, vpVec.y, 17);
            }

            // Need to do hitTest in snapping when dbId = 0
            if (dbId < 0)
                return null;

            //Note this function will destructively modify vpVec,
            //so it's unusable after that.
            point = this.intersectGroundViewport(vpVec);

            // get fragment ID if there is a fragment list
            var fragments = _this.model.getData().fragments;
            var fragId    = (fragments ? fragments.dbId2fragId[dbId] : -1);

            //var node = dbId ? { dbId : dbId, fragIds : _this.model.getData().fragments.dbId2fragId[dbId] } : null;
            result = { intersectPoint : point, dbId : dbId, fragId : fragId };

            if (dbId) {
                //result.node = ... get the node for the dbId here
            }

        }
        else {

            dbId = _renderer.idAtPixel(vpVec.x, vpVec.y);

            result = this.castRayViewport(vpVec, ignoreTransparent, dbId > 0 ? [dbId] : null);

        }

        return result;
    };

    // Used for snapping
    // firstly, find the intersect object using pre-computed ID buffer
    // secondly, find the intersect point and face using intersection test
    this.snappingHitTest = function(clientX, clientY, ignoreTransparent) {

        return this.snappingHitTestViewport(this.clientToViewport(clientX, clientY), ignoreTransparent);
    };

    //Used for rollover highlighting using pre-computed ID buffer
    //Currently only the 2D code path can do this.
    this.rolloverObjectViewport = function(vpVec) {

        //Not supported for 3d.
        //if (!this.is2d)
        //    return;

        if (_renderer.rolloverObjectViewport(vpVec.x, vpVec.y))
            this.invalidate(false, false, true);
    };

    this.rolloverObject = function(clientX, clientY) {

        if (!this.rolloverDisabled)
            this.rolloverObjectViewport(this.clientToViewport(clientX, clientY));
    };

    this.disableRollover = function(disable) {

        this.rolloverDisabled = disable;
        if (disable) {
            _renderer.rolloverObjectId(-1);
            this.invalidate(false, false, true);
        }
    };

    this.rolloverObjectNode = function(dbId) {

        var dbIds = [];
        var it = _this.model.getData().instanceTree;

        if (it) {

            it.enumNodeChildren(dbId, function(childId) {
                dbIds.push(childId);
            }, true);

            // Sort the array to get the dbIds range, it should exclude the first node which
            // is local root, since its dbId may not be serial number like its descendants.
            if (dbIds.length > 1) {
                var temp = dbIds.shift();
                dbIds.sort(function(a,b) {return a-b;});
                dbIds.unshift(temp);
            }

        }
        else {
            dbIds.push(dbId);
        }

        if (_renderer.rolloverObjectViewport(null, null, dbIds))
            this.invalidate(false, false, true);
    };

    // https://github.com/ebidel/filer.js/blob/master/src/filer.js
    function dataURLToBlob(dataURL) {
        var BASE64_MARKER = ';base64,';
        var parts, contentType, raw;
        if (dataURL.indexOf(BASE64_MARKER) == -1) {
            parts = dataURL.split(',');
            contentType = parts[0].split(':')[1];
            raw = decodeURIComponent(parts[1]);

            return new Blob([raw], {type: contentType});
        }

        parts = dataURL.split(BASE64_MARKER);
        contentType = parts[0].split(':')[1];
        raw = window.atob(parts[1]);
        var rawLength = raw.length;

        var uInt8Array = new Uint8Array(rawLength);

        for (var i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }

        return new Blob([uInt8Array], {type: contentType});
    }

    //this function get a blob object
    this.getScreenShotBuffer = function (w, h, cb) {
        _renderer.presentBuffer();
        var blobobj = _this.canvas.toDataURL("image/png");

        var flip = av.isSafari();
        flip |= av.isIOSDevice();
        if (flip) {
            w = w ? w : _newWidth;
            h = h ? h : _newHeight;
        }

        if (!w || !h)
            return blobobj;

        // calc resize and center
        var nw, nh, nx = 0, ny = 0;
        if (w > h || (_newWidth / _newHeight < w / h)) {
            nw = w;
            nh = _newHeight / _newWidth * w;
            ny = h / 2 - nh / 2;
        }
        else {
            nh = h;
            nw = _newWidth / _newHeight * h;
            nx = w / 2 - nw / 2;
        }

        var blobURL = window.URL.createObjectURL(dataURLToBlob(_this.canvas.toDataURL("image/png")));
        // new image from blobURL
        var img = new Image();
        img.src = blobURL;

        // create working canvas
        var tmpCanvas = document.createElement("canvas");
        var ctx = tmpCanvas.getContext("2d");
        tmpCanvas.width = w;
        tmpCanvas.height = h;

        // draw image on canvas
        img.onload = function () {
            if (flip) {
                ctx.translate(0, nh);
                ctx.scale(1,-1);
            }
            ctx.drawImage(img, nx, ny, nw, nh);
            var newobj = tmpCanvas.toDataURL("image/png");
            var newBlobURL = window.URL.createObjectURL(dataURLToBlob(tmpCanvas.toDataURL("image/png")));
            if (cb)
                cb(newobj);
            else
                window.open(newBlobURL);
        };
    };

    // we use Blob URL, Chrome crashes when opening dataURL that is too large
    // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
    this.getScreenShot = function(w, h, cb) {

        function reframeBlob(blobURL, w, h, flip, cb) {

            if (!flip && (!w || !h)) {
                cb && cb(blobURL);
            } else {
                // calc resize and center
                var nw, nh, nx = 0, ny = 0;
                if (w > h || (_newWidth/_newHeight < w/h)) {
                    nw = w;
                    nh = _newHeight/_newWidth * w;
                    ny = h/2 - nh/2;
                }
                else {
                    nh = h;
                    nw = _newWidth/_newHeight * h;
                    nx = w/2 - nw/2;
                }

                // new image from blobURL
                var img = new Image();
                img.src = blobURL;

                // create working canvas
                var tmpCanvas = document.createElement("canvas");
                var ctx = tmpCanvas.getContext("2d");
                tmpCanvas.width = w;
                tmpCanvas.height = h;

                // draw image on canvas
                img.onload = function() {
                    if (flip) {
                        ctx.translate(0, nh);
                        ctx.scale(1,-1);
                    }
                    ctx.drawImage(img, nx, ny, nw, nh);
                    var newBlobURL = window.URL.createObjectURL(dataURLToBlob(tmpCanvas.toDataURL("image/png")));
                    if (cb) {
                        cb(newBlobURL);
                    } else {
                        window.open(newBlobURL);
                    }
                };
            }
        }

        _renderer.presentBuffer();
        var blobURL = window.URL.createObjectURL(dataURLToBlob(_this.canvas.toDataURL("image/png")));

        // It seems there is not a better way to detect if the resulting image needs to be flipped.
        var flip = av.isSafari();
        flip |= av.isIOSDevice();
        if (flip) {
            w = w ? w : _newWidth;
            h = h ? h : _newHeight;
        }

        reframeBlob(blobURL, w, h, flip, cb);
    };

    //This accessor is only used for debugging purposes a.t.m.
    this.modelQueue = function() { return _modelQueue; };

    this.glrenderer = function() { return _webglrender; };

    this.renderer = function() { return _renderer; };

    // only for debugging purposes
    this.shadowMaps = function() { return _shadowMaps; };

    this.worldUp = function() { return _worldUp; };
    this.worldUpName = function() { return _worldUpName; };

    this.setUserRenderContext = function(ctx) {
        _renderer = (ctx) ? ctx : new avp.RenderContext();
        _renderer.init(_webglrender, this.canvas.clientWidth, this.canvas.clientHeight);
        _renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
        this.invalidate(true);
        this.sceneUpdated(false); //to reset world boxes needed by new RenderContext for shadows, etc
    };

    this.invalidate = function(needsClear, needsRender, overlayDirty) {
        _needsClear = needsClear || _needsClear;
        _needsRender = needsRender || _needsRender;
        _overlayDirty = overlayDirty || _overlayDirty;
    };

    // needed for command system
    this.isOverlayDirty = function() {
        return _overlayDirty;
    };

    this.clearOverlayDirtyFlag = function() {
        _overlayDirty = false;
    };

    this.sceneUpdated = function(objectsMoved) {

        this.invalidate(true, false, true);

        // Mark the scene bounds for update
        if (_modelQueue && objectsMoved){
            _modelQueue.invalidateVisibleBounds();
            this.zoomBoundsChanged = true;
        }

        _sceneDirty = true;

        invalidateShadowMap();
    };

    // immediately restart rendering, make it interruptible like progressive, displaying only when done
    this.requestSilentRender = function() {
        _deferredSilentRender = _immediateSilentRender = true;
    };

    // restart rendering only when the previous render is done, make it interruptible like progressive, itself displaying only when done
    this.requestDeferredSilentRender = function() {
        _deferredSilentRender = true;   // but not immediate
    };

    this.currentLightPreset = function() { return _currentLightPreset; };

    this.matman = function() { return _materials; };

    this.fps = function() { return 1000.0 / _frameTimeAvg; };

    this.setFPSTargets = function(min, target, max) {
        MAX_FRAME_BUDGET = 1000 / max;
        MIN_FRAME_BUDGET = 1000 / min;
        TARGET_FRAME_TIME = 1000 / target;
        // TODO mismatch! Why / 4 here, and / 2 below (search on targetFrameBudget)?
        this.targetFrameBudget = av.isMobileDevice() ? TARGET_FRAME_TIME / 4 : TARGET_FRAME_TIME;
    };

    //========================================================================


    // Record fragments transformation in explode mode for RaaS rendering
    //this.fragTransformConfig = [];

    this.track = function(event) {
        avp.logger.track(event);
    };

    this.worldToClient = function(point) {
        var p = new THREE.Vector4(point.x, point.y, point.z, 1);
        p.applyMatrix4(this.camera.matrixWorldInverse);
        p.applyMatrix4(this.camera.projectionMatrix);

        // Don't want to mirror values with negative z (behind camera)
        if (p.w > 0)
        {
            p.x /= p.w;
            p.y /= p.w;
            p.z /= p.w;
        }

        return this.viewportToClient(p.x, p.y);
    };

    this.clientToWorld = function(clientX, clientY, ignoreTransparent) {

        var result = null;
        var model = this.model;
        var modelData = model.getData();

        if (model.is2d()) {

            var collision = this.intersectGround(clientX, clientY);
            if (collision) {
                collision.z = 0;
                var bbox = modelData.bbox;
                if (modelData.hidePaper || bbox.containsPoint(collision)) {
                    result = {
                        point: collision,
                        model: model
                    };
                }
            }
        } else {

            // hitTest handles multiple scenes
            result = this.hitTest(clientX, clientY, ignoreTransparent);
            if (result) {
                result.point = result.intersectPoint; // API expects attribute point to have the return value too.
            }
        }

        return result;
    };

    /**
     *
     * @param {THREE.Color} color
     * @param {number} selectionType 
     */
    this.setSelectionColor = function(color, selectionType) {
        selectionType = selectionType || Autodesk.Viewing.SelectionType.MIXED;
        var emissive = new THREE.Color(color);
        emissive.multiplyScalar(0.5);
        switch(selectionType) {
            default:
            case Autodesk.Viewing.SelectionType.MIXED:
                this.selectionMaterialBase.color.set(color);
                this.selectionMaterialTop.color.set(color);
                this.selectionMaterialBase.emissive.set(emissive);
                this.selectionMaterialTop.emissive.set(emissive);
                _renderer.setSelectionColor(color);
                this.highlightMaterial.color.set(color);
                this.highlightMaterial.emissive.set(emissive);
                this.invalidate(true);
                break;
            case Autodesk.Viewing.SelectionType.REGULAR:
                this.highlightMaterial.color.set(color);
                this.highlightMaterial.emissive.set(emissive);
                this.invalidate(true);
                break;
            case Autodesk.Viewing.SelectionType.OVERLAYED:
                this.selectionMaterialBase.color.set(color);
                this.selectionMaterialTop.color.set(color);
                this.selectionMaterialBase.emissive.set(emissive);
                this.selectionMaterialTop.emissive.set(emissive);
                _renderer.setSelectionColor(color);
                this.invalidate(false, false, true);
                break;
        }
    };

    // Update the viewport Id for the first selection in 2d measure
    this.updateViewportId = function(vpId) {
        _materials.updateViewportId(vpId);
        this.invalidate(true);
    };

    /**
     *  @param   {number} id
     *  @returns {RenderModel|null}
     */
    this.findModel = function(modelId) {
        return _modelQueue.findModel(modelId);
    };

    // get/set frame rate for progressive rendering, i.e, how many ticks go by before an update occurs
    /**
     *  @returns {number}
     */
    this.getFrameRate = function() {
        return this.frameDisplayRate;
    };

    /**
     *  @param   {number} rate
     */
    this.setFrameRate = function(rate) {
        // don't let rate < 1, just in case user sets 0.
        this.frameDisplayRate = (rate<1) ? 1 : rate;
    };

    /**
     *  For shadow casting, we assume a single directional light. Shadow light direction is the direction
     *  that this light comes from, i.e., shadows are casted to the opposite direction.
     *  This function changes the direction and triggers a shadow update.
     *
     *  Note that the directional light source is only assumed for shadow casting. The actual lighting usually comes from
     *  several directions when using environment lighting, but we need a fixed direction for shadow mapping.
     *
     *   @param {THREE.Vector3} lightDir - direction in world space
     */
    this.setShadowLightDirection = function(lightDir) {
        _shadowLightDir.copy(lightDir);
        invalidateShadowMap();
        this.invalidate(true, false, false);

        // update ground transform to make sure that the ground shape is large enough
        // to make the whole shadow visible.
        updateGroundTransform();
    };

    /**
     *  The result is either returned as a new vector or written to 'target' (if specified)
     *  @param [THREE.Vector3} [target]
     *  @returns {THREE.Vector3} Either target object or new Vector3 instance.
     */
    this.getShadowLightDirection = function(target) {
        var dir = (target ? target : new THREE.Vector3());
        dir.copy(_shadowLightDir);
        return dir;
    };

    /**
     * @param {Bool} enable
     * Note that viewer must be initialized first.
     */
    this.toggleShadows = function(enable) {
        if (!!_shadowMaps == !!enable) {
            // no change
            return;
        }

        if (enable) {
            _shadowMaps = new avp.ShadowMaps(_webglrender);
        } else {
            _shadowMaps.cleanup(_materials);
            _shadowMaps = null;
        }

        // Adjust ground plane box if the shadows are getting turned on.
        updateGroundTransform();

        this.invalidate(true, true, false);
    };

    this.showTransparencyWhenMoving = function(enabled) {
        _modelQueue.enableNonResumableFrames = enabled;
    };


    this.fitToView = function(objectIds, model, immediate) {
        
        model = model || this.model;
        immediate = immediate || false;

        // We currently allow fit to view to work even if the model
        // is not fully loaded.
        if (!model)
            return false;

        var theEvent = { 
            type: av.FIT_TO_VIEW_EVENT,
            nodeIdArray: objectIds,
            immediate: immediate,
            model: model 
        };

        var that = this;

        function find2DBounds(model, fragId, dbId, bc)
        {
            var mesh = model.getFragmentList().getVizmesh(fragId);
            var vbr = new avp.VertexBufferReader(mesh.geometry);
            vbr.enumGeomsForObject(dbId, bc);
        }

        function find2DLayerBounds(model, fragId, bc)
        {
            var mesh = model.getFragmentList().getVizmesh(fragId);
            var vbr = new avp.VertexBufferReader(mesh.geometry);
            var visibleLayerIds = that.getVisibleLayerIds();
            vbr.enumGeomsForVisibleLayer(visibleLayerIds, bc);
        }

        var _fit = function(){
            var fitTo = null;
            if( Array.isArray(objectIds) && (objectIds.length > 0) )
            {
                var bounds = new THREE.Box3();
                var box = new THREE.Box3();

                var fragmentMap = model.getFragmentMap();
                var fragList = model.getFragmentList();

                // best to not define this inside the loop itself, acc. to jshint
                var addBox = function(fragId) {
                        fragList.getWorldBounds(fragId, box);
                        bounds.union(box);
                    };
                for (var i=0; i<objectIds.length; i++) {
                    fragmentMap.enumNodeFragments(objectIds[i], addBox, true);
                }

                if( !bounds.empty() )
                    fitTo = bounds;
            }
            if( !fitTo || fitTo.empty() )
                fitTo = that.getFitBounds();

            that.api.navigation.fitBounds(immediate, fitTo);
            that.api.dispatchEvent( theEvent );
        };

        // This doesn't guarantee that an object tree will be created but it will be pretty likely
        var bounds, bc, i;
        if (objectIds && objectIds.length > 0) {
            if (model.is2d()) {
                // objectIds list is array of dbids. Go through list and find bounds.

                /*
                FragmentList.dbid2fragId[dbid] will return the fragment id or an array of fragment ids
                that contain geometry for the dbid.
                Loop through the fragments and get the geometry for each fragment.
                Create a VertexBufferReader using the geometry.
                Use the VertexBufferReader to find the geometry for a dbid.

                To find the geometry we use VertexBufferReader.enumGeomsForObject(dbid, callback).
                It uses a callback object to enumerate geometry for a dbid. The callback object needs these
                optional functions:

                onLineSegment(x0, y0, x1, y1, viewport_id)
                onCircularArc(centerX, centerY, startAngle, endAngle, radius, viewport_id)
                onEllipticalArccenterX, centerY, startAngle, endAngle, major, minor, tilt, viewport_id)
                onOneTriangle(x1, y1, x2, y2, x3, y3, viewport_id)
                etc.

                We use the VertexBufferReader to loop through the geometry in the
                buffer looking for the dbid.
                */

                bounds = new THREE.Box3();
                // move this next one up into the calling method
                bc = new avp.BoundsCallback(bounds);

                var dbId2fragId = model.getData().fragments.dbId2fragId;

                for (i=0; i<objectIds.length; i++) {
                    var fragIds = dbId2fragId[objectIds[i]];
                    // fragId is either a single vertex buffer or an array of vertex buffers
                    if (Array.isArray(fragIds)) {
                        for (var j=0; j<fragIds.length; j++) {
                            // go through each vertex buffer, looking for the object id
                            find2DBounds(model, fragIds[j], objectIds[i], bc);
                        }
                    } else if (typeof fragIds === 'number') {
                        // go through the specific vertex buffer, looking for the object id
                        find2DBounds(model, fragIds, objectIds[i], bc);
                    }
                }
                // should have some real box at this point; check
                if ( !bounds.empty()) {
                    //console.log("selected bounds are " + bounds.min.x +", "+ bounds.min.y + " to " + bounds.max.x +", "+ bounds.max.y);
                    this.api.navigation.fitBounds(immediate, bounds);
                    this.api.dispatchEvent( theEvent );
                    return;             
                }
            } else if (model.getFragmentMap()) {
                // Either memory limited mode or the instance tree has already been created.
                // So, we can just fit the object ids in the view.
                _fit();
                return;
            } else {
                // 3D content
                var propertyDB = model.getData().propertydb,
                    propertyDBFileExists = propertyDB && propertyDB.attrs.length > 0;

                if (propertyDBFileExists) {
                    model.getObjectTree(function(){
                        _fit();
                    });
                    return;
                }
            }
        }

        // If there was no selected set, see what the bounds are of the visible layers.
        // no bounds found, so for 2D instead look at visible layers
        var viewState = this.api.viewerState.getState();
        var object2D = viewState.objectSet[0];
        if (model.is2d() && !object2D.allLayers) {
            bounds = new THREE.Box3();
            // move this next one up into the calling method
            bc = new avp.BoundsCallback(bounds);

            var frags = model.getData().fragments;
            // go through all fragments' geometry objects and see if any are on visible layers
            for (i=0; i<frags.length; i++) {
                find2DLayerBounds(model, i, bc);
            }
        
            // should have some real box at this point; check
            if ( !bounds.empty()) {
                //console.log("layer bounds are " + bounds.min.x +", "+ bounds.min.y + " to " + bounds.max.x +", "+ bounds.max.y);
                this.api.navigation.fitBounds(immediate, bounds);
                this.api.dispatchEvent( theEvent );
                return;                 
            }
        }

        // Fallback, fit to the model bounds
        this.api.navigation.fitBounds(immediate, this.getFitBounds(true));
        this.api.dispatchEvent( theEvent );
    };
}



Viewer3DImpl.prototype.constructor = Viewer3DImpl;

avp.Viewer3DImpl = Viewer3DImpl;

})();

var avp = Autodesk.Viewing.Private;

/**
 * Autocam is the container for the view cube and steering wheel classes.
 * It contains math for camera transformations and most of the functions are retrieved from SampleCAM.
 * Refer to their documentation for explanation.
 */
avp.Autocam = avp.Autocam || function(camera, navApi) {

    var cam = this;
    var dropDownMenu = null;
    var cubeContainer = null;
    var _changing = false;

    this.cube = null;
    this.camera = camera;
    this.renderer = 'WEBGL';
    this.startState = {};
    this.navApi = navApi;   // TODO: use this for camera sync.
    this.orthographicFaces = false;

    this.cameraChangedCallback = null;
    this.pivotDisplayCallback = null;
    this.canvas = null;

    //delta Time
    var startTime = Date.now();
    var deltaTime;
    var setHomeDeferred = false;

    function changed(worldUpChanged)
    {
        _changing = true;
        camera.target.copy(cam.center);
        camera.pivot.copy(cam.pivot);

        if( camera.worldup )
            camera.worldup.copy(cam.sceneUpDirection);
        else
            camera.up.copy(cam.sceneUpDirection);

        if( cam.cameraChangedCallback )
            cam.cameraChangedCallback(worldUpChanged);

        _changing = false;
    }
    
    this.dtor = function() {
        this.cube = null;
        this.cameraChangedCallback = null;
        this.pivotDisplayCallback = null;
        this.canvas = null;
    };

    this.showPivot = function(state)
    {
        if( this.pivotDisplayCallback )
            this.pivotDisplayCallback(state);
    };

        /*
    this.setViewCubeContainer = function( div )
    {
        cubeContainer = div;
    };
    */

    this.setWorldUpVector = function( newUp )
    {
        if( _changing )
            return;

        if( newUp && (newUp.lengthSq() > 0) && !newUp.normalize().equals(this.sceneUpDirection) )
        {
            // Changing up resets the front face:
            this.sceneUpDirection.copy( newUp );
            this.sceneFrontDirection.copy( this.getWorldFrontVector() );
            this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
            if( this.cube )
                requestAnimationFrame(this.cube.render);
        }
    };

    this.getWorldUpVector = function()
    {
        return this.sceneUpDirection.clone();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldRightVector = function()
    {
        var vec = this.sceneUpDirection.clone();

        if (Math.abs(vec.z) <= Math.abs(vec.y))
        {
            // Cross(Vertical, ZAxis)
            vec.set(vec.y, -vec.x, 0);
        }
        else if (vec.z >= 0)
        {
            // Cross(YAxis, Vertical)
            vec.set(vec.z, 0, -vec.x);
        }
        else
        {
            // Cross(Vertical, YAxis)
            vec.set(-vec.z, 0, vec.x);
        }
        return vec.normalize();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldFrontVector = function()
    {
        var up = this.getWorldUpVector();
        return up.cross(this.getWorldRightVector()).normalize();
    };

    this.goToView = function( viewVector ) {
        if( this.navApi.isActionEnabled('gotoview') ) {
            var destination = {
                position: viewVector.position.clone(),
                      up: viewVector.up.clone(),
                  center: viewVector.center.clone(),
                   pivot: viewVector.pivot.clone(),
                     fov: viewVector.fov,
                 worldUp: viewVector.worldUp.clone(),
                 isOrtho: viewVector.isOrtho
            };
            cam.elapsedTime = 0;
            this.animateTransition(destination);
        }
    };

    this.getCurrentView = function () {
        return {
            position: camera.position.clone(),
            up: camera.up.clone(),
            center: this.center.clone(),
            pivot: this.pivot.clone(),
            fov: camera.fov,
            worldUp: this.sceneUpDirection.clone(),
            isOrtho: (camera.isPerspective === false)
        };
    };

    this.setCurrentViewAsHome = function( focusFirst ) {
        if( focusFirst ) {
            this.navApi.setRequestFitToView(true);
            setHomeDeferred = true;
        }
        else {
            this.homeVector = this.getCurrentView();
        }
    };

    // This method sets both the "current" home and the "original" home.
    // The latter is used for the "reset home" function.
    this.setHomeViewFrom = function(camera) {
        var pivot   = camera.pivot   ? camera.pivot   : this.center;
        var center  = camera.target  ? camera.target  : this.pivot;
        var worldup = camera.worldup ? camera.worldup : this.sceneUpDirection;

        this.homeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
             isOrtho: (camera.isPerspective === false)
        };

        this.originalHomeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
          worldFront: this.sceneFrontDirection.clone(),  // Extra for reset orientation
             isOrtho: (camera.isPerspective === false)
        };
    };

    this.toPerspective = function() {
        if( !camera.isPerspective ) {
            camera.toPerspective();
            changed(false);
        }
    };

    this.toOrthographic = function() {
        if( camera.isPerspective ) {
            camera.toOrthographic();
            changed(false);
        }
    };

    this.setOrthographicFaces = function(state) {
         this.orthographicFaces = state;
    };

    this.goHome = function() {
        if( this.navApi.isActionEnabled('gotoview') ) {
            this.navApi.setPivotSetFlag(false);
            this.goToView( this.homeVector );
        }
    };

    this.resetHome = function() {
        this.homeVector.position.copy(this.originalHomeVector.position);
        this.homeVector.up.copy(this.originalHomeVector.up);
        this.homeVector.center.copy(this.originalHomeVector.center);
        this.homeVector.pivot.copy(this.originalHomeVector.pivot);
        this.homeVector.fov = this.originalHomeVector.fov;
        this.homeVector.worldUp.copy(this.originalHomeVector.worldUp);
        this.homeVector.isOrtho = this.originalHomeVector.isOrtho;
        this.goHome();
    };

    this.getView = function() {
        return this.center.clone().sub(camera.position);
    };

    this.setCameraUp = function(up) {
        var view = this.dir.clone();
        var right = view.cross(up).normalize();
        if( right.lengthSq() === 0 )
        {
            // Try again after perturbing eye direction:
            view.copy(this.dir);
            if( up.z > up.y )
                view.y += 0.0001;
            else
                view.z += 0.0001;

            right = view.cross(up).normalize();
        }
        // Orthogonal camera up direction:
        camera.up.copy(right).cross(this.dir).normalize();
    };

    /***
    this.render = function(){
        //renderer.render( scene, camera );
        //We need to remove all calls to this render
        avp.logger.log("Unrequired call to render within Autocam.js:17")
    };
    ***/

    (function animate() {
        requestAnimationFrame(animate);
        // Is there an assumption here about the order of animation frame callbacks?
        var now = Date.now();
        deltaTime = now - startTime;
        startTime = now;
    }());

    //Control variables
    this.ortho = false;
    this.center = camera.target ? camera.target.clone() : new THREE.Vector3(0,0,0);
    this.pivot = camera.pivot ? camera.pivot.clone() : this.center.clone();

    this.sceneUpDirection    = camera.worldup ? camera.worldup.clone() : camera.up.clone();
    this.sceneFrontDirection = this.getWorldFrontVector();

    //
    //dir, up, left vector
    this.dir = this.getView();

    // Compute "real" camera up:
    this.setCameraUp(camera.up);

    this.saveCenter = this.center.clone();
    this.savePivot  = this.pivot.clone();
    this.saveEye    = camera.position.clone();
    this.saveUp     = camera.up.clone();
    var prevEye, prevCenter, prevUp, prevPivot;

    this.cubeFront = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();

    this.setHomeViewFrom(camera);

    var rotInitial = new THREE.Quaternion();
    var rotFinal   = new THREE.Quaternion();
    var rotTwist   = new THREE.Quaternion();
    var rotSpin    = new THREE.Quaternion();
    var distInitial;
    var distFinal;

    /**
     * Holds the default pan speed multiplier of 0.5
     * @type {number}
     */
    this.userPanSpeed = 0.5;

    /**
     * Holds the default look speed multiplier of 2.0
     * @type {number}
     */
    this.userLookSpeed = 2.0;

    /**
     * Holds the default height speed multiplier of 5.0 (used in updown function)
     * @type {number}
     */
    this.userHeightSpeed = 5.0;

    /**
     * Holds the current walk speed multiplier, which can be altered in the steering wheel drop down menu (between 0.24 and 8)
     * @type {number}
     */
    this.walkMultiplier = 1.0;

    /**
     * Holds the default zoom speed multiplier of 1.015
     * @type {number}
     */
    this.userZoomSpeed = 1.015;

    /**
     * Holds the orbit multiplier of 5.0
     * @type {number}
     */
    this.orbitMultiplier = 5.0;
    this.currentlyAnimating = false;

    //look
    camera.keepSceneUpright = true;

    //orbit
    this.preserveOrbitUpDirection = true;
    this.alignOrbitUpDirection = true;
    this.constrainOrbitHorizontal = false;
    this.constrainOrbitVertical = false;
    this.doCustomOrbit = false;
    this.snapOrbitDeadZone = 0.045;
    this.snapOrbitThresholdH = this.snapOrbitThresholdV = THREE.Math.degToRad(15.0);
    this.snapOrbitAccelerationAX = this.snapOrbitAccelerationAY = 1.5;
    this.snapOrbitAccelerationBX = this.snapOrbitAccelerationBY = 2.0;
    this.snapOrbitAccelerationPointX = this.snapOrbitAccelerationPointY = 0.5;
    this.alignDirTable = new Array(26);
    this.alignDirTable[0] = new THREE.Vector3(-1,0,0);
    this.alignDirTable[1] = new THREE.Vector3(1,0,0);
    this.alignDirTable[2] = new THREE.Vector3(0,-1,0);
    this.alignDirTable[3] = new THREE.Vector3(0,1,0);
    this.alignDirTable[4] = new THREE.Vector3(0,0,-1);
    this.alignDirTable[5] = new THREE.Vector3(0,0,1);

    // fill edges
    this.alignDirTable[6] = new THREE.Vector3(-1,-1,0);
    this.alignDirTable[7] = new THREE.Vector3(-1,1,0);
    this.alignDirTable[8] = new THREE.Vector3(1,-1,0);
    this.alignDirTable[9] = new THREE.Vector3(1,1,0);
    this.alignDirTable[10] = new THREE.Vector3(0,-1,-1);
    this.alignDirTable[11] = new THREE.Vector3(0,-1,1);
    this.alignDirTable[12] = new THREE.Vector3(0,1,-1);
    this.alignDirTable[13] = new THREE.Vector3(0,1,1);
    this.alignDirTable[14] = new THREE.Vector3(-1,0,-1);
    this.alignDirTable[15] = new THREE.Vector3(1,0,-1);
    this.alignDirTable[16] = new THREE.Vector3(-1,0,1);
    this.alignDirTable[17] = new THREE.Vector3(1,0,1);

    // fill corners
    this.alignDirTable[18] = new THREE.Vector3(-1,-1,-1);
    this.alignDirTable[19] = new THREE.Vector3(-1,-1,1);
    this.alignDirTable[20] = new THREE.Vector3(-1,1,-1);
    this.alignDirTable[21] = new THREE.Vector3(-1,1,1);
    this.alignDirTable[22] = new THREE.Vector3(1,-1,-1);
    this.alignDirTable[23] = new THREE.Vector3(1,-1,1);
    this.alignDirTable[24] = new THREE.Vector3(1,1,-1);
    this.alignDirTable[25] = new THREE.Vector3(1,1,1);

    this.combined = false;

    //variables used for snapping
    this.useSnap = false;
    this.lockDeltaX = 0.0;
    this.lockedX = false;
    this.lastSnapRotateX = 0.0;
    this.lockDeltaY = 0.0;
    this.lockedY = false;
    this.lastSnapRotateY = 0.0;
    this.lastSnapDir = new THREE.Vector3(0,0,0);

    //up-down
    this.topLimit = false;
    this.bottomLimit = false;
    this.minSceneBound = 0;
    this.maxSceneBound = 0;

    //shot
    var shotParams = { destinationPercent:1.0, duration:1.0, zoomToFitScene:true, useOffAxis:false };
    this.shotParams = shotParams;   // Expose these for modification
    var camParamsInitial, camParamsFinal;

    //zoom
    this.zoomDelta = new THREE.Vector2();
    var unitAmount = 0.0;

    //walk
    var m_resetBiasX, m_resetBiasY, m_bias;

    //info about model object we need to save for fit to window
    var boundingBoxMin = new THREE.Vector3();
    var boundingBoxMax = new THREE.Vector3();

    /**
     * Parameters to control the saving and displaying of the rewind timeline
     * @example <caption> Changing the maximum number of stored rewind cameras from 25(default) to 50 </caption>
     * cam.rewindParams.maxHistorySize = 50;
     */
    this.rewindParams = {
        history:[],
        startTime:undefined,
        thumbnailSize:56.0,
        thumbnailGapSize:12.0,
        maxHistorySize:25,
        snappingEnabled:true,
        timelineIndex:0,
        timelineIndexSlide:0,
        open:false,
        openLocation:new THREE.Vector2(0,0),
        openBracket:new THREE.Vector2(0,0),
        openBracketA:new THREE.Vector2(0,0),
        openBracketB:new THREE.Vector2(0,0),
        openLocationOrigin:new THREE.Vector2(0,0),
        locationOffset:new THREE.Vector2(0,0),
        snapOffset:new THREE.Vector2(0,0),
        slideOffset:new THREE.Vector2(0,0),
        snapped:true,
        resetWeights:false,
        recordEnabled:false,
        elementIsRecording:false
    };

    this.viewCubeMenuOpen = false;
    this.menuSize = new THREE.Vector2(0,0);
    this.menuOrigin = new THREE.Vector2(0,0);

    camera.lookAt(this.center);

    // function windowResize(){
        // refresh camera on size change

        // We handle this elsewhere
        /*
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.topFov = camera.bottomFov = camera.fov/2;
            camera.leftFov = camera.rightFov = (camera.aspect * camera.fov)/2;
            camera.updateProjectionMatrix();
        */
    // }

    /***
    windowResize();
    window.addEventListener('resize', windowResize, false);
    ***/

    this.setCube = function(viewcube)
    {
        this.cube = viewcube;    // DOH!!!
    };

    /**
     * Function which loads the JSON object to the scene
     * @param {JSONObject} model - The correctly formatted JSON model
     * @param {Vector3} scale - The scale multiplier for the input model
     * @param {Vector3} position - Where to load the model
     * @example <caption>Load an object called car.json to (0,0,0) with a scale of 50 </caption>
     * cam.loadObject('Objects/car.json', new THREE.Vector3(50,50,50), new THREE.Vector3(0,0,0));
     */
    this.loadObject = function(model, scale, position){
        loader = new THREE.JSONLoader();
        loader.load( model, function( geometry, materials ) {
            var faceMaterial = new THREE.MeshPhongMaterial( materials );
            mesh = new THREE.Mesh( geometry, faceMaterial );
            mesh.scale = scale;
            mesh.position.copy(position);
            mesh.geometry.computeBoundingBox();
            var bBox = mesh.geometry.boundingBox.clone();
            boundingBoxMax.set(bBox.max.x,bBox.max.y,bBox.max.z);
            boundingBoxMin.set(bBox.min.x,bBox.min.y,bBox.min.z);
            boundingBoxMax.multiply(scale);
            boundingBoxMin.multiply(scale);
            scene.add( mesh );
            objects.push( mesh );
        });
    };


    // Sync our local data from the given external camera:
    this.sync = function(clientCamera) {
        if( clientCamera.isPerspective !== camera.isPerspective ) {
            if( clientCamera.isPerspective ) {
                camera.toPerspective();
            }
            else {
                camera.toOrthographic();
                if( clientCamera.saveFov )
                    camera.saveFov = clientCamera.saveFov;
            }
        }
        camera.fov = clientCamera.fov;
        camera.position.copy(clientCamera.position);

        if( clientCamera.target ) {
            this.center.copy(clientCamera.target);
            camera.target.copy(clientCamera.target);
        }
        if( clientCamera.pivot ) {
            this.pivot.copy(clientCamera.pivot);
            camera.pivot.copy(clientCamera.pivot);
        }
        this.dir.copy(this.center).sub(camera.position);

        this.setCameraUp(clientCamera.up);

        var worldUp = clientCamera.worldup ? clientCamera.worldup : clientCamera.up;
        if( worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001 ) {
            this.setWorldUpVector(worldUp);
        }

        if( setHomeDeferred && !this.navApi.getTransitionActive() ) {
            setHomeDeferred = false;
            this.setCurrentViewAsHome(false);
        }
        if( this.cube )
            requestAnimationFrame(this.cube.render);
    };


    this.refresh = function() {
        if( this.cube )
            this.cube.refreshCube();
    };

    /*        Prototyped Functions          */

    //extending Box2 to be used like AutoCam::Box2
    THREE.Box2.prototype.setCenter = function (center){
        var halfSize = new THREE.Vector2((Math.abs(this.max.x - this.min.x)/2.0),(Math.abs(this.max.y - this.min.y))/2.0);
        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );
        return this;
    };

    //Using Box2 like an AutoCam::Icon2D
    THREE.Box2.prototype.getIcon2DCoords = function(Pscreen,PIcon2D){
        var zero = this.center;
        PIcon2D.set((Pscreen.x - zero.x)/(this.size().x/2.0) , (Pscreen.y - zero.y)/(this.size().y / 2.0));
    };

    //so we dont need a matrix4 as an intermediate
    THREE.Matrix3.prototype.makeRotationFromQuaternion = function ( q ) {
        var te = this.elements;

        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[0] = 1 - ( yy + zz );
        te[3] = xy - wz;
        te[6] = xz + wy;

        te[1] = xy + wz;
        te[4] = 1 - ( xx + zz );
        te[7] = yz - wx;

        te[2] = xz - wy;
        te[5] = yz + wx;
        te[8] = 1 - ( xx + yy );

        return this;
    };

    // changed to accept a matrix3
    THREE.Quaternion.prototype.setFromRotationMatrix3 = function ( m ) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        var te = m.elements,
            m11 = te[0], m12 = te[3], m13 = te[6],
            m21 = te[1], m22 = te[4], m23 = te[7],
            m31 = te[2], m32 = te[5], m33 = te[8],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {
            s = 0.5 / Math.sqrt( trace + 1.0 );
            this.w = 0.25 / s;
            this.x = ( m32 - m23 ) * s;
            this.y = ( m13 - m31 ) * s;
            this.z = ( m21 - m12 ) * s;
        } else if ( m11 > m22 && m11 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
            this.w = (m32 - m23 ) / s;
            this.x = 0.25 * s;
            this.y = (m12 + m21 ) / s;
            this.z = (m13 + m31 ) / s;
        } else if ( m22 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
            this.w = (m13 - m31 ) / s;
            this.x = (m12 + m21 ) / s;
            this.y = 0.25 * s;
            this.z = (m23 + m32 ) / s;
        } else {
            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
            this.w = ( m21 - m12 ) / s;
            this.x = ( m13 + m31 ) / s;
            this.y = ( m23 + m32 ) / s;
            this.z = 0.25 * s;
        }
        return this;
    };

    // NOTE: This modifies the incoming vector!!
    // TODO: Change all calls to use Vector3.applyQuaternion instead.
    THREE.Quaternion.prototype.rotate = function (vector){
        //From AutoCamMath.h file
        var kRot = new THREE.Matrix4().makeRotationFromQuaternion(this);
        var e = kRot.elements;

        //converting 4d matrix to 3d
        var viewRot = new THREE.Matrix3().set( e[0],e[1],e[2], e[4],e[5],e[6], e[8],e[9],e[10] );

        return vector.applyMatrix3(viewRot);
    };

    THREE.Vector3.prototype.findAngleWith = function(b, axis){
        var angle = 0.0;
        var cosAngle = this.clone().normalize().clone().dot(b.clone().normalize());

        var axisCheck = (this.clone().cross(b)).clone().normalize();
        if (axisCheck.clone().length() < Number.MIN_VALUE){
            if(cosAngle > 0.0){
                angle = 0.0;
            }else{
                angle = 180.0;
            }
        }else{

            var cosCheck = axisCheck.clone().dot(axis.clone().normalize());

            //check to make sure user specified axis is orthogonal to vectors.
            //If it isn't we take the closer of the two choices.
            axis = cosCheck > 0.0 ? axisCheck : -axisCheck;

            var cosAngleNextQuadrant = new THREE.Quaternion().setFromAxisAngle( axis, 90.0 * THREE.Math.degToRad );
            cosAngleNextQuadrant = ((cosAngleNextQuadrant.clone().rotate(b)).clone().normalize()).clone().dot(this);
            angle = Math.acos(cosAngle) * THREE.Math.radToDeg;

            if(Math.abs(angle - 90.0) < Number.MIN_VALUE)
                angle = 90.0;

            if ((angle < 90.0 && cosAngle * cosAngleNextQuadrant > 0.0)||
                (angle > 90.0 && cosAngle * cosAngleNextQuadrant < 0.0)||
                (angle == 90.0 && cosAngleNextQuadrant > 0.0))
                angle = -1.0 * angle;	//figure out whether we need to turn left or right
        }

        angle = THREE.Math.degToRad(angle);
        return angle;
    };

    if(!('contains' in String.prototype))
        String.prototype.contains = function(str, startIndex) { return -1 !== String.prototype.indexOf.call(this, str, startIndex); };

    Math.linearClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        return ( x - a ) / ( b - a );
    };

    Math.easeClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        var t = ( x - a ) / ( b - a );
        return 0.5 * ( Math.sin( (t - 0.5) * Math.PI ) + 1.0 );
    };

    Math.linearInterp = function( t, a, b ){
        return a * (1.0 - t) + b * t;
    };

    Math.equalityClamp = function (x,a,b){
        if ( x <= a ) { return a; }
        if ( x >= b ) { return b; }

        return x;
    };

    Math.round2 = function (x){
        return (Math.round(x*100))/100;
    };

    Math.round1 = function (x){
        return (Math.round(x*10))/10;
    };


    /*      SHOT OPERATION      */

    //transitions smoothly to destination
    this.animateTransition = function ( destination ) {

        if ( !destination ) { return; }

        var worldUpChanged = false;
        var unitTime = 0.0;

        this.setCameraOrtho(destination.isOrtho);

        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;

            cam.center.copy(destination.center);
            cam.pivot.copy(destination.pivot);
            camera.position.copy(destination.position);
            camera.up.copy(destination.up);
            camera.target.copy(destination.center);
            if( !destination.isOrtho )
                camera.fov = destination.fov;
            camera.dirty = true;

            worldUpChanged = !destination.worldUp.equals(this.sceneUpDirection);
            if( worldUpChanged )
                this.setWorldUpVector(destination.worldUp);

            this.currentlyAnimating = false;
            changed(worldUpChanged);
            this.showPivot(false);
            if( this.cube )
                requestAnimationFrame(this.cube.render);

            this.addHistoryElement();
            this.navApi.setTransitionActive(false);
            return;
        }
        this.currentlyAnimating = true;
        this.showPivot(true);
        this.navApi.setTransitionActive(true);

        var tMax = shotParams.destinationPercent;
        unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
        var oneMinusTime = 1.0 - unitTime;
        cam.elapsedTime += deltaTime/500;

        var center = (cam.center.clone().multiplyScalar(oneMinusTime)).add( destination.center.clone().multiplyScalar( unitTime ));
        var position = (camera.position.clone().multiplyScalar(oneMinusTime)).add(destination.position.clone().multiplyScalar( unitTime ));
        var up = (camera.up.clone().multiplyScalar(oneMinusTime)).add(destination.up.clone().multiplyScalar( unitTime ));
        var pivot = (camera.pivot.clone().multiplyScalar(oneMinusTime)).add(destination.pivot.clone().multiplyScalar( unitTime ));
        var worldUp = (this.sceneUpDirection.clone().multiplyScalar(oneMinusTime)).add(destination.worldUp.clone().multiplyScalar( unitTime ));
        var fov = camera.fov * oneMinusTime + destination.fov * unitTime;

        cam.center.copy(center);
        cam.pivot.copy(pivot);
        camera.position.copy(position);
        camera.up.copy(up);
        camera.target.copy(center);
        if( !destination.isOrtho )
            camera.fov = fov;
        camera.dirty = true;

        worldUpChanged = (worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001);
        if( worldUpChanged )
            this.setWorldUpVector(worldUp);

        camera.lookAt(cam.center);
        changed(worldUpChanged);

        if( this.cube )
            requestAnimationFrame(this.cube.render);

        requestAnimationFrame(function() { cam.animateTransition(destination); });
    };

    //used for view cube transforms, to see difference between this and linear interpolation watch
    //http://www.youtube.com/watch?v=uNHIPVOnt-Y
    this.sphericallyInterpolateTransition = function( completionCallback )
    {
        var center, position, up;
        var unitTime = 0.0;
        this.currentlyAnimating = true;
        this.navApi.setTransitionActive(true);

        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
            this.currentlyAnimating = false;
        }
        else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        // This seems to avoid some error in the rotation:
        if( unitTime === 1.0 ) {
            position = camParamsFinal.position;
            center   = camParamsFinal.center;
            up       = camParamsFinal.up;
        }
        else {
            var M = new THREE.Matrix3();
            var rot = rotInitial.clone();
            rot.slerp(rotFinal,(unitTime));
            M.makeRotationFromQuaternion(rot);
            var dist = Math.linearInterp(unitTime, distInitial, distFinal);

            var e = M.elements;

            center = camParamsInitial.center.clone().multiplyScalar(1.0 - unitTime).add(camParamsFinal.center.clone().multiplyScalar(unitTime));
            position = center.clone().sub(new THREE.Vector3(e[0],e[1],e[2]).multiplyScalar(dist));
            up = new THREE.Vector3(e[3],e[4],e[5]);
        }
        cam.center.copy(center);
        camera.position.copy(position);
        camera.up.copy(up);

        // The above code will have to change if we want the proper rotation
        // to occur about the pivot point instead of the center.
        if( !cam.navApi.getUsePivotAlways() )
            cam.pivot.copy(center);

        camera.lookAt(cam.center);

        if( this.currentlyAnimating === true ) {
            this.showPivot(true);
            requestAnimationFrame(function() { cam.sphericallyInterpolateTransition(completionCallback); });
        }
        else {
            this.navApi.setTransitionActive(false);
            this.showPivot(false);
            this.addHistoryElement();

            if( this.orthographicFaces && this.isFaceView() )
                this.setCameraOrtho(true);

            if( completionCallback )
                completionCallback();
        }
        changed(false);
        if( this.cube )
            requestAnimationFrame(this.cube.render);
    };

    //This is used to determine the relation between camera up vector and scene direction, used to determine which
    //face to translate to when clicking on a viewcube arrow
    this.getOrientation = function(){
        if( !this.cube )
            return;

        var camX = Math.round1(camera.up.x);
        var camY = Math.round1(camera.up.y);
        var camZ = Math.round1(camera.up.z);
        var sceneFront = this.sceneFrontDirection.clone();
        var sceneUp = this.sceneUpDirection.clone();
        var sceneRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
        sceneFront.x = Math.round1(sceneFront.x);
        sceneFront.y = Math.round1(sceneFront.y);
        sceneFront.z = Math.round1(sceneFront.z);
        sceneUp.x = Math.round1(sceneUp.x);
        sceneUp.y = Math.round1(sceneUp.y);
        sceneUp.z = Math.round1(sceneUp.z);
        sceneRight.x = Math.round1(sceneRight.x);
        sceneRight.y = Math.round1(sceneRight.y);
        sceneRight.z = Math.round1(sceneRight.z);
        var sceneLeft = sceneRight.clone().multiplyScalar(-1);
        var sceneDown = sceneUp.clone().multiplyScalar(-1);
        var sceneBack = sceneFront.clone().multiplyScalar(-1);

        switch (this.cube.currentFace){
            case "front":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "right":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "left";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "right"
                break;
            case "left":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "left";
                else if (sceneBack.x ==camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "right"
                break;
            case "back":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "right";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "left"
                break;
            case "top":
                if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "bottom":
                if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
        }
    };

    this.setCameraOrtho = function(yes) {
        if( yes && camera.isPerspective )
            camera.toOrthographic();

        if( !yes && !camera.isPerspective )
            camera.toPerspective();
    };

    this.resetOrientation = function(){
        this.setCameraOrtho(this.originalHomeVector.isOrtho);
        this.sceneUpDirection.copy(this.originalHomeVector.worldUp);
        this.sceneFrontDirection.copy(this.originalHomeVector.worldFront);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        this.setCameraUp(this.sceneUpDirection);
        changed(true);
    };

    this.setCurrentViewAsFront = function(){
        if( this.cube )
            this.cube.currentFace = "front";

        this.sceneUpDirection.copy(camera.up.clone());
        this.sceneFrontDirection.copy(this.getView()).normalize();
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();

        if( this.orthographicFaces )
            this.setCameraOrtho(true);

        changed(true);
    };

    this.setCurrentViewAsTop = function(){
        if( this.cube )
            this.cube.currentFace = "top";

        this.sceneUpDirection.copy(this.getView()).multiplyScalar(-1).normalize();
        this.sceneFrontDirection.copy(camera.up);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        changed(true);
    };

    this.calculateCubeTransform = function(faceString){
        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

        camParamsInitial = camera.clone();
        camParamsInitial.center = cam.center.clone();
        camParamsInitial.pivot = cam.pivot.clone();

        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center.clone();
        camParamsFinal.pivot = cam.pivot.clone();

        // find movement offset based on given boolean flags
        var offset = new THREE.Vector3( 0, 0, 0 );
        if ( faceString.contains('back')){
            offset = offset.add(worldFront);
        }
        if ( faceString.contains('front')){
            offset = offset.sub(worldFront);
        }
        if ( faceString.contains('top')){
            offset = offset.add(worldUp);
        }
        if ( faceString.contains('bottom')){
            offset = offset.sub(worldUp);
        }
        if ( faceString.contains('right')){
            offset = offset.add(worldRight);
        }
        if ( faceString.contains('left')){
            offset = offset.sub(worldRight);
        }
        var upDir = worldUp;

        // view looking at top or bottom chosen
        var test = offset.clone().normalize();

        if ( ( 1.0 - Math.abs(test.dot(worldUp)) ) < Number.MIN_VALUE ) {
            //( offset == worldUp || offset == -worldUp )
            // find the principal view direction other than top/bottom closest to
            // the current view direction and use it as an up vector

            var viewDir = this.getView().normalize();
            var optUpDir = [ worldFront.clone(), worldFront.clone().negate(), worldRight.clone(), worldRight.clone().negate() ];

            // use both view and up vectors for test vector because transitioning from
            // top and bottom views, view direction is the same (but up direction is different)

            var sign = (test.dot(worldUp) > 0.0) ? +1.0 : -1.0; //( offset == worldUp ) ? +1.0 : -1.0;
            var testDir = viewDir.clone().add(camera.up.clone().multiplyScalar(sign)).normalize();

            var optValue = -2.0;

            for ( var i = 0; i < 4; i++ ){
                var value = testDir.dot( optUpDir[i] );

                if ( value > optValue ){
                    optValue = value;
                    upDir = optUpDir[i].multiplyScalar(sign);
                }
            }
        }

        distFinal = distInitial = this.getView().length();
        // WHY? camParamsFinal.center = this.originalCenter;
        camParamsFinal.position.copy(camParamsFinal.center.clone().add(offset.multiplyScalar(distFinal/offset.length())));
        camParamsFinal.up.copy(upDir);

        var D = camParamsInitial.center.clone().sub(camParamsInitial.position).normalize();
        var R = D.clone().cross(camParamsInitial.up).normalize();
        var U = R.clone().cross(D).normalize();
        var M = new THREE.Matrix3();
        M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        rotInitial.setFromRotationMatrix3(M);

        D = camParamsFinal.center.clone().sub(camParamsFinal.position).normalize();
        R = D.clone().cross(camParamsFinal.up).normalize();
        U = R.clone().cross(D).normalize();
        M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        //TODO: figure out when these angles aren't supposed to be 0, works for now
        rotTwist.setFromAxisAngle(D,0.0);
        rotSpin.setFromAxisAngle(U,0.0);
        rotFinal.setFromRotationMatrix3(M);
        rotFinal.multiply(rotTwist).multiply(rotSpin).normalize();

    };

    //used for center operation from steering wheel and steering wheel menu
    this.centerShot = function(fromWheelMenu){
        //TODO: investigate the problem where it is not animating sometimes (due to lag)

        if (!camParamsInitial || fromWheelMenu){
            cam.elapsedTime = 0;
            camParamsInitial = camParamsFinal = camera.clone();
            camParamsInitial.center = cam.center;
        }

        var pWorld = cam.pivot.clone();
        var P = pWorld.clone().sub(camParamsInitial.position);
        var D = (camParamsInitial.center.clone().sub(camParamsInitial.position)).normalize();
        var U = camParamsInitial.up.clone();
        var R = (D.clone().cross(U)).normalize();
        U = (R.clone().cross(D)).normalize();


        var PprojR = R.clone().multiplyScalar(R.dot(P));
        var PprojU = U.clone().multiplyScalar(U.dot(P));
        var PprojRU = PprojR.clone().add(PprojU);

        camParamsFinal.position.copy(camParamsInitial.position.clone().add(PprojRU));

        camParamsFinal.center = pWorld;
        camParamsFinal.pivot = pWorld;

        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/2000;
        }

        var position = (camera.position.clone().multiplyScalar( 1.0 - unitTime)).add(camParamsFinal.position.clone().multiplyScalar( unitTime ));
        var center = (cam.center.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.center.clone().multiplyScalar( unitTime ));
        var pivot = (cam.pivot.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.pivot.clone().multiplyScalar(unitTime));
        camera.position.copy(position);
        cam.center.copy(center);
        cam.pivot.copy(pivot);

        camera.lookAt(cam.center);
        changed(false);

        if( unitTime === 1.0 )
            this.addHistoryElement();
        else
            requestAnimationFrame(function() { cam.centerShot(false); });
    };

    //This is for the level camera operation in steering wheel menu
    //Integrated from ViewManager::LevelCamera
    this.levelShot = function(){

        var view = this.getView();
        var dist = view.length();
        var worldUp = this.sceneUpDirection.clone();
        var vUp  = camera.up.clone().normalize();
        var vView = view.normalize();
        var dotView = vView.dot(worldUp);

        if ((1.0 - Math.abs(dotView)) > Number.MIN_VALUE){
            var vRight = vView.clone().cross(worldUp);
            vView = worldUp.clone().cross(vRight);
            vView.normalize();
        }else{
            vView = vUp.clone();
        }
        vView.multiplyScalar(dist);

        var destination = {
            center: vView.add(camera.position),
            up: worldUp,
            position: camera.position,
            pivot: cam.center.clone().add(vView),
            fov: camera.fov,
            worldUp: worldUp
        };
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    };

    //This is for the fit to window operation in the steering wheel drop down menu
    //Integrated from CameraOperations::FitBoundingBoxToView
    //Right now since we only load one mesh we can use the bounding box property of it, if multiple meshes loaded
    //we will need to find the bounding box around them
    this.fitToWindow = function(){

        var viewDir = this.getView();
        var upDir = camera.up.clone();
        viewDir.normalize();
        upDir.normalize();
        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center;

        upDir = getUpDirection(upDir,viewDir);
        upDir.normalize();
        camParamsFinal.up.copy(upDir);

        var rightDir = viewDir.clone().cross(upDir);
        rightDir.normalize();

        var boxMin = boundingBoxMin.clone();
        var boxMax = boundingBoxMax.clone();
        var boxPoints = [boxMin,boxMax];
        var boxMidpoint = new THREE.Vector3(boxMax.x-boxMin.x, boxMax.y-boxMin.y,boxMax.z-boxMin.z);

        boxPoints[2] = new THREE.Vector3(boxMax.x,boxMin.y,boxMax.z);
        boxPoints[3] = new THREE.Vector3(boxMax.x,boxMin.y,boxMin.z);
        boxPoints[4] = new THREE.Vector3(boxMax.x,boxMax.y,boxMin.z);
        boxPoints[5] = new THREE.Vector3(boxMin.x,boxMax.y,boxMax.z);
        boxPoints[6] = new THREE.Vector3(boxMin.x,boxMax.y,boxMin.z);
        boxPoints[7] = new THREE.Vector3(boxMin.x,boxMin.y,boxMax.z);

        //Move the box into camParams frame coordinates
        for(var j=0; j<8; j++){
            var testVector = boxPoints[j].clone().sub(camera.position);

            boxPoints[j].setX(testVector.clone().dot(rightDir));
            boxPoints[j].setY(testVector.clone().dot(upDir));
            boxPoints[j].setZ(testVector.clone().dot(viewDir));
        }

        //This is to be used when ortho camera is implemented
        /*
        var minPointH = boxPoints[0], maxPointH = boxPoints[0], minPointV = boxPoints[0],maxPointV = boxPoints[0];

        //Solve for the eye position in ortho.  We take the position as the center point
        //Of the 2D projection.
        for(var k=0; k<8; k++){
            var testVertex = boxPoints[k];
            if(testVertex.x < minPointH.x){
                minPointH = testVertex;
            }else if(testVertex.x > maxPointH.x){
                maxPointH = testVertex;
            }

            if(testVertex.y < minPointV.y){
                minPointV = testVertex;
            }else if(testVertex.y > maxPointV.y){
                maxPointV = testVertex;
            }
        }

        var geomWidth = maxPointH.x - minPointH.x;
        var geomHeight = maxPointV.y - minPointV.y;

        //Set ortho width and height
        if (geomWidth/geomHeight > camera.aspect){
            camParams.orthoWidth = geomWidth;
            camParams.orthoHeight = geomWidth/viewAspect;
        }else{
            camParams.orthoWidth = geomHeight * viewAspect;
            camParams.orthoHeight = geomHeight;
        }
        var orthoOffset = new THREE.Vector3((minPointH.x + maxPointH.x)/2.0,(minPointV.y + maxPointV.y)/2.0,0.0);
        */

        //Find the eye position in perspective.
        //While working in 2D, find the equation of the line passing through each box corner of form z = mx + b
        //that is parallel to the sides of the viewing frustum.  Note that all of the coordinates of the box
        //are still defined in the camParams frame.  Compare the z intercept values (ie. b) to figure out which two lines
        //represent the outer edges of the bounding box, and solve for their intersection to find the desired eye (x,z) position
        //that would be required to make the object touch the left and right edges of the viewport (ie. the closest we can get
        //without losing horizontal view of the object).  Repeat with z = my + b to find the eye (y,z) position for the vertical frustum.

        //TODO:fovTop and fovBottom are ALWAYS the same b/c of camera declaration, this needs to change
        var fovTop = THREE.Math.degToRad(camera.topFov);
        var fovBottom = THREE.Math.degToRad(camera.bottomFov);
        var fovLeft = THREE.Math.degToRad(camera.leftFov);
        var fovRight = THREE.Math.degToRad(camera.rightFov);

        var BLeft, BRight, BTop,BBottom;

        BLeft = (fovLeft >= 0) ? Number.MAX_VALUE : Number.MIN_VALUE;
        BRight = (fovRight >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BTop = (fovTop >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BBottom = (fovBottom >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;

        var slopeRight = 1.0/Math.tan(fovRight);
        var slopeLeft = -1.0/Math.tan(fovLeft);
        var slopeTop = 1.0/Math.tan(fovTop);
        var slopeBottom = -1.0/Math.tan(fovBottom);

        for (var i = 0; i<8; i++){
            var testCorner = boxPoints[i].clone();
            var b = testCorner.z - (slopeLeft * testCorner.x);
            BLeft = (fovLeft >= 0)? Math.min(BLeft,b) : Math.max(BLeft,b);

            b = testCorner.z - (slopeRight * testCorner.x);
            BRight = (fovRight >=0) ? Math.min(BRight, b) : Math.max(BRight, b);

            //For vertical frustum
            b = testCorner.z - (slopeTop *testCorner.y);
            BTop = (fovTop >=0) ? Math.min(BTop, b) : Math.max(BTop, b);

            b = testCorner.z - (slopeBottom * testCorner.y);
            BBottom = (fovBottom >=0) ? Math.min(BBottom, b) : Math.max(BBottom, b);
        }

        //Solve for intersection of horizontal frustum
        var eyeX = (BRight - BLeft)/(slopeLeft - slopeRight);
        var eyeZH = (slopeLeft * eyeX) + BLeft;

        //Solve for intersection of vertical frustum
        var eyeY = (BBottom - BTop)/(slopeTop - slopeBottom);
        var eyeZV = slopeTop * eyeY + BTop;

        var eyeZ = 0.0;

        //With the two frustums solved, compare the two frustums to see which one is currently closer to the object based on z value.
        //Slide the closer frustum back along its median line (to ensure that the points stay within the frustum) until it's Z value
        //matches that of the further frustum. Take this as the final eye position.

        if (eyeZH <= eyeZV){
            var medianAngleV = (fovTop - fovBottom) / 2.0;
            if (Math.abs(medianAngleV) > Number.MIN_VALUE){
                var medianSlopeV = 1.0/Math.tan(medianAngleV);
                eyeY = eyeY - eyeZV/medianSlopeV + eyeZH/medianSlopeV; //derived from z1 - my1 = z2 - my2
            }
            eyeZ = eyeZH;
        }else{
            var medianAngleH = (fovRight - fovLeft) / 2.0;
            if (Math.abs(medianAngleH) > Number.MIN_VALUE){
                var medianSlopeH = 1.0/Math.tan(medianAngleH);
                eyeX = eyeX - eyeZH/medianSlopeH + eyeZV/medianSlopeH;
            }
            eyeZ = eyeZV;
        }

        var eyeOffset = new THREE.Vector3(eyeX,eyeY,eyeZ);

        //Transform eyeoffset back into world frame
        var interim1 = (rightDir.clone().multiplyScalar(eyeOffset.x));
        var interim2 = (upDir.clone().multiplyScalar(eyeOffset.y));
        var interim3 = (viewDir.clone().multiplyScalar(eyeOffset.z));
        eyeOffset = interim1.clone().add(interim2.clone().add(interim3));

        camParamsFinal.position.add(eyeOffset);
        var interim = (boxMidpoint.clone().sub(camParamsFinal.position)).dot(viewDir);
        camParamsFinal.center = camParamsFinal.position.clone().add(viewDir.multiplyScalar(interim));
        camParamsFinal.pivot = boxMidpoint.clone();

        var destination = {
              center: camParamsFinal.center,
                  up: camParamsFinal.up,
            position: camParamsFinal.position,
               pivot: camParamsFinal.pivot,
                 fov: camera.fov,
             worldUp: cam.sceneUpDirection.clone()
        };
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    };

    /*         Functions for operation         */

    //used in fit to window
    function getUpDirection(upDir, viewDir){
        var upp = upDir.clone();

        if((Math.abs(upp.clone().dot(viewDir))) < Number.MIN_VALUE){
            upp.normalize();
            return upp;
        }

        upp = getProjectionOnPlane(upDir,viewDir);
        if (upp.length() < Number.MIN_VALUE){
            upp = getEmpiricalUpDirection(viewDir);
        }
        upp.normalize();
        return upp;
    }

    //used in getUpDirection
    function getProjectionOnPlane(vector,normal){
        normal.normalize();
        var projToNormal = vector.clone().dot(normal);
        var projection = normal.clone().multiplyScalar(projToNormal);
        projection = vector.clone().sub(projection);
        return projection;
    }

    //used in getUpDirection
    function getEmpiricalUpDirection(normal){
        var zeros = new THREE.Vector3(0,0,0);
        var directions = [new THREE.Vector3(0,1,0),
            new THREE.Vector3(1,0,0),
            new THREE.Vector3(0,0,1),
            new THREE.Vector3(0,1,1),
            new THREE.Vector3(1,0,1),
            new THREE.Vector3(1,1,0),
            new THREE.Vector3(1,1,1)
            ];

        for (var i = 0; i <7; i++){
            if (Math.abs(directions[i].dot(normal)) < Number.MIN_VALUE){
                zeros = directions[i];
                break;
            }
        }
        return zeros;
    }

    //convert screen coords to window coords
    function convertCoordsToWindow( pixelX, pixelY ){
        var delta = new THREE.Vector2(0,0);

        delta.x = pixelX / window.innerWidth;
        delta.y = pixelY / window.innerHeight;

        return delta;
    }

    //picking ray intersection with the empty scene(not on object)
    function getScreenRay( mouse ){
        mouse.y = Math.abs(mouse.y - window.innerHeight);
        var rayOrigin, rayDirection;
        var eye = camera.position;
        var center = cam.center;
        var eyeToCenter = center.clone().sub(eye);
        var up = camera.up;
        var right = eyeToCenter.clone().cross(up);
        var dist = eyeToCenter.clone().length();

        var frustumLeft = dist * Math.tan(THREE.Math.degToRad(camera.leftFov));
        var frustumRight = dist * Math.tan(THREE.Math.degToRad(camera.rightFov));
        var frustumTop = dist * Math.tan(THREE.Math.degToRad(camera.topFov));
        var frustumBottom = dist * Math.tan(THREE.Math.degToRad(camera.bottomFov));
        var frustumWidth = (frustumLeft + frustumRight);
        var frustumHeight = (frustumTop + frustumBottom);

        var rightLength = mouse.x * frustumWidth / window.innerWidth;
        var centerToRightLength = rightLength - frustumLeft;

        var upLength = mouse.y * frustumHeight / window.innerHeight;
        var centerToUpLength = upLength - frustumBottom;

        up = up.clone().normalize().clone().multiplyScalar(centerToUpLength);
        right = right.clone().normalize().clone().multiplyScalar(centerToRightLength);

        /*
        // PRH -- account for difference in aspect ratio between camera FOV and viewport --
        AutoCam::AdjustForAspectRatio( params, screenWidth, screenHeight, mouseXunit, mouseYunit );
        */

        if ( cam.ortho ){
            rayOrigin = eye.clone().add(right).clone().add(up);
            rayDirection = eyeToCenter;
        }else{
            rayOrigin = eye;
            rayDirection = eyeToCenter.clone().add(up).clone().add(right);
        }

        return {
            'rayO': rayOrigin,
            'rayD': rayDirection
        };
    }

    //get ray intersection point and set pivot
    this.updatePivotPosition = function( mouse ){
        //TODO: update pivot only when mouse down

        var raycaster;
        var intersects;
        //formula from online
        var direction = new THREE.Vector3((mouse.x / window.innerWidth) * 2 - 1, -(mouse.y / window.innerHeight) * 2 + 1, 0.5);

        direction = direction.unproject(camera);
        raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
        intersects = raycaster.intersectObjects(objects);

        if (cam.mode == 'zoom'){
            if (intersects[0] !== undefined){
                var point = intersects[0].point;
                cam.pivot.copy(point);
            }else{
                var result = getScreenRay( mouse );
                cam.pivot.copy(result.rayO.clone().add(result.rayD));
            }

        }else if (intersects[0] !== undefined){
            wheel.cursorImage('pivot');
            var point = intersects[0].point;
            if (!cam.isMouseDown){
                cam.pivot.copy(point);
            }
        }else{
            wheel.cursorImage('SWInvalidArea');
        }
    };

    function getNextRotation(rotationType, snapAngle, lastDelta){
        var threshold, accelerationA, accelerationB, shiftZone;
        threshold = accelerationA = accelerationB = shiftZone = 0.0;

        var next = 0.0;
        var lockedAxis = null;
        var lockDelta = null;

        var deadZone = cam.snapOrbitDeadZone;
        var orbitMultiplier = cam.orbitMultiplier;

        if (rotationType == 'h'){
            threshold = cam.snapOrbitThresholdH;
            accelerationA = cam.snapOrbitAccelerationAX;
            accelerationB = cam.snapOrbitAccelerationBX;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointX;
            lockDelta = cam.lockDeltaX;
            lockedAxis = cam.lockedX;
        }else{
            threshold = cam.snapOrbitThresholdV;
            accelerationA = cam.snapOrbitAccelerationAY;
            accelerationB = cam.snapOrbitAccelerationBY;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointY;
            lockDelta = cam.lockDeltaY;
            lockedAxis = cam.lockedY;
        }

        if(!lockedAxis){
            if(Math.abs(snapAngle) > threshold){
                next = lastDelta * orbitMultiplier;
            }else if (Math.abs(snapAngle) > shiftZone * threshold){
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationA;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationA;
                }

            }else{
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationB;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationB;
                }

            }

            if(next * snapAngle > 0.0 && Math.abs(next) > Math.abs(snapAngle)){
                this.lockDeltaX = this.lockDeltaY = 0.0;	//want to reset both regardless of rotation axis
                lockedAxis = true;
                next = snapAngle;
            }

        }else{
            lockDelta += lastDelta;

            if(lockDelta < -deadZone){
                next =  (lockDelta + deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }else if(lockDelta > deadZone){
                next =  (lockDelta - deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }
        }
        return next;
    }


    function getClosestAlignDir(Dv, searchPrincipal){
        var maxAngle = -Number.MAX_VALUE;
        var maxIndex = 0;

        for ( var i = 0; i < (searchPrincipal ? 6 : 26); i++ ){
            var Di = cam.alignDirTable[i].clone().multiplyScalar(-1);
            Di.normalize();

            var angle = Di.dot(Dv);

            if ( angle > maxAngle ){
                maxAngle = angle;
                maxIndex = i;
            }
        }
        return cam.alignDirTable[maxIndex];
    }

    function snapToClosestView (up, snapAngleh, snapAnglev){
        if ( !cam.useSnap )
            return;

        if (cam.preserveOrbitUpDirection ){
            // Find closest view direction
            var lastViewDir = (cam.saveCenter.clone().sub(cam.saveEye)).clone().normalize();
            var snapDir = (getClosestAlignDir(lastViewDir, false)).clone().multiplyScalar(-1).clone().normalize();

            if(Math.abs(Math.abs(lastViewDir.clone().dot(up)) - 1.0) < Number.MIN_VALUE){
                //topdown or bottom up case
                snapAnglev = 0.0;
                var snapUp = (getClosestAlignDir(cam.saveUp, true)).clone().multiplyScalar(-1).clone().normalize();
                snapAngleh = cam.saveUp.findAngleWith(snapUp,up);
            } else {
                var lastViewDirProj = lastViewDir.clone().sub(up).multiplyScalar(up.clone().dot(lastViewDir));
                var snapDirProj = snapDir.clone().sub(up).multiplyScalar(up.clone().dot(snapDir));
                snapAngleh = lastViewDirProj.clone().findAngleWith(snapDirProj, up);
                var testRotate = new THREE.Quaternion().setFromAxisAngle( up,snapAngleh );
                var transitionDir = testRotate.clone().rotate(lastViewDir);
                var transitionRight = testRotate.clone().rotate(lastViewDir.clone().cross(cam.saveUp));
                snapAnglev = transitionDir.clone().findAngleWith(snapDir, transitionRight);
            }

            if(snapDir != cam.lastSnapDir){
                //If last and current snapDirs are not on the same plane, unlock vertical orbit
                if (Math.abs(snapDir.clone().dot(up) - cam.lastSnapDir.clone().dot(up)) > Number.MIN_VALUE){
                    cam.lockedY = false;
                }
                cam.lastSnapDir = snapDir;
            }
        } else {
            //Find closest view direction
            /*  var vDirView = cam.saveCenter.clone().sub(cam.saveEye);
            var vRight = vDirView.clone().cross( cam.saveUp );
            var snapDir = -getClosestAlignDir(vDirView, false).clone().normalize();
            var snapDirProj = snapDir.clone.sub(up.clone().multiplyScalar(up.clone().dot(snapDir)));
            snapAngleh = vDirView.findAngleWith(snapDirProj, up);

            var testRotate = new THREE.Quaternion().setFromAxisAngle(up,snapAngleh );
            var transitionDir = testRotate.clone().rotate(vDirView);
            var transitionRight = testRotate.clone().rotate(vRight);
            snapAnglev = transitionDir.findAngleWith(snapDir, transitionRight);

            if(snapDir != cam.lastSnapDir) {
                cam.cam.lockedY = false;
                cam.lockedX = false;
                cam.lastSnapDir = snapDir;
            }*/
        }
    }

/// Returns true if the operation belongs to a chain of combined operations; otherwise returns false.
    function IsCombined(){
        return cam.combined;
    }

    function isInDeadZone(currentCursor, startCursor){

        var deadZone = 30;
        var res = false;

        var w = window.innerWidth;
        var x = currentCursor.x % w;

        var h = window.innerHeight;
        var y = currentCursor.y % h;


        var diffX = (x > 0) ? (x - startCursor.x) : (w + x - startCursor.x);
        var diffY = (y > 0) ? (y - startCursor.y) : (h + y - startCursor.y);

        if((Math.abs(diffX) < deadZone) &&  (Math.abs(diffY) < deadZone))
            res = true;

        return res;
    }

    function GetXYAndWrapCounts(currentCursor, startCursor, wrapCount ){
        wrapCount.x = (currentCursor.x - startCursor.x) / window.innerWidth;
        currentCursor.x = startCursor.x + (currentCursor.x - startCursor.x) % window.innerWidth;

        wrapCount.y = (currentCursor.y - startCursor.y) / window.innerHeight;
        currentCursor.y = startCursor.y + (currentCursor.y - startCursor.y) % window.innerHeight;
    }

    function setBias( set, currentCursor, startCursor ){
        if (m_bias && set){
            return;

        }else if (set){
            var deadZone = 30;
            var wrapCount = new THREE.Vector2();

            var x = currentCursor.x;
            var y = currentCursor.y;

            GetXYAndWrapCounts(currentCursor, startCursor, wrapCount);

            m_resetBiasX = window.innerWidth * wrapCount.x;
            m_resetBiasY = window.innerHeight * wrapCount.y;

            if (x < startCursor.x)
                x = x - 2 * deadZone;
            else
                x = x + 2 * deadZone;

            if (y < startCursor.y)
                y = y - 2 * deadZone;
            else
                y = y + 2 * deadZone;
        }
        m_bias = set;
    }

    function checkBoundaryConditions(amount, cursorOffset, m_amount){
        if (cursorOffset === 0)
            return 0;

        var deltaAmount = amount;
        var eye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount + deltaAmount));
        var prevEye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount));

        var eyeHeight = 0.0;
        var epsilon = (cam.maxSceneBound - cam.minSceneBound) / 1000;

        //avp.logger.log(m_amount);
        //avp.logger.log(deltaAmount);


        if (cam.topLimit && (cursorOffset > 0)){
            // Cursor was on the top of the slider, but now is moving down.
            // Bring eyeHeight below maxSceneBound.
            eyeHeight = cam.maxSceneBound - epsilon;
            cam.topLimit = false;
        }else if (cam.bottomLimit && (cursorOffset < 0)){
            // Cursor was on the bottom of the slider, but now is moving up.
            // Bring eyeHeight above minSceneBound.
            eyeHeight = cam.minSceneBound + epsilon;
            cam.bottomLimit = false;
        }else{
            eyeHeight = eye.dot(worldUp);
        }

        var prevEyeHeight =	prevEye.dot(worldUp);

        //avp.logger.log(eyeHeight);

        if ( eyeHeight < cam.minSceneBound ) {
            if ( prevEyeHeight < cam.minSceneBound) {
                // this limits how far under the min we can go
                cam.bottomLimit = true;
                deltaAmount = 0.0;
            }
        }else if ( eyeHeight > cam.maxSceneBound ) {
            if ( prevEyeHeight > cam.maxSceneBound ) {
                // This limits how far over the max we can go
                cam.topLimit = true;
                deltaAmount = 0.0;
            }
        }

        return deltaAmount;
    }

    function getMoveAmountFromCursorOffset(offset){
        // Manipulating with power of 2 of cursor offset allows to amplify the visible change in the offset
        // when the offset is big to achieve the effect ofhigher sensitivity of the tool on small offsets
        // and lower sensitivity on big offsets.
        var derivedOffset = Math.pow (offset, 2.0);
        if (offset < 0){
            derivedOffset = -derivedOffset;
        }

        //delta.y = derivedOffset;
        var delta = convertCoordsToWindow( 0, derivedOffset );
        var sceneHeight = cam.maxSceneBound - cam.minSceneBound;

        // This empirical step provides a good motion of the scene when moving up/down.
        var p = sceneHeight * 0.01;
        delta.y *= p;

        var deltaAmount = cam.userHeightSpeed * delta.y;
        deltaAmount = checkBoundaryConditions(deltaAmount, offset, cam.m_amount);

        return deltaAmount;
    }

    //draw UI for up-down operation during mouse move
    this.onDrawHeight = function(mouse, pX, pY, dragged, path){
        var sliderHeight = 86;
        var upDir = new THREE.Vector3(0,1,0);
        var h = camera.position.clone().dot(upDir);
        var unitHeight = Math.linearClamp( h, cam.minSceneBound, cam.maxSceneBound );
        var height = unitHeight - 0.5 ;
        if( cubeContainer ) {
            cubeContainer.find("img#updownImageA").remove();
            cubeContainer.prepend('<img src="'+path+'SWheighthandleA.png" id="updownImageA" style="position:fixed; z-index:9999; top:'+(pY - sliderHeight * height)+'px; left:'+pX+'px;"/>');

            if (!dragged){
                cubeContainer.prepend('<img src="'+path+'SWheighthandleI.png" id="updownImageI" style="position:fixed; z-index:9998; top:'+(pY - sliderHeight * height)+'px; left:'+(pX)+'px;"/>');
            }
        }
    };

    /**
     * Draws a menu by appending an unordered list to the given container element.
     * @param {Array} menuOptions - string array of menu options, null meaning seperator
     * @param {Array} menuEnables - boolean array of menu enable flags indicating which corresponding menu entry in menuOptions should be enabled or disabled.
     * @param {Number} mousex - the x coordinate of the menu trigger point, used to position menu
     * @param {Number} mousey - the y coordinate of the menu trigger point, used to position menu
     * @param {HTMLElement} container - the container element to add the menu to.
     * @param {Object} position - object with x, y, w, h of the container element.
     */
    this.drawDropdownMenu = function(menuOptions, menuEnables, menuCallbacks, mousex, mousey, container, position) {
        var itemID = 0;

        if( !dropDownMenu ) {

            dropDownMenu = document.createElement('div');
            dropDownMenu.className = 'dropDownMenu';

            // Initialize the top and left with some approximate values
            // so that the correct width can be returned by gerBoudningClientRect().
            dropDownMenu.style.top    = '100px';
            dropDownMenu.style.left   = '-400px';

            var menuHeight = 0;
            var menuMinWidth = 0;
            for (var i = 0; i<menuOptions.length; i++){
                var listItem;
                if (menuOptions[i] === null) {                       // menu separator
                    listItem = document.createElement("li");
                    listItem.style.height = '1px';
                    menuHeight += 1;
                    listItem.style.backgroundColor="#E0E0E0";
                } else {
                    var content = Autodesk.Viewing.i18n.translate(menuOptions[i]);
                    menuMinWidth = content.length > menuMinWidth ? content.length : menuMinWidth;

                    if( menuCallbacks[i] ) {
                        listItem = document.createElement("div");
                        var check = document.createElement("input");
                        var text  = document.createElement("label");
                        check.type = "radio";
                        check.className = "dropDownMenuCheck";
                        text.innerHTML = content;
                        text.className = "dropDownMenuCheckText";
                        listItem.appendChild(check);
                        listItem.appendChild(text);
                        listItem.className = "dropDownMenuCheckbox";
                    }
                    else {
                        listItem = document.createElement("li");
                        listItem.textContent = content;
                        listItem.className = menuEnables[i] ? "dropDownMenuItem" : "dropDownMenuItemDisabled";
                    }

                    listItem.id = "menuItem" + itemID;
                    itemID++;
                    menuHeight += 25;       // HACK!!!

                    listItem.setAttribute( "data-i18n", menuOptions[i] );
                }
                dropDownMenu.appendChild(listItem);
            }

            // Add the menu to the DOM before asking for boundingClientRect.
            // Otherwise, it will be zero.
            container.appendChild(dropDownMenu);

            dropDownMenu.style.minWidth = Math.max(256, menuMinWidth * 7.4) + 'px'; // approximate min width
            var menuWidth = dropDownMenu.getBoundingClientRect().width;

            this.menuSize.x = menuWidth;
            this.menuSize.y = menuHeight;
        }
        else {
            // Just add the drop down menu, It already exists.
            container.appendChild(dropDownMenu);
        }
        itemID = 0;
        for (var i = 0; i<menuOptions.length; i++) {
            if( menuOptions[i] === null )
                continue;

            if( menuCallbacks[i] ) {
                var id = "menuItem" + itemID;
                var element = document.getElementById(id);
                if( element ) {
                    element.children[0].checked = menuCallbacks[i]();
                }
            }
            itemID++;
        }
        var top  = mousey - 15;        // 15 offset so list appears @ button
        var left = mousex + 1;

        var rect = this.canvas.getBoundingClientRect();

        if( (left + this.menuSize.x) > rect.right )
            left = mousex - this.menuSize.x - 1;
        if( (top + this.menuSize.y) > rect.bottom )
            top = rect.bottom - this.menuSize.y;

        // Make relative to container:
        top  -= position.y;
        left -= position.x;

        dropDownMenu.style.top  = top + 'px';
        dropDownMenu.style.left = left + 'px';

        this.menuOrigin.x = left;
        this.menuOrigin.y = top;
    };


    this.removeDropdownMenu = function(container) {
        container.removeChild(dropDownMenu);
    };

    function isAxisAligned(vec) {
        var sceneRight  = cam.sceneFrontDirection.clone().cross(cam.sceneUpDirection);
        var checkUp    = Math.abs(Math.abs(vec.dot(cam.sceneUpDirection)) - 1.0);
        var checkFront = Math.abs(Math.abs(vec.dot(cam.sceneFrontDirection)) - 1.0);
        var checkRight = Math.abs(Math.abs(vec.dot(sceneRight)) - 1.0);

        return (checkUp < 0.00001 || checkFront < 0.00001 || checkRight < 0.00001);
    }

    this.isFaceView = function() {
        var dir = this.center.clone().sub(camera.position).normalize();
        return isAxisAligned(dir) && isAxisAligned(camera.up);
    };

    this.startInteraction = function (x, y) {
        this.startCursor = new THREE.Vector2(x, y);

        this.startState = {
            saveCenter: this.center.clone(),
            saveEye:    this.camera.position.clone(),
            savePivot:  this.pivot.clone(),
            saveUp:     this.camera.up.clone()
        };

        this.lockDeltaX = 0.0;
        this.lockedX = false;
        this.lastSnapRotateX = 0.0;
        this.lockDeltaY = 0.0;
        this.lockedY = false;
        this.lastSnapRotateY = 0.0;
        this.lastSnapDir = new THREE.Vector3(0,0,0);

        this.navApi.setTransitionActive(true);
    };

    this.orbit = function (currentCursor, startCursor, distance, startState){
        if( !this.navApi.isActionEnabled('orbit') || this.currentlyAnimating === true )
            return;

        var mode = 'wheel';

        // If orthofaces is enabled, and camera is ortho
        // then switch to perspective
        if(cam.orthographicFaces && !camera.isPerspective) {
            camera.toPerspective();

            // Hack: update the start state with the new position:
            if( startState )
                startState.saveEye.copy(this.camera.position);
        }
        if (startState){
            mode = 'cube';
        }
        if (mode == 'cube'){
            this.saveCenter.copy(startState.saveCenter);
            this.saveEye.copy(startState.saveEye);
            this.savePivot.copy(startState.savePivot);
            this.saveUp.copy(startState.saveUp);
            this.useSnap = true;
            this.doCustomOrbit = true;
        } else {
            this.saveCenter.copy(this.center);
            this.savePivot.copy(this.pivot);
            this.saveEye.copy(camera.position);
            this.saveUp.copy(camera.up);
            this.useSnap = false;
            this.doCustomOrbit = false;
        }

        if (IsCombined() && prevCenter == undefined) {
            prevCenter = this.saveCenter.clone();
            prevEye    = this.saveEye.clone();
            prevPivot  = this.savePivot.clone();
            prevUp     = this.saveUp.clone();
        }

        // TODO: fold the two cases into one and prevent duplicate code
        if (this.preserveOrbitUpDirection ) {

            var delta = convertCoordsToWindow( currentCursor.x - startCursor.x, currentCursor.y - startCursor.y );
            var lastDelta = convertCoordsToWindow(distance.x, distance.y);

            var worldUp = this.sceneUpDirection.clone();
            var worldFront = this.sceneFrontDirection.clone();
            var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

            /* ????? WTF:
            var worldFront = new THREE.Vector3(1,0,0);
            var worldUp = new THREE.Vector3(0,1,0);
            */

            //viewcube
            // if (this.doCustomOrbit ) {
            //     worldUp = new THREE.Vector3(0,1,0);
            //     worldFront = new THREE.Vector3(1,0,0);
            // }

            /* ?????? WTF:
            var worldR = worldFront.clone().cross( worldUp );
            worldUp = worldR.clone().cross(worldFront);
            worldUp.clone().normalize();
            */

            var pivot  = IsCombined() ? prevPivot  : this.savePivot;
            var eye    = IsCombined() ? prevEye    : this.saveEye;
            var center = IsCombined() ? prevCenter : this.saveCenter;
            var camUp  = IsCombined() ? prevUp     : this.saveUp;

            var initViewDir  = pivot.clone().sub(eye).normalize();
            var initViewDirV = center.clone().sub(eye).normalize();
            var initRightDir = initViewDirV.clone().cross( camUp );

            var fTargetDist  = eye.clone().sub(pivot).length();
            var fTargetDistV = eye.clone().sub(center).length();

            var vLookUpdate  = initViewDir.clone().multiplyScalar(-1);
            var vLookUpdateV = initViewDirV.clone().multiplyScalar(-1);
            var vRightUpdate = initRightDir;
            var vUpUpdate = camUp.clone();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube

            // DOESN'T DO ANYTHING: snapToClosestView(worldUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ) {
                // Need to check if:
                //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
                //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
                // These cases required a reversed rotation direction to maintain consistent mapping of tool:
                //  left->clockwise, right->counter-clockwise
                //
                //  PHB June 2014 - #2 above makes no sense to me. If the camera up is perpendicular to the
                //  world up then the view is parallel to world up (view dot up == 1). So the second test is
                //  meaningless. There is no good way to determine the rotation direction in this case. If you
                //  want it to feel like direct manipulation then it would be better to determine if the cursor
                //  is above or below the pivot in screen space.

                var worldUpDotCamUp = worldUp.dot(this.saveUp);
                // var worldUpDotView  = worldUp.dot(this.saveCenter.clone().sub(this.saveEye).normalize());

                // if ((worldUpDotCamUp < -Number.MIN_VALUE) ||
                //     ((Math.abs(worldUpDotCamUp) < Number.MIN_VALUE) && (worldUpDotView > 0.0)))
                //
                var kFlipTolerance = 0.009;     // Must be flipped by more than about 0.5 degrees
                if( worldUpDotCamUp < -kFlipTolerance ) {
                    delta.x = -delta.x;
                    lastDelta.x = -lastDelta.x;
                }

                var dHorzAngle = 0.0;
                if (IsCombined()) {
                    dHorzAngle = lastDelta.x * this.orbitMultiplier;
                } else {
                    dHorzAngle = this.useSnap ? this.lastSnapRotateX + getNextRotation('h', snapAngleh, -lastDelta.x) :
                        delta.x * this.orbitMultiplier;
                }

                this.lastSnapRotateX = dHorzAngle;
                // Define rotation transformation

                var quatH = new THREE.Quaternion().setFromAxisAngle( worldUp, -dHorzAngle );

                vLookUpdate.applyQuaternion(quatH);
                vLookUpdateV.applyQuaternion(quatH);
                vRightUpdate.applyQuaternion(quatH);
                vUpUpdate.applyQuaternion(quatH);
            }

            if ( !this.constrainOrbitVertical ) {
                var vRightProjF = worldFront.clone().multiplyScalar(worldFront.dot(vRightUpdate));
                var vRightProjR = worldRight.clone().multiplyScalar(worldRight.dot(vRightUpdate));
                var vRightProj = vRightProjF.clone().add(vRightProjR);
                vRightProj.clone().normalize();

                var dVertAngle = 0.0;

                if (IsCombined()){
                    dVertAngle = lastDelta.y * this.orbitMultiplier;
                }else{
                    var next = getNextRotation('v', snapAnglev, lastDelta.y);
                    dVertAngle = this.useSnap ? this.lastSnapRotateY + next : delta.y * this.orbitMultiplier;
                }
                var quatV = new THREE.Quaternion().setFromAxisAngle( vRightProj, -dVertAngle );

                if( !this.navApi.getOrbitPastWorldPoles() ) {

                    var vUpUpdateTemp = vUpUpdate.clone();
                    vUpUpdateTemp.applyQuaternion(quatV).normalize();

                    // Check if we've gone over the north or south poles:
                    var wDotC = worldUp.dot(vUpUpdateTemp);
                    if( wDotC < 0.0 )
                    {
                        var vLookUpdateVtemp = vLookUpdateV.clone();
                        vLookUpdateVtemp.applyQuaternion(quatV).normalize();

                        // How far past Up are we?
                        var dVertAngle2 = vLookUpdateVtemp.angleTo(worldUp);
                        if( Math.abs(dVertAngle2) > (Math.PI * 0.5) )
                            dVertAngle2 -= (dVertAngle2 > 0.0) ? Math.PI : -Math.PI;

                        dVertAngle -= dVertAngle2;

                        quatV.setFromAxisAngle( vRightProj, -dVertAngle );
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();

                    }
                    else
                    {
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();
                    }
                }
                else
                {
                    vLookUpdate.applyQuaternion(quatV).normalize();
                    vLookUpdateV.applyQuaternion(quatV).normalize();
                    vUpUpdate.applyQuaternion(quatV).normalize();
                }
                this.lastSnapRotateY = dVertAngle;
            }

            // figure out new eye point
            var vNewEye = vLookUpdate.multiplyScalar(fTargetDist).add(pivot);

            camera.position.copy(vNewEye);
            camera.up.copy(vUpUpdate);
            this.center.copy(vNewEye);
            this.center.sub(vLookUpdateV.multiplyScalar(fTargetDistV));

            if( IsCombined() )
            {
                prevCenter.copy(this.center);
                prevEye.copy(camera.position);
                prevPivot.copy(this.pivot);
                prevUp.copy(camera.up);
            }
        }
        else {
            /*var lastDelta = convertCoordsToWindow(distance.x, distance.y);
            var vDir = prevPivot.clone().sub(prevEye);
            var vDirView = prevCenter.clone().sub(prevEye);
            var vRight = vDirView.clone().cross(prevUp);
            var vUp = vRight.clone().cross(vDirView);
            vUp.clone().normalize();

            var dist = (prevPivot.clone().sub(prevEye)).clone().length();
            var distView = (prevCenter.clone().sub(prevEye)).clone().length();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube
            //snapToClosestView(vUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ){

            var dHorzAngle = this.useSnap ? getNextRotation(HORIZONTAL, snapAngleh, lastDelta.x):
            lastDelta.x *this.orbitMultiplier;

            var quatH = new THREE.Quaternion().setFromAxisAngle( vUp.clone().normalize(), dHorzAngle );
            vDir = quatH.clone().rotate(vDir);
            vDirView = quatH.clone().rotate(vDirView);
            }

            if ( !this.constrainOrbitVertical ){
            var dVertAngle = this.useSnap ? getNextRotation(VERTICAL, snapAnglev, lastDelta.y) :
            lastDelta.y *this.orbitMultiplier;

            var quatV = new THREE.Quaternion().setFromAxisAngle( vRight.clone().normalize(), dVertAngle );
            vDir = quatV.clone().rotate(vDir);
            vDirView = quatV.clone().rotate(vDirView);
            vUp = quatV.clone().rotate(vUp);
            }

            camera.eye = this.pivot.clone().sub((vDir.clone().normalize()).clone().multiplyScalar(dist));
            this.center.copy(camera.eye.clone().add((vDirView.clone().normalize()).clone().multiplyScalar(distView)));
            camera.up.copy(vUp.clone().normalize());

            prevCenter = this.center;
            prevEye = camera.position;
            prevPivot = this.pivot;
            prevUp = camera.up;*/
        }
        camera.lookAt(this.center);
        changed(false);

        /*avp.logger.log("Camera Position: ( "+camera.position.x +", "+camera.position.y+", "+camera.position.z+" )");
        avp.logger.log("Up Vector: ( "+camera.up.x +", "+camera.up.y+", "+camera.up.z+" )");
        avp.logger.log("Center: ( "+this.center.x +", "+this.center.y+", "+this.center.z+" )");
        */
    };

    this.endInteraction = function() {

        this.navApi.setTransitionActive(false);
    };

    this.look = function( distance ){
        if( !this.navApi.isActionEnabled('walk') )
            return;

        var delta = convertCoordsToWindow(distance.x, distance.y);
        var multiplier = this.userLookSpeed;

        //if ( m_manager->GetApplicationParameters().lookInvertVerticalAxis ) { deltaY = -deltaY; }

        var eyeToCenter = this.getView();

        var camUp = camera.up;
        var camRight = eyeToCenter.clone().cross(camUp).normalize();
        var worldUp = this.sceneUpDirection.clone();

        // TODO: scale look by camera's FOV
        // vertical rotation around the camera right vector
        var angle = delta.clone();
        angle.x *= Math.PI;
        angle.y *= Math.PI / camera.aspect;
        angle.multiplyScalar(multiplier);
        var qRotY = new THREE.Quaternion().setFromAxisAngle( camRight, -angle.y);

        if (camera.keepSceneUpright && !this.navApi.getOrbitPastWorldPoles()) {
            var futureUp = camUp.clone();
            futureUp.applyQuaternion(qRotY).normalize();

            if (futureUp.dot(worldUp) < 0) {
                var futureEyeToCenter = eyeToCenter.clone();
                futureEyeToCenter.applyQuaternion(qRotY);

                var deltaAngle = futureEyeToCenter.angleTo(worldUp);

                if(Math.abs(deltaAngle) > (Math.PI * 0.5))
                    deltaAngle -= (deltaAngle > 0.0) ? Math.PI : -Math.PI;

                angle.y -= deltaAngle;

                qRotY.setFromAxisAngle(camRight, -angle.y);
            }
        }

        eyeToCenter = qRotY.clone().rotate(eyeToCenter);
        camUp = qRotY.clone().rotate(camUp);
        camUp.normalize();

        var vertAxis = camera.keepSceneUpright ? worldUp : camUp;
        var qRotX = new THREE.Quaternion().setFromAxisAngle( vertAxis, -angle.x );

        eyeToCenter = qRotX.clone().rotate( eyeToCenter );
        camUp = qRotX.clone().rotate( camUp );

        this.center.copy(eyeToCenter.add(camera.position));
        camera.up.copy(camUp);

        camera.lookAt(this.center);
        changed(false);
    };

    this.pan = function ( distance ) {
        if( !this.navApi.isActionEnabled('pan') )
            return;

        distance = convertCoordsToWindow(distance.x, distance.y);

        var W = this.getView();
        var U = camera.up.clone().cross(W);
        var V = W.clone().cross(U);

        U.normalize();
        V.normalize();
        W.normalize();

        var Pscreen = this.pivot.clone().sub(camera.position);
        var screenW = W.clone().dot(Pscreen);
        var screenU = screenW * (Math.tan( THREE.Math.degToRad(camera.leftFov)) + Math.tan(THREE.Math.degToRad(camera.rightFov)));
        var screenV = screenW * (Math.tan( THREE.Math.degToRad(camera.topFov)) + Math.tan(THREE.Math.degToRad(camera.bottomFov)));

        var offsetU = distance.x * Math.abs(screenU);
        var offsetV = distance.y * Math.abs(screenV);

        var offset = new THREE.Vector3();
        var u = U.clone().multiplyScalar(offsetU);
        var v = V.clone().multiplyScalar(offsetV);

        offset = (u.clone().add(v)).clone().multiplyScalar(this.userPanSpeed);

        camera.position.add(offset);
        this.center.add(offset);

        camera.lookAt(this.center);
        changed(false);
    };

    this.zoom = function(zoomDelta){
        if( !this.navApi.isActionEnabled('zoom') )
            return;

        //TODO: bug - when pivot is set outside the object, object zooms past the pivot point
        var zoomMin = 0.05;
        var zoomBase = this.userZoomSpeed;
        var distMax = Number.MAX_VALUE;
        var deltaXY = zoomDelta.x + zoomDelta.y;
        var dist = Math.pow ( zoomBase, deltaXY);

        var zoomPosition = (this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye).clone()).multiplyScalar(dist)));
        var zoomCenter = zoomPosition.clone().add(cam.D.clone().multiplyScalar(cam.D.clone().dot((this.pivot.clone().sub(zoomPosition)).clone())));

        if (dist >= distMax)
            return;

        if (deltaXY > 0.0){
            var snapSize = 0;
            var dist2 = Math.pow(zoomBase, deltaXY - snapSize);

            // PERSP zoom out
            if ( deltaXY < snapSize ){
                // inside the zoomout speedbump region
                unitAmount = 0.0;
                return;

            } else {
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);

                var EprojD = (zoomPosition.clone().sub(this.saveEye)).dot(cam.D);

                if ( EprojD > distMax ) {
                    camera.position.copy((this.saveEye.sub(cam.D)).clone().multiplyScalar(distMax));
                    unitAmount = (distMax > 0.0) ? -1.0 : 0.0;
                } else {
                    unitAmount = -(EprojD / distMax);
                }
            }
        } else {


            camera.position.copy(zoomPosition);
            this.center.copy(zoomCenter);

            //Zoom In
            /*if ( dist < zoomMin) {
                //exponential zoom moved in as far as it can
                var zoomMinLinear = ( Math.log(zoomMin) / Math.log(zoomBase) );
                var distLinearXY = Math.abs(deltaXY) - Math.abs(zoomMinLinear);
                var snapSize = 0;

                // do linear zoomin
                if ( distLinearXY > snapSize ) {

                    var distLinearXY = distLinearXY - snapSize/window.innerHeight;
                    var amount = -distLinearXY;

                    var multiplier = this.userZoomSpeed;
                    var dist2 = amount * multiplier;

                    var Esnap = this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(zoomMin));
                    var E = Esnap.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(dist2));

                    this.center.copy(E.clone().add(cam.D.clone().multiplyScalar(zoomMin)));
                    camera.position.copy(E);
                }
            } else {
                cam.D = (this.saveCenter.clone().sub(this.saveEye)).clone().normalize();
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);
            }*/
        }
        camera.lookAt(this.center);
        changed(false);
    };

    this.walk = function(currentCursor, startCursor, movementX, movementY, deltaTime){
        if( !this.navApi.isActionEnabled('walk') )
            return;

        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection);
        //TODO: figure out what deltaTime does

        var flyPlanarMotion = true;
        var flyUpDownSensitivity = 0.01;

        if (isInDeadZone(currentCursor, startCursor)){
            wheel.cursorImage('SWWalk');
            setBias(true, currentCursor, startCursor);
            x = startCursor.x;
            y = startCursor.y;
        }else{
            setBias(false, currentCursor, startCursor);
        }

        //x = currentCursor.x - m_resetBiasX;
        //y = currentCursor.y - m_resetBiasY;
        x = currentCursor.x;
        y = currentCursor.y;

        var delta = convertCoordsToWindow( x - startCursor.x, y - startCursor.y );

        var fInitialMoveX = -delta.x;
        var fInitialMoveY = -delta.y;
        var fSignX = (fInitialMoveX < 0.0) ? -1.0 : 1.0;
        var fSignY = (fInitialMoveY < 0.0) ? -1.0 : 1.0;
        var fMoveX = Math.abs(fInitialMoveX);
        var fMoveY = Math.abs(fInitialMoveY);

        var deadzoneRadius = new THREE.Vector2(30, 30);
        deadzoneRadius = convertCoordsToWindow (deadzoneRadius.x, deadzoneRadius.y);

        fMoveX = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveX) - deadzoneRadius.x;
        fMoveY = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveY) - deadzoneRadius.y;

        var rampRadius = 0.25;
        fMoveX /= rampRadius;
        fMoveY /= rampRadius;

        fMoveX = ( fMoveX < 1.0 ) ? Math.easeClamp( fMoveX, 0.0, 1.0 ) : Math.pow(fMoveX, 1.0);
        fMoveY = ( fMoveY < 1.0 ) ? Math.easeClamp( fMoveY, 0.0, 1.0 ) : Math.pow(fMoveY, 1.0);


        // scale by time
        //fMoveX *= deltaTime;
        //fMoveY *= deltaTime;

        var fDeltaX = (fMoveX > 0.0) ? fMoveX * fSignX : 0.0;
        var fDeltaY = (fMoveY > 0.0) ? fMoveY * fSignY : 0.0;

        var vViewDir = this.getView();
        var fViewDist = vViewDir.length();
        vViewDir.normalize();

        var vRightDir = vViewDir.clone().cross( camera.up );
        vRightDir.normalize();

        // project vViewDir onto plane perpendicular to up direction to get
        // better walking inside houses, etc
        // (but prevents flying down to model from 3/4 view...)

        var vYViewDirRight = worldRight.clone().multiplyScalar(worldRight.clone().dot(vViewDir));
        var vYviewDirFront = worldFront.clone().multiplyScalar(worldFront.clone().dot(vViewDir));
        var vYViewDir = vYviewDirFront.clone().add(vYViewDirRight);

        vYViewDir = (vYViewDir.clone().length() > Number.MIN_VALUE) ? vYViewDir.normalize() : camera.up;

        var scale = 1.0;
        var fDollyDist = fDeltaY * (this.walkMultiplier * scale );

        var dir = flyPlanarMotion ? vYViewDir : vViewDir;


        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // To avoid perceptually confusing motion, force a reversal of flying direction along a shifted axis

           // Angle to offset threshold from up-axis
           // TODO: make cos(0.65) into an AutoCam Parameter
           var dDirThreshold = Math.cos(0.65);

           if ((dDirThreshold != 1) &&
               (((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) < -dDirThreshold)) ||
                   ((worldUp.clone().dot(camera.up) > Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) > dDirThreshold)))) {
               dir = -dir;
           }
        }


        var fSpinAngle = -fDeltaX *this.walkMultiplier*0.05;

        // rotate around world-up vector instead of CameraOperations up vector (more like head movement!)
        //Quaternion quat( m_cameraParams.up, (float)fSpinAngle );

        // Define rotation axis direction
        var vRotAxis = camera.up;

        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // Need to check if:
            //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
            //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
            // These cases require a reversed rotation direction to maintain consistent mapping of tool:
            //  left->clockwise, right->counter-clockwise
            if ((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) ||
                ((Math.abs(worldUp.clone().dot(camera.up)) < Number.MIN_VALUE)
                    && (worldUp.clone().dot(vViewDir) > Number.MIN_VALUE))) {
                fSpinAngle = -fSpinAngle;
            }
            vRotAxis = worldUp;
        }

        // Define rotation transformation

        var quat = new THREE.Quaternion().setFromAxisAngle( vRotAxis, fSpinAngle );
        quat.normalize();

        vViewDir = quat.clone().rotate( vViewDir );
        vViewDir.normalize();
        camera.up.copy(quat.clone().rotate( camera.up ));
        camera.up.normalize();

        camera.position.add(dir.clone().multiplyScalar(fDollyDist));
        this.center.copy(camera.position.clone().add(vViewDir.clone().multiplyScalar(fViewDist)));

        dir = flyPlanarMotion ? worldUp : camera.up;
        dir.normalize();

        if(fDollyDist === 0)
            fDollyDist = flyUpDownSensitivity;

        camera.lookAt(this.center);
        changed(false);
    };

    this.updown = function(movementY){
        if( this.navApi.getIsLocked() )
            return;

        var deltaCursor = movementY;
        var deltaAmount = getMoveAmountFromCursorOffset(deltaCursor);

        cam.m_amount += deltaAmount;

        var upDir = new THREE.Vector3(0,1,0);

        var eye = cam.saveEye.clone().sub(upDir.clone().multiplyScalar(cam.m_amount));
        var eyeHeight = eye.clone().dot(upDir);

        camera.position.copy(eye);

        if ( eyeHeight < cam.minSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.minSceneBound - eyeHeight));
        }

        if ( eyeHeight > cam.maxSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.maxSceneBound - eyeHeight));
        }

        this.center.copy(camera.position.clone().add(cam.saveCenter.clone().sub(cam.saveEye)));
        camera.lookAt(this.center);
        changed(false);
    };


    /*      REWIND FUNCTIONS */

    /**
     * This takes a snapshot of the current camera passed into Autocam and saves it to the history. A screenshot
     * is taken of the sceneContainer canvas
     */
    this.addHistoryElement = function(){

        // --- We don't require history being saved ---

        // if (cam.rewindParams.maxHistorySize > 0 && cam.rewindParams.history.length >= cam.rewindParams.maxHistorySize){
        //     this.rewindParams.history.shift();
        // }

        // //reset previous 1 or 2 weights to 0
        // if (cam.rewindParams.history.length == 1){
        //     cam.rewindParams.history[0].weight = 0.0;
        // }else if (cam.rewindParams.history.length > 1){
        //     cam.rewindParams.history[cam.rewindParams.history.length -1].weight = 0.0;
        //     cam.rewindParams.history[cam.rewindParams.history.length -2].weight = 0.0;
        // }

        // var element = {};
        // element.thumbnail = document.getElementById("sceneContainer").toDataURL("image/png");
        // element.thumbnailBounds = new THREE.Box2(new THREE.Vector2(0,0),new THREE.Vector2(56,56));
        // element.camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        // element.camera.position = camera.position.clone();
        // element.camera.up = camera.up.clone();
        // element.camera.rotation = camera.rotation.clone();
        // element.camera.leftFov = camera.leftFov;
        // element.camera.rightFov = camera.rightFov;
        // element.camera.topFov = camera.topFov;
        // element.camera.bottomFov = camera.bottomFov;
        // element.camera.center = cam.center.clone();
        // element.camera.pivot = cam.pivot.clone();
        // element.weight = 1.0;
        // element.isEmptyScene = false;

        // //IF SCENE OUTSIDE VIEW SET ISEMPTYSCENE TO TRUE

        // cam.rewindParams.history.push(element);
        // cam.rewindParams.snapped = true;
        // cam.rewindParams.slideOffset.x=0;
        // cam.rewindParams.timelineIndex = cam.rewindParams.history.length - 1;
        // cam.rewindParams.timelineIndexSlide = cam.rewindParams.timelineIndex;
    }

    /**
     * This handles any case where the user rewinds and then does any transformations, the history is sliced depending
     * on where the user rewinds to
     */
    this.addIntermediateHistoryElement = function(){

        if (this.rewindParams.snapped){
            this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
        }else{
            if (this.rewindParams.slideOffset.x > 0){
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
            } else{
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex+1);
            }
        }
        this.addHistoryElement();
    };

    this.clearHistory = function(){
        this.rewindParams.history.length = 0;
        this.rewindParams.timelineIndex = 0;
        this.rewindParams.timelineIndexSlide = 0;
        this.rewindParams.resetWeights = true;
    };

    this.openTimeline = function (location){
        this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;

        if (this.rewindParams.resetWeights){
            this.rewindParams.slideOffset.x = 0;
            this.rewindParams.snapped = this.rewindParams.snappingEnabled;
        }

        //if haven't applied any transformations before clicking rewind
        if (this.rewindParams.history.length === 0) this.addHistoryElement();

        for ( var i = 0; i < this.rewindParams.history.length; i++ )
        {
            var index = i - this.rewindParams.timelineIndex;
            var size = this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize;

            this.rewindParams.history[i].thumbnailBounds.setCenter(new THREE.Vector2(location.x + index * size, location.y).add(this.rewindParams.slideOffset));

            if (this.rewindParams.resetWeights)
            {
                this.rewindParams.history[i].weight = (i==this.rewindParams.timelineIndex)? 1.0:0.0;
            }
        }

        if ( this.rewindParams.resetWeights )
        {
            this.rewindParams.resetWeights = false;
        }

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) *2.0;
        this.rewindParams.open = true;
        this.rewindParams.openLocation = location.clone();
        this.rewindParams.openLocationOrigin = location.clone();
        this.rewindParams.openBracket = location.clone();
        this.rewindParams.openBracketA = new THREE.Vector2(size, location.y);
        this.rewindParams.openBracketB = new THREE.Vector2(window.innerWidth - size, location.y);
        // make sure dead-zone is well formed ... i.e. A.x < B.x
        if (this.rewindParams.openBracketA.x > this.rewindParams.openBracketB.x) {
            var swap = this.rewindParams.openBracketA.x;
            this.rewindParams.openBracketA.x = this.rewindParams.openBracketB.x;
            this.rewindParams.openBracketB.x = swap;
        }
        this.rewindParams.locationOffset = new THREE.Vector2(0,0);
        this.rewindParams.snapOffset = new THREE.Vector2(0,0);
    };

    this.slideTimeline = function(location_){
        /*
         Basic Idea:
         Behaviour of the current rewind timeline is similar to a tracking menu. There is a "deadzone"
         region where cursor movement does not slide the thumbnails. As the cursor goes outside the
         region, thumbnails slide to align the closest edge of the timeline to the cursor ('extent'
         variable is this sliding amount). The edges of the deadzone region are stored in
         'm_openBracketA/B' variables, and slide around with the timeline. Draw some icons at bracket
         positions to visualize the process.
         */

        if ( !this.rewindParams.open || this.rewindParams.history.length === 0  ) { return; }

        var location =  location_.clone().add(this.rewindParams.locationOffset);

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0;
        var bracketA = size;
        var bracketB = window.innerWidth - size;

        var edgeA = this.rewindParams.history[0].thumbnailBounds.center().x;
        var edgeB = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;

        var extent = 0.0;

        if ( location.x < this.rewindParams.openBracketA.x )
        {
            extent = location.x - this.rewindParams.openBracketA.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeAnew = edgeA - extent;

            if ( bracketA < edgeAnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.min( extent + (edgeAnew - bracketA), 0.0);
            }
        }
        if ( location.x > this.rewindParams.openBracketB.x )
        {
            extent = location.x - this.rewindParams.openBracketB.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeBnew = edgeB - extent;

            if ( bracketB > edgeBnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.max( extent + (edgeBnew - bracketB), 0.0);
            }
        }

        this.rewindParams.openLocation.x += extent;
        this.rewindParams.openBracketA.x += extent;
        this.rewindParams.openBracketB.x += extent;

        this.rewindParams.openBracket.x = location.x - ( this.rewindParams.openLocation.x - this.rewindParams.openLocationOrigin.x );

        var iconOffset = new THREE.Vector2( -extent, 0.0 );

        var L = location.clone().sub( this.rewindParams.openLocation.clone().sub(this.rewindParams.openLocationOrigin));

        // snapping

        iconOffset.x += this.rewindParams.snapOffset.x;
        this.rewindParams.snapOffset.x = 0.0;

        var snapped = false;

        if ( this.rewindParams.snappingEnabled )
        {
            var kEnterSnapDistance = 4.0;
            var kLeaveSnapDistance = 16.0;

            for ( var i = 0; i < this.rewindParams.history.length; i++ )
            {
                var P = this.rewindParams.history[i].thumbnailBounds.center().add(iconOffset);
                if ( Math.abs(P.x - L.x) < kEnterSnapDistance || (this.rewindParams.snapped && Math.abs(P.x - L.x) < kLeaveSnapDistance) )
                {
                    snapped = true;
                    if (extent !== 0.0)
                    {
                        this.rewindParams.snapOffset.x = P.x - L.x;
                        iconOffset.x -= this.rewindParams.snapOffset.x;
                    }
                    else
                    {
                        this.rewindParams.openBracket.x += P.x - L.x;
                    }
                    L.x = P.x;
                    break;
                }
            }
        }

        this.rewindParams.snapped = snapped;

        var weightMax = -1.0;
        var weightTotal = 0.0;
        for ( var j = 0; j < this.rewindParams.history.length; j++ )
        {
            var tempBox = this.rewindParams.history[j].thumbnailBounds.clone();

            // slide the thumbnails
            this.rewindParams.history[j].thumbnailBounds.setCenter(this.rewindParams.history[j].thumbnailBounds.center().add(iconOffset));

            if (this.rewindParams.history[j].thumbnail )
            {
                var leftEdge = this.rewindParams.history[j].thumbnailBounds.center().x - this.rewindParams.thumbnailSize/2.0;
                $('#rewindFrame' + j).css('left', leftEdge);
                $('#rewindBorder' + j).css('left', (leftEdge-4));
            }

            // grow the copied Icon2D to touch the center of its neighbor
            //think about adding offset for frames here
            var newSize = new THREE.Vector2((this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0, (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0 );
            tempBox.setFromCenterAndSize(tempBox.center(),newSize);

            var Icon2DCoords = new THREE.Vector2(0,0);
            tempBox.getIcon2DCoords(L,Icon2DCoords);

            var weight = 1.0 - Math.abs( Math.equalityClamp(Icon2DCoords.x, -1.0, 1.0 ));
            this.rewindParams.history[j].weight = weight;

            // check for out-of-range cases
            if ( j === 0 && L.x < tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            if ( j === this.rewindParams.history.length - 1 && L.x > tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            weightTotal = weightTotal + this.rewindParams.history[j].weight;

            // find dominant thumbnail
            if ( this.rewindParams.history[j].weight > weightMax )
            {
                weightMax = this.rewindParams.history[j].weight;
                if ( this.rewindParams.snappingEnabled && this.rewindParams.history[j].weight == 1.0 ){
                    // snap to this element
                    this.rewindParams.slideOffset.x = 0;
                    this.rewindParams.snapped = true;
                }else{
                    this.rewindParams.slideOffset.x = this.rewindParams.history[j].thumbnailBounds.center().x - L.x;
                }
                this.rewindParams.timelineIndexSlide = j;
            }
        }

        // normalize the weights just in case
        for ( var k = 0; k < this.rewindParams.history.length; k++ )
        {
            this.rewindParams.history[k].weight = this.rewindParams.history[k].weight / weightTotal;
        }

        // prevent the bracket from moving off the ends of the timeline
        var xBracketMin = this.rewindParams.history[0].thumbnailBounds.center().x;
        var xBracketMax = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
        if ( this.rewindParams.openBracket.x < xBracketMin )
        {
            this.rewindParams.locationOffset.x += xBracketMin - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMin;
        }
        else if ( this.rewindParams.openBracket.x > xBracketMax )
        {
            this.rewindParams.locationOffset.x += xBracketMax - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMax;
        }
    };

    this.shiftBackOneElement = function(){
        if ( this.rewindParams.history.length !== 0 && (this.rewindParams.timelineIndex > 0 || this.rewindParams.slideOffset.x !== 0)){
            if (this.rewindParams.snapped || this.rewindParams.slideOffset.x > 0){
                this.rewindParams.timelineIndex--;
            }
            this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
            this.rewindParams.resetWeights = true;
            cam.elapsedTime = 0;
            this.animateToRewindIndex();
        }
    };

    this.animateToRewindIndex = function ()    {
        var currentTimelineIndex = this.rewindParams.timelineIndex;
        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        cam.center.copy((cam.center.clone().multiplyScalar( 1.0 - unitTime)).clone().add( this.rewindParams.history[currentTimelineIndex].camera.center.clone().multiplyScalar( unitTime )));
        camera.position.copy((camera.position.clone().multiplyScalar( 1.0 - unitTime)).clone().add(this.rewindParams.history[currentTimelineIndex].camera.position.clone().multiplyScalar( unitTime )));
        camera.up.copy(this.rewindParams.history[currentTimelineIndex].camera.up);
        cam.pivot.copy(cam.center);

        camera.lookAt(cam.center);
        changed(false);

        if( this.cube )
            requestAnimationFrame(this.cube.render);

        if( unitTime !== 1.0 )
            requestAnimationFrame(function() { cam.animateToRewindIndex();});
    };

    this.closeTimeline = function(){
        if (this.rewindParams.timelineIndex != this.rewindParams.timelineIndexSlide){
            this.rewindParams.timelineIndex = this.rewindParams.timelineIndexSlide;
        }
        this.rewindParams.open = false;
    };

    this.getInterpolatedCamera = function (){
        var interpolatedCam = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        interpolatedCam.center = new THREE.Vector3(0,0,0);
        interpolatedCam.pivot = new THREE.Vector3(0,0,0);
        interpolatedCam.leftFov = 0;
        interpolatedCam.rightFov = 0;
        interpolatedCam.topFov = 0;
        interpolatedCam.bottomFov = 0;
        interpolatedCam.up.set(0,0,0);

        for (var i = 0; i < this.rewindParams.history.length; i++){
            var frameCam = this.rewindParams.history[i].camera;
            var wi = this.rewindParams.history[i].weight;

            interpolatedCam.center.add(frameCam.center.clone().multiplyScalar(wi));
            interpolatedCam.position.add(frameCam.position.clone().multiplyScalar(wi));
            interpolatedCam.up.add(frameCam.up.clone().multiplyScalar(wi));
            interpolatedCam.rotation.add(frameCam.rotation.clone().multiplyScalar(wi));
            interpolatedCam.pivot.add(frameCam.pivot.clone().multiplyScalar(wi));
            interpolatedCam.leftFov+=(frameCam.leftFov*wi);
            interpolatedCam.rightFov +=(frameCam.rightFov*wi);
            interpolatedCam.topFov+=(frameCam.topFov*wi);
            interpolatedCam.bottomFov+=(frameCam.bottomFov*wi);
        }

        camera.position.copy(interpolatedCam.position);
        camera.up.copy(interpolatedCam.up);
        camera.rotation = interpolatedCam.rotation;
        camera.leftFov = interpolatedCam.leftFov;
        camera.rightFov = interpolatedCam.rightFov;
        camera.topFov = interpolatedCam.topFov;
        camera.bottomFov = interpolatedCam.bottomFov;
        cam.center.copy(interpolatedCam.center);
        cam.pivot.copy(interpolatedCam.pivot);
        camera.lookAt(cam.center);
        camera.up.normalize();
        changed(false);
    };

};

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

/* All coordinates in three.js are right handed
 * when looking at the Front of the Cube in the regular upright position: */
/**
 * This is the view cube class subset of Autocam
 * this class renders and provides all functionality for the view cube
 * @class
 * @param {string} tagId - html tag id where you want the view cube to render - OBSOLETE
 * @param {Object} autocam - the autocam controller object
 * @param {HTMLDivElement} cubeContainer - the HTML element to contain the view cube
 * @param {string} localizeResourcePath - relative path to localized texture images
 * @param {Object} [options] - the optional options
 * @param {string} [options.showTriad] - whether to show the triad. 'up' is given by autocam's world up
 * */
avp.Autocam.ViewCube = function (tagId, autocam, cubeContainer, localizeResourcePath, options) {

    var self = this;
    var cam = autocam;
    var camera = autocam.camera;
    autocam.setCube(this);

    // $("body").prepend("<div id='"+tagId+"' style='position: absolute; z-index: 1000; border: 2px solid red;'></div>");

    self.currentFace = "front";
    self.showTriad = options && options.showTriad;

    var edgeNames = ["top,front","top right", "top,left", "top,back", "bottom,front", "bottom,right", "bottom,left", "bottom,back", "left,front", "front,right", "right,back", "back,left"];
    var cornerNames = ["front,top,right","back,top,right","front,top,left","back,top,left","front,bottom,right","back,bottom,right","front,bottom,left","back,bottom,left"];

   /**
     *  A string array which contains the options for the view cube menu. Use null to indicate a section separator
     * @type {Array}
     */
    var menuOptionList = [
        "Go Home",                          // localized by call to drawDropdownMenu
        null,
        "Orthographic",                     // localized by call to drawDropdownMenu
        "Perspective",                      // localized by call to drawDropdownMenu
        "Perspective with Ortho Faces",     // localized by call to drawDropdownMenu
        null,
        "Set current view as Home",         // localized by call to drawDropdownMenu
        "Focus and set as Home",            // localized by call to drawDropdownMenu
        "Reset Home",                       // localized by call to drawDropdownMenu
        null,
        "Set current view as Front",        // localized by call to drawDropdownMenu
        "Set current view as Top",          // localized by call to drawDropdownMenu
        "Reset orientation"                 // localized by call to drawDropdownMenu
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuEnableList = [
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuStateCallbackList = [
        null,
        null,
        function() { return !cam.orthographicFaces && !camera.isPerspective; },
        function() { return !cam.orthographicFaces &&  camera.isPerspective; },
        function() { return cam.orthographicFaces; },
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];

    // THREE.js Scenes
    var shadowScene, cubeScene, gridScene, lineScene, triadScene, controlScene;

    // An array of objects that need to always face the camera
    var sprites = [];

    var controlCamera;
    // self.camera = new THREE.PerspectiveCamera( camera.fov, window.innerWidth / window.innerHeight, 1, 10000 );
    // make two cameras to flip between, depending if perspective or orthographic view is used.
    // TODO: scale keeps the size of the view cube the same; 45 fov used to be the default FOV. Problem with this
    // idea is that you also then need to adjust the position (and not below - setting it there does nothing) and this
    // will change the look of the perspective cube.
    self.pcam = new THREE.PerspectiveCamera( 45, 1.0, 1, 2000 ); // aspect gets truly set during Init()
    self.ocam = new THREE.OrthographicCamera(-265,265, 265,-265, -1000, 1000);
    self.ocam.fov = self.pcam.fov;
    self.ocam.aspect = self.pcam.aspect;
    self.camera = camera.isPerspective ? self.pcam : self.ocam;
    self.camera.position.copy(camera.position);
    self.center = new THREE.Vector3(0,0,0);
    self.camera.lookAt(self.center);
    // var length = camera.position.length();

    // THREE.js Meshes
    var cube, line, home, shadow, context;
    var gridMeshes = [];
    var arrowGroup;

    // Sizes for Three.js renderers
    //var windowHalfX;
    //var windowHalfY;

    // Buffers and past INTERSECTS used for mouse picking
    var arrowBuffer = [];
    var intersectsFace = [];
    var controlBuffer = [];
    var cubeBuffer = [];
    var INTERSECTED = null;
    var INTERSECTED_F = null;
    var INTERSECTED_C = null;
    var rollLeftOffset, rollRightOffset, rollOffset;
    var homeOffset, menuOffset;

    // Size of cube in relation to HTML tag
    var cubeSize = 0;

    // Position of HTML element
    var position;

    // Used to wait for textures to load before rendering the View Cube
    var loadedTextureCount = 0;

    // Flags
    // Whether arrows (orthogonal and roll) are visible (i.e., you're directly facing a cube face).
    var _orthogonalView = true;
    var _havePointerLockFeature = false;
    var _havePointerLock = false;
    var _pointerLockMoveBugSPK865 = false;
	var _isChrome = (navigator.userAgent.search("Chrome") != -1);
	var _isWindows = (navigator.platform.search("Win32") != -1);
    var _dragged = false;
    var _transparent = false;

    // store all loaded textures here so we are not constantly re-downloading them
    var changingTextures = [];

    // Height and Width of the renderer
    // may be referred to as self.width and self.height
    this.width = 0;
    this.height = 0;

    // Public changeable values
    /**
     * view cube animation speed (not 0 or negative),
     * specified in time (milliseconds) to complete an animation
     * @type {Number}
     */
    this.animSpeed = 500;
    /**
     * turn on and off animation
     * @type {Boolean}
     */
    this.animate = true;
    /**
     * turn on and off ability to drag the view cube
     * @type {Boolean}
     */

    this.compass = false;
    this.viewScaleFactorCompass = 1.5;
    this.viewScale = 1; // Set in Init based on cubeSize

    this.draggable = true;

    /**
     * turn on and off the availability of the home button;
     * note, this is a "second", smaller home button, you probably
     * do not want it.
     * @type {Boolean}
     */
    this.wantHomeButton = false;

    /**
     * turn on and off the availability of the roll arrows
     * @type {Boolean}
     */
    this.wantRollArrows = true;

    /**
     * turn on and off the availability of the menu icon
     * @type {Boolean}
     */
    this.wantContextMenu = true;

    /**
     * opacity when inactive (transparency must be enabled)
     * @type {Number}
     */
    this.inactiveOpacity = 0.5;

    /** Function to get position of html element on screen
     *
     * @param element - HTML DOM element to find position of
     * @return {Object} - object which specifies x and y screen coordinates of location of input element
     */
    var getPosition = function (element) {
        var rect = element.getBoundingClientRect();
        return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };

        /*
        var xPosition = window.pageXOffset;
        var yPosition = window.pageYOffset;

        while (element) {
            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
            element = element.offsetParent;
        }
        return { x:xPosition, y:yPosition };
        */
    };

    /** Used by pointer lock API
     *
     * @param {Object} e - event object
     */
    var pointerLockChange = function(e) {
        e.preventDefault();
        e.stopPropagation();

        _havePointerLock = (document.pointerLockElement === cubeContainer ||
                            document.mozPointerLockElement === cubeContainer ||
                            document.webkitPointerLockElement === cubeContainer);
    };

    var initTriad = function(triadLength, worldUp) {
      var offSet = triadLength / 2;
      var triadThickness = 10;
      var spriteSize = 50;
      var triadColors = {
        x: 0xff0000,
        y: 0x00ff00,
        z: 0x0000ff
      };
      var tempMatrix = new THREE.Matrix4(); // A matrix for temporary calculations

      var rotationMatrix = new THREE.Matrix4();
      if (worldUp.z === 1) {
        var rotationVector = new THREE.Vector3(0, 1, 0);
        // Rotate the triad so that z is up and the x and y axis lines point in the positive direction
        rotationMatrix.makeRotationAxis(rotationVector, Math.PI / 2);
        rotationVector.set(1, 1, 1).normalize();
        rotationMatrix.multiply(tempMatrix.makeRotationAxis(rotationVector, -Math.PI * 2 / 3));
      }

      var spriteGeometry = new THREE.PlaneBufferGeometry(spriteSize, spriteSize);
      var getTextSprite = function(text, color) {
        var textCanvas = document.createElement('canvas');
        textCanvas.width = textCanvas.height = 128;
        var ctx2d = textCanvas.getContext('2d');
        ctx2d.font = '128px Arial';
        ctx2d.fillStyle = "rgba(255,255,255,1)";
        ctx2d.textAlign = 'center';
        ctx2d.textBaseline = 'middle';
        ctx2d.fillText(text, textCanvas.width / 2, textCanvas.height / 2);

        var textTexture = new THREE.Texture(textCanvas);
        textTexture.needsUpdate = true;

        return new THREE.Mesh(
          spriteGeometry,
          new THREE.MeshBasicMaterial({
            map: textTexture,
            side: THREE.DoubleSide,
            transparent: true,
            color: color,
            depthWrite: false,
            depthTest: true
          })
        );
      };

      triadScene = new THREE.Scene();

      // Add the axes
      var triadGeom = new THREE.BoxGeometry(triadLength, triadThickness, triadThickness);
      var xAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(
        {color: triadColors.x, shading: THREE.SmoothShading}));
      var yAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(
        {color: triadColors.y, shading: THREE.SmoothShading}));
      var zAxis = new THREE.Mesh(triadGeom, new THREE.MeshBasicMaterial(
        {color: triadColors.z, shading: THREE.SmoothShading}));

      xAxis.applyMatrix(tempMatrix.makeTranslation(triadThickness / 2, -offSet, -offSet));
      yAxis.applyMatrix(tempMatrix.makeRotationZ(Math.PI / 2));
      yAxis.applyMatrix(tempMatrix.makeTranslation(-offSet, triadThickness / 2, -offSet));
      zAxis.applyMatrix(tempMatrix.makeRotationY(Math.PI / 2));
      zAxis.applyMatrix(tempMatrix.makeTranslation(-offSet, -offSet, triadThickness / 2));

      // Rotate the triad to match the up direction
      xAxis.applyMatrix(rotationMatrix);
      yAxis.applyMatrix(rotationMatrix);
      zAxis.applyMatrix(rotationMatrix);

      triadScene.add(xAxis);
      triadScene.add(yAxis);
      triadScene.add(zAxis);

      // Add text
      var xSprite = getTextSprite('X', triadColors.x);
      var ySprite = getTextSprite('Y', triadColors.y);
      var zSprite = getTextSprite('Z', triadColors.z);

      var spriteSecondaryAxisOffSet = -(spriteSize + offSet) / 2 - 20;
      var spriteMainAxisOffset = offSet + spriteSize;
      xSprite.position.set(spriteMainAxisOffset, spriteSecondaryAxisOffSet, spriteSecondaryAxisOffSet);
      ySprite.position.set(spriteSecondaryAxisOffSet, spriteMainAxisOffset, spriteSecondaryAxisOffSet);
      zSprite.position.set(spriteSecondaryAxisOffSet, spriteSecondaryAxisOffSet, spriteMainAxisOffset);

      // Rotate the text to match the up direction. Only rotate the positions, otherwise orienting them to face the
      // camera becomes more complicated
      xSprite.position.applyMatrix4(rotationMatrix);
      ySprite.position.applyMatrix4(rotationMatrix);
      zSprite.position.applyMatrix4(rotationMatrix);

      // Add them to the list of sprites to keep them oriented correctly
      sprites.push(xSprite);
      sprites.push(ySprite);
      sprites.push(zSprite);

      triadScene.add(xSprite);
      triadScene.add(ySprite);
      triadScene.add(zSprite);
    };

    /** Create ViewCube and set up renderer and camera
     * sets up all Three.js meshes for the View Cube
     * and initializes all event handlers such as mousemove
     * and mousedown and mouseup and pointerlock
     */
    var Init = function () {

        // parentTag = document.getElementById(tagId);

        // var element = $('#'+tagId); // ?? Is this different than the above?
        // element.width(300);
        // element.height(300);

        var bounds = cubeContainer.getBoundingClientRect();
        self.width  = bounds.width;
        self.height = bounds.height;

        position = getPosition(cubeContainer);

        //windowHalfX = self.width / 2;
        //windowHalfY = self.height / 2;

        //camera for home and arrow
        controlCamera = new THREE.PerspectiveCamera(70, self.height / self.width, 1, 10000);
        controlCamera.position.set(0, 0, 500);

        shadowScene = new THREE.Scene();
        cubeScene = new THREE.Scene();
        gridScene = new THREE.Scene();
        lineScene = new THREE.Scene();
        controlScene = new THREE.Scene();
        _orthogonalView = true;

        // This size means that the cube is (cubeSize)x(cubeSize)x(cubeSize) big
        cubeSize = 200;
        self.viewScale = cubeSize * 3.5;

        /******************************************Create the View Cube***********************************************/
        var filteringType = THREE.LinearFilter;

        // Load in the faceMap textures for 6 faces

        var getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;
        var resRoot = 'res/textures/';

        //The face names texture is localized:
        var locTexPath = localizeResourcePath || resRoot;

        var texture = new THREE.DDSLoader().load(getResourceUrl(locTexPath + 'VCcrossRGBA8small.dds'));
        texture.minFilter = texture.maxFilter = filteringType;

        var shader = THREE.ShaderLib[ "cube" ];

        var material = Autodesk.Viewing.Shaders.createShaderMaterial(shader);
        material.depthWrite = false;
        material.uniforms[ "tCube" ].value = texture;

        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 4, 4, 4);
        var cubeLine = new THREE.BoxGeometry(cubeSize+1 , cubeSize+1 , cubeSize+1, 4, 4, 4);

        // Create a cube object mesh with specified geometry and faceMap materials
        cube = new THREE.Mesh(cubeGeometry, material);
        cube.position.set(0.0, 0, 0);
        cubeScene.add(cube);

        // Set up a line segment for the cube border
        var borderTexture = loadTexture(getResourceUrl(resRoot + 'VCedge1.png'));

        borderTexture.minFilter = borderTexture.maxFilter = filteringType;

        line = new THREE.Mesh(cubeLine, new THREE.MeshBasicMaterial({ map: borderTexture, overdraw: false, transparent: true, shading: THREE.SmoothShading }));
        line.position.set(0.0, 0, 0);
        lineScene.add(line);

        // Set up the triad
        initTriad(cubeSize + 20, autocam.getWorldUpVector());

        /********************************************Set up the controls**********************************************/

        // Orthogonal Arrows

        var arrowDist = cubeSize;

        var arrowGeo = new THREE.Geometry();

        var v1 = new THREE.Vector3(-30, 0, 0);
        var v2 = new THREE.Vector3(30, 0, 0);
        var v3 = new THREE.Vector3(0, -30, 0);

        arrowGeo.vertices.push(v1);
        arrowGeo.vertices.push(v2);
        arrowGeo.vertices.push(v3);

        arrowGeo.faces.push(new THREE.Face3(1, 0, 2));
        arrowGeo.computeFaceNormals();

        var arrowMaterial1 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial2 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial3 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial4 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });

        var arrowSelection = new THREE.PlaneBufferGeometry(cubeSize * 0.5, cubeSize * 0.3, 2, 2);
        var arrowSelectionMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});

        var upArrow = new THREE.Mesh(arrowGeo, arrowMaterial1);
        var upArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        upArrow.position.set(0, arrowDist, 0.0);
        upArrowSelect.position.set(0, arrowDist * 0.9, 0.1);

        var downArrow = new THREE.Mesh(arrowGeo, arrowMaterial2);
        var downArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        downArrow.position.set(0, -arrowDist, 0.0);
        downArrowSelect.position.set(0, -arrowDist * 0.9, 0.1);
        downArrow.rotation.z += Math.PI;
        downArrowSelect.rotation.z += Math.PI;

        var rightArrow = new THREE.Mesh(arrowGeo, arrowMaterial3);
        var rightArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        rightArrow.position.set(arrowDist, 0, 0.0);
        rightArrowSelect.position.set(arrowDist * 0.9, 0, 0.1);
        rightArrow.rotation.z -= Math.PI / 2;
        rightArrowSelect.rotation.z -= Math.PI / 2;

        var leftArrow = new THREE.Mesh(arrowGeo, arrowMaterial4);
        var leftArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        leftArrow.position.set(-arrowDist, 0, 0.0);
        leftArrowSelect.position.set(-arrowDist * 0.9, 0, 0.1);
        leftArrow.rotation.z += Math.PI / 2;
        leftArrowSelect.rotation.z += Math.PI / 2;

        arrowGroup = new THREE.Object3D();
        arrowGroup.position.set(0, 0, 0);
        arrowGroup.add(upArrow);
        arrowGroup.add(downArrow);
        arrowGroup.add(rightArrow);
        arrowGroup.add(leftArrow);

        controlScene.add(upArrowSelect);
        controlScene.add(downArrowSelect);
        controlScene.add(rightArrowSelect);
        controlScene.add(leftArrowSelect);
        controlScene.add(arrowGroup);

        arrowBuffer.push(upArrowSelect);
        arrowBuffer.push(downArrowSelect);
        arrowBuffer.push(rightArrowSelect);
        arrowBuffer.push(leftArrowSelect);

        // Home icon
        var homeGeo = new THREE.PlaneBufferGeometry(cubeSize / 3, cubeSize / 3, 2, 2);
        var homeMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VChome.png')),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        home = new THREE.Mesh(homeGeo, homeMaterial);
        home.position.set(-cubeSize, cubeSize, 0);

        homeOffset = controlBuffer.length;
        controlScene.add(home);
        controlBuffer.push(home);

        // Arrows for rolling
        var rollArrows = new THREE.PlaneBufferGeometry(cubeSize * 1.5, cubeSize * 1.5, 2, 2);
        var rollMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCarrows.png')), shading: THREE.FlatShading, transparent: true});
        var roll = new THREE.Mesh(rollArrows, rollMaterial);
        roll.position.set(cubeSize * 0.5 + 20, cubeSize * 0.5 + 20, 0);

        var rollSelectionLeft = new THREE.PlaneBufferGeometry(cubeSize * 0.6, cubeSize * 0.45, 2, 2);
        var rollSelectionLeftMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollLeft = new THREE.Mesh(rollSelectionLeft, rollSelectionLeftMat);
        rollLeft.position.set(cubeSize * 0.5 + 20, cubeSize + 20, 0.1);

        var rollSelectionRight = new THREE.PlaneBufferGeometry(cubeSize * 0.45, cubeSize * 0.6, 2, 2);
        var rollSelectionRightMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollRight = new THREE.Mesh(rollSelectionRight, rollSelectionRightMat);
        rollRight.position.set(cubeSize + 20, cubeSize * 0.5 + 20, 0.1);

        controlScene.add(roll);
        controlScene.add(rollLeft);
        controlScene.add(rollRight);

        rollLeftOffset = controlBuffer.length;
        controlBuffer.push(rollLeft);
        rollRightOffset = controlBuffer.length;
        controlBuffer.push(rollRight);
        rollOffset = controlBuffer.length;
        controlBuffer.push(roll);

        //Menu Icon
        var contextGeo = new THREE.PlaneBufferGeometry(cubeSize / 2.3, cubeSize / 2.3, 2, 2);
        var contextMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(getResourceUrl(resRoot + 'VCcontext.png')),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        context = new THREE.Mesh(contextGeo, contextMaterial);
        context.position.set(cubeSize, -cubeSize, 0);

        menuOffset = controlBuffer.length;
        controlScene.add(context);
        controlBuffer.push(context);

        // Cube Shadow (Plane)

        var shadowGeo = new THREE.Geometry();

        shadowGeo.vertices.push(new THREE.Vector3(0, 0, 0));

        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));

        shadowGeo.faces.push(new THREE.Face3(4, 3, 2));
        shadowGeo.faces.push(new THREE.Face3(4, 2, 1));


        var shadowMat;

        // if(cam.renderer === 'WEBGL') {
        //     var vertexShader = "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}";
        //     var fragmentShader = "void main() {gl_FragColor = vec4(0, 0, 0, 0.5);}";
        //     shadowMat = new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader});
        // }else{
        //     shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});
        // }
        shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});

        shadow = new THREE.Mesh(shadowGeo, shadowMat);
        shadowScene.add(shadow);

        createCubeGrid();

        if (cam.renderer.toUpperCase() === 'CANVAS'){
            self.renderer = new THREE.CanvasRenderer();

        }else if (cam.renderer.toUpperCase() === 'WEBGL'){
            self.renderer = new avp.FireflyWebGLRenderer({ alpha: true, antialias: false });

        }else {
            avp.logger.warn("Incorrect use of Autocam.renderer property");
            self.renderer = new THREE.CanvasRenderer();
        }

        self.useTransparency(true);
        self.setSize(self.width,self.height);

        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;
        // need to copy to camera templates - half of these statements do nothing, since the camera points at pcam or ocam, but simpler than an if statement.
        self.pcam.topFov = self.ocam.topFov = self.camera.topFov;
        self.pcam.bottomFov = self.ocam.bottomFov = self.camera.bottomFov;
        self.pcam.leftFov = self.ocam.leftFov = self.camera.leftFov;
        self.pcam.rightFov = self.ocam.rightFov = self.camera.rightFov;

        // Auto clear needed because of multiple scenes
        self.renderer.autoClear = false;
        self.renderer.setSize(self.width, self.height);
        self.renderer.sortObjects = false;
        cubeContainer.appendChild(self.renderer.domElement);

        // Initialize all event handlers
        cubeContainer.addEventListener('touchstart', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousedown', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);

/*
        _havePointerLockFeature = 'pointerLockElement' in document ||
                                  'mozPointerLockElement' in document ||
                                  'webkitPointerLockElement' in document;
*/
        //Disabling this because it causes an intrusive browser pop-up asking
        //whether I want to allow full screen mode to happen (huh?)
        _havePointerLockFeature = false;

        if(_havePointerLockFeature) {
            document.exitPointerLock = document.exitPointerLock ||
                                       document.mozExitPointerLock ||
                                       document.webkitExitPointerLock;

            cubeContainer.requestPointerLock = cubeContainer.requestPointerLock ||
                                               cubeContainer.mozRequestPointerLock ||
                                               cubeContainer.webkitRequestPointerLock;

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerLockChange, false);
            document.addEventListener('mozpointerlockchange', pointerLockChange, false);
            document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        }

        // Changing textures (blue highlighting for home and roll arrows)
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChomeS.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS0.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrowsS1.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VChome.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCarrows.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontext.png')));
        changingTextures.push(loadTexture(getResourceUrl(resRoot + 'VCcontextS.png')));
    };

    /** Used to make cube visible again when using the transparency option   */
    var mouseOverCube = function() {
        if( cam.navApi.isActionEnabled('orbit') ) {
            cubeContainer.style.opacity = "1.0";
            _transparent = false;
        }
        requestAnimationFrame(self.render);
    };

    /** Used to fade in and out the cube when using the transparency option */
    var mouseMoveOverCube = function(event) {
        if (!_transparent && !cam.viewCubeMenuOpen && cam.navApi.isActionEnabled('orbit') ) {
            var x = Math.max(Math.abs((event.clientX - position.x) / position.w - 0.5) * 4.0 - 1.0, 0);
            var y = Math.max(Math.abs((event.clientY - position.y) / position.h - 0.5) * 4.0 - 1.0, 0);
            var d = Math.max(0, Math.min(Math.sqrt(x*x + y*y), 1.0));
            cubeContainer.style.opacity = 1.0 - d * (1.0 - self.inactiveOpacity);
        }
        else if( cam.navApi.isActionEnabled('orbit') ) {
            cubeContainer.style.opacity = 1.0;
        }
    };

    /** Used to make cube transparent when using the transparency option */
    var mouseOutCube = function() {
        if(cam.viewCubeMenuOpen){
            return;
        }
        cubeContainer.style.opacity = self.inactiveOpacity;
        _transparent = true;
        requestAnimationFrame(self.render);
    };


    /** Takes in a image url and outputs a THREE.texture to be used
     * by Three.js materials
     * @param {string} url - path to the image you want to load as a texture
     * @return {THREE.Texture}
     */
    var loadTexture = function(url) {
        var image = new Image();
        var useCredentials = av.endpoint.getUseCredentials() && (url.indexOf('://') === -1 || url.indexOf(window.location.host) !== -1);
        if (useCredentials) {
            image.crossOrigin = "use-credentials";
        } else {
            image.crossOrigin = "anonymous";
        }
        var texture = new THREE.Texture(image);
        image.onload = function() {
            texture.needsUpdate = true;
            loadedTextureCount++;
            if(loadedTextureCount >= 11){
                // all textures are now loaded
                requestAnimationFrame(self.render);
            }
        };

        image.src = url;
        return texture;
    };

    /** Creates the click-able grid around the View Cube
     *  by running functions to create Three.js meshes
     */
    var createCubeGrid = function () {
        var currentGridLength;
        var cubeCorners = [];
        var cubeEdges = [];

        cubeCorners[0] = buildCubeCorner(0, 0);
        cubeCorners[1] = buildCubeCorner(0, Math.PI / 2);
        cubeCorners[2] = buildCubeCorner(0, -Math.PI / 2);
        cubeCorners[3] = buildCubeCorner(0, Math.PI);
        cubeCorners[4] = buildCubeCorner(Math.PI / 2, 0);
        cubeCorners[5] = buildCubeCorner(Math.PI / 2, Math.PI / 2);
        cubeCorners[6] = buildCubeCorner(Math.PI / 2, -Math.PI / 2);
        cubeCorners[7] = buildCubeCorner(Math.PI / 2, Math.PI);

        cubeEdges[0] = buildCubeEdge(0, 0, 0);
        cubeEdges[1] = buildCubeEdge(0, Math.PI / 2, 0);
        cubeEdges[2] = buildCubeEdge(0, -Math.PI / 2, 0);
        cubeEdges[3] = buildCubeEdge(0, Math.PI, 0);
        cubeEdges[4] = buildCubeEdge(Math.PI / 2, 0, 0);
        cubeEdges[5] = buildCubeEdge(Math.PI / 2, Math.PI / 2, 0);
        cubeEdges[6] = buildCubeEdge(Math.PI / 2, -Math.PI / 2, 0);
        cubeEdges[7] = buildCubeEdge(Math.PI / 2, Math.PI, 0);
        cubeEdges[8] = buildCubeEdge(0, 0, Math.PI / 2);
        cubeEdges[9] = buildCubeEdge(0, 0, -Math.PI / 2);
        cubeEdges[10] = buildCubeEdge(-Math.PI / 2, 0, -Math.PI / 2);
        cubeEdges[11] = buildCubeEdge(-Math.PI, 0, -Math.PI / 2);

        // Draw the front square on the grid
        gridMeshes.push(buildCubeFace(0, 0));
        gridMeshes[0].name = 'front';
        intersectsFace.push(gridMeshes[0]);
        cubeBuffer.push(gridMeshes[0]);
        gridScene.add(gridMeshes[0]);

        // Draw the right square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI / 2));
        gridMeshes[1].name = 'right';
        intersectsFace.push(gridMeshes[1]);
        cubeBuffer.push(gridMeshes[1]);
        gridScene.add(gridMeshes[1]);

        // Draw the back square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI));
        gridMeshes[2].name = 'back';
        intersectsFace.push(gridMeshes[2]);
        cubeBuffer.push(gridMeshes[2]);
        gridScene.add(gridMeshes[2]);

        // Draw the left grid
        gridMeshes.push(buildCubeFace(0, -Math.PI / 2));
        gridMeshes[3].name = 'left';
        intersectsFace.push(gridMeshes[3]);
        cubeBuffer.push(gridMeshes[3]);
        gridScene.add(gridMeshes[3]);

        // Draw the bottom grid
        gridMeshes.push(buildCubeFace(Math.PI / 2, 0));
        gridMeshes[4].name = 'bottom';
        intersectsFace.push(gridMeshes[4]);
        cubeBuffer.push(gridMeshes[4]);
        gridScene.add(gridMeshes[4]);

        // Draw the top grid
        gridMeshes.push(buildCubeFace(-Math.PI / 2, 0));
        gridMeshes[5].name = 'top';
        intersectsFace.push(gridMeshes[5]);
        cubeBuffer.push(gridMeshes[5]);
        gridScene.add(gridMeshes[5]);

        currentGridLength = gridMeshes.length;

        var i;
        for (i = 0; i < cubeCorners.length; i++) {
            gridMeshes.push(cubeCorners[i]);
            gridMeshes[currentGridLength + i].name = cornerNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }

        currentGridLength = gridMeshes.length;

        for (i = 0; i < cubeEdges.length; i++) {
            gridMeshes.push(cubeEdges[i]);
            gridMeshes[currentGridLength + i].name = edgeNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }
    };


    /**
     * Get intersections between a mesh and mouse position (mouse picking)
     * @param {THREE.Vector3} pickingVector - direction vector to find intersections
     * @param {THREE.Camera} camera
     * @param {THREE.Mesh[]} intersectionBuffer - an array of three.js meshes to check for intersections with these specific meshes
     * @return {Object[]} - objects which were intersected
     */
    var findPickingIntersects = function(pickingVector, camera, intersectionBuffer) {
        var raycaster;

        var direction = new THREE.Vector3();
        if (camera.type === "PerspectiveCamera") {
            direction.copy(pickingVector);
            // retrieve point on view plane to shoot ray through
            direction.unproject(camera);
            // direction is target point minus position
            raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
        } else {
            // orthographic
            var target = new THREE.Vector3();
            target.copy(pickingVector);
            // retrieve point on view plane to shoot ray through
            target.unproject(camera);

            // direction is constant, from position to origin.
            // direction is negative of position
            direction.copy(camera.position).negate().normalize();
            raycaster = new THREE.Raycaster(target, direction);
        }

        return raycaster.intersectObjects(intersectionBuffer);

    };

    var getPickVector = function(event, position) {
        var x = event.clientX - position.x;
        var y = event.clientY - position.y;

        x = (x / position.w * 2.0) - 1.0;
        y = ((position.h - y) / position.h * 2.0) - 1.0;

        return new THREE.Vector3(x, y, 0.5);
    };

    /* never used
    function isFullscreen() {
        return document.fullscreenElement ||
               document.webkitFullscreenElement ||
               document.mozFullScreenElement ||
               document.msFullscreenElement;
    }
    */

    function getEventCoords(event, self) {
        var coords = {};

        if( event.type.indexOf("touch") === 0 ) {
            if( event.touches.length > 0 ) {
                coords.clientX   = event.touches[0].clientX;
                coords.clientY   = event.touches[0].clientY;
                coords.pageX     = event.touches[0].pageX;
                coords.pageY     = event.touches[0].pageY;
                coords.screenX   = event.touches[0].screenX;
                coords.screenY   = event.touches[0].screenY;
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
                coords.which     = cam.navApi.getUseLeftHandedInput() ? 3 : 1;
            }
            else {
                coords = self.prevCoords;
            }
        }
        else {
            coords.clientX   = event.clientX;
            coords.clientY   = event.clientY;
            coords.pageX     = event.pageX;
            coords.pageY     = event.pageY;
            coords.screenX   = event.screenX;
            coords.screenY   = event.screenY;
            coords.which     = event.which;

            if ( _havePointerLockFeature ) {
                coords.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                coords.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            }
            else {
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
            }
        }
        self.prevX = coords.screenX;
        self.prevY = coords.screenY;
        self.prevCoords = coords;

        return coords;
    }

    /** All functionality regarding cube clicks starts here
     *
     * @param {Object} event - event when mouse down occurs
     */
    var onDocumentMouseDown = function (event) {
        event.preventDefault();
        event.stopPropagation();

        if( !cam.navApi.isActionEnabled('orbit') )
            return;

        if (cam.currentlyAnimating) { return; }

        var coords = getEventCoords(event, self);

        // Make sure our position is up to date...
        position = getPosition(cubeContainer);

        cubeContainer.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        document.addEventListener('touchend', onDocumentMouseUp, false);
        // Not needed: document.addEventListener('mousemove', onDocumentMouseMove, false);

        if( !cam.navApi.getUsePivotAlways() ) {
            // If the usePivot option is not on, we pivot around the center of the view:
            cam.pivot.copy(cam.center);
            cam.navApi.setPivotPoint(cam.center);
            // This also clears the pivot set flag:
            cam.navApi.setPivotSetFlag(false);
        }

        cam.startInteraction(coords.pageX, coords.pageY);

        // Since this mouse down is for dragging the cube we should not be able do this if the cube is animating already
        var intersectsWithCube;
        var pickingVector;

        //If cube is first thing clicked, add the current shot to rewind history
        if (cam.rewindParams.history.length == 0) cam.addHistoryElement();

        //If clicking cube from anywhere other then end of timeline update history accordingly
        if (!cam.rewindParams.snapped || cam.rewindParams.timelineIndex +1 != cam.rewindParams.history.length) cam.addIntermediateHistoryElement();

        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) // Right mouse click, handled on mouse up
            return;

        if(self.animSpeed <= 0){
            avp.logger.error("animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation", av.errorCodeString(av.ErrorCodes.VIEWER_INTERNAL_ERROR));
            return;
        }

        // get mouse picking intersections
        pickingVector = getPickVector(coords, position);
        intersectsWithCube = findPickingIntersects(pickingVector, self.camera, cubeBuffer);


        if (intersectsWithCube.length > 0) {

            hideArrows();
            if(self.draggable){
                document.addEventListener('mousemove', onDocumentMouseMoveCube, false);
                document.addEventListener('touchmove', onDocumentMouseMoveCube, false);

                // Check if browser has pointer lock support
                if ( _havePointerLockFeature ) {
                    // Ask the browser to lock the pointer
                    cubeContainer.requestPointerLock();
					_pointerLockMoveBugSPK865 = (_isChrome && _isWindows);
                }
            }
        }
    };

    /** Used for dragging the cube,
     * @param {Object} event - event when mouse move occurs (contains information about pointer position)
     */
    var onDocumentMouseMoveCube = function (event) {

        event.preventDefault();
        event.stopPropagation();

        // This is an error if user puts in self.animSpeed = 0 or less
        if(self.animSpeed <= 0){
            document.removeEventListener("mousemove", onDocumentMouseMoveCube, false);
            document.removeEventListener("touchmove", onDocumentMouseMoveCube, false);
            avp.logger.error("animSpeed cannot be 0 or less", av.errorCodeString(av.ErrorCodes.VIEWER_INTERNAL_ERROR));
            return;
        }

        if(cam.currentlyAnimating) {
			return;
		}
        var coords = getEventCoords(event, self);

        if ( _havePointerLockFeature ) {
			// We skip the first movement event after requesting pointer lock
			// because Chrome on Windows sends out a bogus motion value.
			if( _pointerLockMoveBugSPK865 ) {
				_pointerLockMoveBugSPK865 = false;
				coords.movementX = coords.movementY = 0;
			}
        }

        if(_havePointerLock) {

            // Ignore erroneous data sent from pointer lock
            // not sure why erroneous data gets received
            // could be bug in pointer lock
            if(coords.movementX > 300 || coords.movementY > 300) {
                coords.movementX = 0;
                coords.movementY = 0;
            }
        }

        // If the mouse hasn't moved ignore this current movement (not sure why the mouse move event gets called)
        // Also used for ignoring erroneous data
        if(coords.movementX === coords.movementY && coords.movementX === 0) {
            cam.currentlyAnimating = false;
            return;
        }
        _orthogonalView = false;
        _dragged = true;
        cam.showPivot(true);
        cam.currentCursor = new THREE.Vector2(coords.pageX, coords.pageY);
        cam.orbit(cam.currentCursor, cam.startCursor, new THREE.Vector3( - coords.movementX, coords.movementY, 0 ), cam.startState);

        self.camera.lookAt(self.center);

        requestAnimationFrame(self.render);
    };


    var endMouseUp = function (stillNeedUp) {
        if( !stillNeedUp ) {
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
            document.removeEventListener('touchend', onDocumentMouseUp, false);
        }

        document.removeEventListener('mousemove', onDocumentMouseMoveCube, false);
        document.removeEventListener('touchmove', onDocumentMouseMoveCube, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);

        if ( _havePointerLock ) {
            document.exitPointerLock();
        }

    };

    /** Rotates the cube when a division of the cube grid is clicked,
     * also provides functionality for home button interaction, orthogonal arrows interaction,
     * and roll arrows interaction
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    var onDocumentMouseUp = function (event) {
        event.preventDefault();
        event.stopPropagation();

        var cubeIntersects;
        var arrowIntersects;
        var controlIntersects;

        if (cam.currentlyAnimating || _dragged) {
            cam.endInteraction();
            cam.showPivot(false);
            _dragged = false;

            endMouseUp(false);
            return;
        }
        var coords = getEventCoords(event, self);

        if (cam.viewCubeMenuOpen) {
            var x = coords.clientX - position.x;
            var y = coords.clientY - position.y;

            //if clicked on the menu
            if ((cam.menuOrigin.x <= x) && (x <= (cam.menuOrigin.x + cam.menuSize.x)) &&
                (cam.menuOrigin.y <= y) && (y <= (cam.menuOrigin.y + cam.menuSize.y))){

                // HACK!!
                // TODO: make this a bit more robust. It doesn't take the menu separators
                // into account and makes a gross assumption about the menu entry size.
                var menuItemNumber = Math.floor(((y-5) - cam.menuOrigin.y)/25);

                var log = function(action) {
                    avp.logger.track({ name: 'navigation/' + action, aggregate: 'count' });
                };

                switch(menuItemNumber){
                    case 0:                 //home
                        log('home');
                        cam.goHome();
                        break;
                    case 1:                 //orthographic
                        log('setortho');
                        cam.setOrthographicFaces(false);
                        cam.toOrthographic();
                        // change cube appearance
                        self.camera = self.ocam;
                        break;
                    case 2:                 //perspective
                        log('setpersp');
                        cam.setOrthographicFaces(false);
                        cam.toPerspective();
                        // change cube appearance
                        self.camera = self.pcam;
                        break;
                    case 3:                 //perspective with ortho faces
                        cam.setOrthographicFaces(true);
                        if( _orthogonalView ) {
                            cam.toOrthographic();
                            // change cube appearance
                            self.camera = self.ocam;
                        } else {
                            cam.toPerspective();
                            // change cube appearance
                            self.camera = self.pcam;
                        }
                        break;
                    case 4:                 //set current view as home
                        log('sethome');
                        cam.setCurrentViewAsHome(false);
                        break;
                    case 5:                 //focus and set current view as home
                        log('focushome');
                        cam.setCurrentViewAsHome(true);
                        break;
                    case 6:                 //reset home
                        log('resethome');
                        cam.resetHome();
                        break;
                    case 7:                 //set current view as front
                        log('setfront');
                        cam.setCurrentViewAsFront();
                        break;
                    case 8:                 //set current view as top
                        log('settop');
                        cam.setCurrentViewAsTop();
                        break;
                    case 9:                 //reset orientation
                        cam.resetOrientation();
                        break;
                }
            }

            cam.viewCubeMenuOpen = false;
            cam.removeDropdownMenu(cubeContainer);

            //if clicked off the cube canvas
            if( coords.clientX < position.x || coords.clientX > (position.w + position.x)
             || coords.clientY < position.y || coords.clientY > (position.h + position.y)) {
                mouseOutCube();
            }

            // In case something needs a highlight change:
            if( self.mouseMoveSave )
                self.processMouseMove(self.mouseMoveSave);

            // LMV-1876 and LMV-1986 - re-enable hotkeys, essentially
            cam.endInteraction();

            // remove event listeners
            endMouseUp(false);
            return;
        }
        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) {
            cam.viewCubeMenuOpen=true;
            cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
            endMouseUp(true);
            return;
        }
        var pickingVector = getPickVector(coords, position);
        cubeIntersects    = findPickingIntersects(pickingVector, self.camera, cubeBuffer);
        arrowIntersects   = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        // Apply logic for clicking on arrows
        if (arrowIntersects.length > 0 && _orthogonalView) {
            var orientation = cam.getOrientation();

            switch (self.currentFace){
                case "front":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "right":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                        }
                    break;

                case "left":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "back":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "top":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                    }
                    break;

                case "bottom":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                    }
                    break;
            }
            cam.elapsedTime =0;
            cam.sphericallyInterpolateTransition();
        }

        if (controlIntersects.length > 0) {
            cam.elapsedTime = 0;

            if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]) {
                cam.goHome();
                endMouseUp(false);
                return;
            }
            if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]) {
                cam.viewCubeMenuOpen=true;
                cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
                endMouseUp(true);
                return;
            }
            if (self.wantRollArrows && _orthogonalView && (controlIntersects[0].object === controlBuffer[rollLeftOffset] || controlIntersects[0].object === controlBuffer[rollRightOffset])) {
                //TODO: when panning, dir changes -> position
                var clockwise = (controlIntersects[0].object === controlBuffer[rollRightOffset]);
                var destination = {
                    center: cam.center.clone(),
                    position: camera.position.clone(),
                    pivot: camera.pivot.clone(),
                    fov: camera.fov,
                    worldUp: cam.sceneUpDirection.clone(),
                    isOrtho: (camera.isPerspective === false)
                };
                var dir = cam.center.clone().sub(camera.position).normalize();

                if (clockwise){
                    destination.up = camera.up.clone().cross(dir);
                }else{
                    destination.up = camera.up.clone().multiplyScalar(-1);
                    destination.up.cross(dir);
                }
                destination.up.normalize();

                cam.elapsedTime = 0.0;
                cam.animateTransition(destination);
            }
        }
        if (cubeIntersects.length > 0) {
            var face = cubeIntersects[0].object.name;
            self.mouseMoveSave = event;
            self.cubeRotateTo(face);
        }
        endMouseUp(false);
    };

    this.cubeRotateTo = function(face) {
        self.currentFace = face;

        // If ortho faces is on and the target is not another face,
        // switch to perspective mode:
        if( cam.orthographicFaces && (self.currentFace.indexOf(',') !== -1) ) {
            cam.setCameraOrtho(false);
        }
        cam.calculateCubeTransform(self.currentFace);

        cam.elapsedTime =0;

        // After interpolating to the new target we may have to simulate
        // a mouse move event at the final location so that the appropriate
        // part of the cube is highlighted:
        cam.sphericallyInterpolateTransition(function(){
            if( self.mouseMoveSave )
                self.processMouseMove(self.mouseMoveSave);
        });
    };

    /** Used to highlight cube grid divisions/arrows/home
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    this.processMouseMove = function (event) {
        var intersectsFaces;
        var arrowIntersects;
        var controlIntersects;

        if (cam.viewCubeMenuOpen || cam.currentlyAnimating) {
            self.mouseMoveSave = event;
            return;
        }
        self.mouseMoveSave = null;

        var coords = getEventCoords(event, self);

        var pickingVector = getPickVector(coords, position);

        intersectsFaces = findPickingIntersects(pickingVector, self.camera, intersectsFace);
        arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        /**********Highlight arrows when hovered over************/

        if (INTERSECTED && !_dragged) {
            INTERSECTED.material.color.setHex(0xDDDDDD);
            INTERSECTED = null;
            requestAnimationFrame(self.render);
        }

        if (arrowIntersects.length > 0 && !_dragged) {
                INTERSECTED = arrowIntersects[0].object;
                for( var i=arrowGroup.children.length;  --i >= 0; ) {
                    if (INTERSECTED === arrowBuffer[i]) {
                        INTERSECTED = arrowGroup.children[i];
                        INTERSECTED.material.color.setHex(0x00afff);
                        break;
                    }
                }
                requestAnimationFrame(self.render);
        }

        /**************Highlight faces on cube******************/

        if (INTERSECTED_F && !_dragged) {
            // Make the previously selected face opacity: 0.0
                INTERSECTED_F.material.opacity = 0.0;
                INTERSECTED_F = null;
                requestAnimationFrame(self.render);
        }

        if (intersectsFaces.length > 0 && !_dragged) {
            // Make the currently selected face opacity: 0.3
                INTERSECTED_F = intersectsFaces[0].object;
                INTERSECTED_F.material.opacity = 0.3;
                requestAnimationFrame(self.render);
        }

        if (controlIntersects.length > 0 && !_dragged){
            if(INTERSECTED_C !== controlIntersects[0].object){
                // home mouse over
                if(self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[homeOffset].material.map = changingTextures[0];
                }

                // Left roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollLeftOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[1];
                }

                // Right roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollRightOffset]) {
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[2];
                }

                // Menu Icon
                else if(self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[menuOffset].material.map = changingTextures[6];
                }

                else{
                    // home mouse over
                    if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                        INTERSECTED_C = null;
                        controlBuffer[homeOffset].material.map = changingTextures[3];
                    }

                    // Left roll and Right roll arrow
                    else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                        INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                        INTERSECTED_C = null;
                        controlBuffer[rollOffset].material.map = changingTextures[4];
                    }

                    // menu icon
                    else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                        INTERSECTED_C = null;
                        controlBuffer[menuOffset].material.map = changingTextures[5];
                    }
                }
                requestAnimationFrame(self.render);
            }
        }else if(INTERSECTED_C !== null && !_dragged){
            // home mouse over
            if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                INTERSECTED_C = null;
                controlBuffer[homeOffset].material.map = changingTextures[3];
            }

            // Left roll and Right roll arrow
            else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                INTERSECTED_C = null;
                controlBuffer[rollOffset].material.map = changingTextures[4];
            }

            // menu icon
            else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                INTERSECTED_C = null;
                controlBuffer[menuOffset].material.map = changingTextures[5];
            }

            requestAnimationFrame(self.render);
        }
    };

    var onDocumentMouseMove = function (event) {
        if( cam.navApi.isActionEnabled('orbit') )
            self.processMouseMove(event);
    };

    /** Refreshes values so that renderer is correct size (in pixels) **/
    var onWindowResize = function () {
        position = getPosition(cubeContainer);

        // cubeContainer.style.width = self.width.toString() + "px";
        // cubeContainer.style.height = "inherit";

        self.width  = cubeContainer.offsetWidth;
        self.height = cubeContainer.offsetHeight;

        //windowHalfX = self.width / 2;
        //windowHalfY = self.height / 2;

        //self.camera.aspect = self.width / self.height; - one of the two cameras has this aspect, so setting it there sets it here.
        self.pcam.aspect = self.ocam.aspect = self.width / self.height;
        //self.camera.updateProjectionMatrix(); - done by the two calls below:
        self.pcam.updateProjectionMatrix();
        self.ocam.updateProjectionMatrix();

        // PHB added. See Autocam.js windowResize
        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;
        // need to copy to camera templates - half of these statements do nothing, since the camera points at pcam or ocam, but simpler than an if statement.
        self.pcam.aspect = self.ocam.aspect = self.camera.aspect;
        self.pcam.topFov = self.ocam.topFov = self.camera.topFov;
        self.pcam.bottomFov = self.ocam.bottomFov = self.camera.bottomFov;
        self.pcam.leftFov = self.ocam.leftFov = self.camera.leftFov;
        self.pcam.rightFov = self.ocam.rightFov = self.camera.rightFov;

        self.renderer.setSize(self.width, self.height);
        requestAnimationFrame(self.render);
    };

    /** Builds one square mesh of the grid (located on each face of the cube)
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - mesh of the cube face (square part) rotated by params
     */
    var buildCubeFace = function (rotationX, rotationY) {

        // These sizes may be changed if cube size is changed
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;

        var geo = new THREE.Geometry();

        // Center of the cube
        var v0 = new THREE.Vector3(0, 0, 0);

        /******************FRONT OF CUBE********************/
        var v1 = new THREE.Vector3(square, -square, masterCubeSize);
        var v2 = new THREE.Vector3(square, square, masterCubeSize);
        var v3 = new THREE.Vector3(-square, square, masterCubeSize);
        var v4 = new THREE.Vector3(-square, -square, masterCubeSize);

        geo.vertices.push(v0);

        geo.vertices.push(v1);
        geo.vertices.push(v2);
        geo.vertices.push(v3);
        geo.vertices.push(v4);

        /******************FRONT FACE********************/

            // Front square
        geo.faces.push(new THREE.Face3(1, 2, 3));
        geo.faces.push(new THREE.Face3(1, 3, 4));


        // Apply matrix rotations for sides which are not the front
        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        return new THREE.Mesh(geo, material);
    };

    /** Builds one edge mesh of the grid
     *
     * @param rotationX - rotate shape by this amount X
     * @param rotationY - rotate shape by this amount Y
     * @param rotationZ - rotate shape by this amount Z
     * @return {THREE.Mesh} - mesh of the cube edge rotated by params
     */
    var buildCubeEdge = function (rotationX, rotationY, rotationZ) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var e0 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var e1 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e2 = new THREE.Vector3(-square, square, masterCubeSize);
        var e3 = new THREE.Vector3(square, square, masterCubeSize);

        var e4 = new THREE.Vector3(square, masterCubeSize, square);
        var e5 = new THREE.Vector3(-square, masterCubeSize, square);
        var e6 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e7 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(e0);
        geo.vertices.push(e1);
        geo.vertices.push(e2);
        geo.vertices.push(e3);

        geo.vertices.push(e4);
        geo.vertices.push(e5);
        geo.vertices.push(e6);
        geo.vertices.push(e7);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));
        geo.applyMatrix(new THREE.Matrix4().makeRotationZ(rotationZ));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    /** Builds one corner mesh of the grid
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - the cube corner mesh rotated by params
     */
    var buildCubeCorner = function (rotationX, rotationY) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var c0 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c1 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var c2 = new THREE.Vector3(square, square, masterCubeSize);
        var c3 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);

        var c4 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c5 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c6 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);
        var c7 = new THREE.Vector3(masterCubeSize, square, square);

        var c8 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c9 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c10 = new THREE.Vector3(square, masterCubeSize, square);
        var c11 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(c0);
        geo.vertices.push(c1);
        geo.vertices.push(c2);
        geo.vertices.push(c3);

        geo.vertices.push(c4);
        geo.vertices.push(c5);
        geo.vertices.push(c6);
        geo.vertices.push(c7);

        geo.vertices.push(c8);
        geo.vertices.push(c9);
        geo.vertices.push(c10);
        geo.vertices.push(c11);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));

        geo.faces.push(new THREE.Face3(8, 9, 10));
        geo.faces.push(new THREE.Face3(8, 10, 11));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    var changeBasisWorldToStandard = function (V) {
        var worldD = cam.cubeFront.clone();
        var worldU = cam.sceneUpDirection.clone();
        var worldR = worldD.clone().cross(worldU);
        worldU.copy(worldR).cross(worldD);

        worldD.normalize();
        worldU.normalize();
        worldR.normalize();

        var answer = new THREE.Vector3(worldD.x,worldU.x,worldR.x).multiplyScalar(V.x);
        answer.add(new THREE.Vector3(worldD.y,worldU.y,worldR.y).multiplyScalar(V.y));
        answer.add(new THREE.Vector3(worldD.z,worldU.z,worldR.z).multiplyScalar(V.z));

        return answer;
    };

    /** Render the View Cube scenes and perform checks for control visibility **/
    this.render = function () {
        // switch view cube to match whatever camera.isPerspective says to use.
        self.camera = camera.isPerspective ? self.pcam : self.ocam;

        var scale = self.compass ? self.viewScaleFactorCompass * self.viewScale : self.viewScale;
        var viewDir = cam.center.clone().sub(camera.position).normalize();
        var upDir   = camera.up.normalize();
        var spriteRotationMatrix = new THREE.Matrix4();

        viewDir = changeBasisWorldToStandard(viewDir);
        upDir   = changeBasisWorldToStandard(upDir);

        self.camera.position.copy(viewDir);
		    self.camera.position.multiplyScalar(-scale / self.camera.position.length());
        self.camera.up = upDir.normalize();
        self.camera.lookAt(self.center);

        checkControlVisibility();

        var renderer = self.renderer;
        if (renderer) {
            // Orient any sprites to face the camera
            for (var i = 0; i < sprites.length; i++) {
              spriteRotationMatrix.lookAt(self.camera.position, sprites[i].position, self.camera.up);
              sprites[i].setRotationFromMatrix(spriteRotationMatrix);
            }

            renderer.clear();
            // There are 3 scenes: the first is the shadow, then the cube with textures, then the grid is on top
            renderer.render(shadowScene, self.camera);
            renderer.render(cubeScene, self.camera);
            renderer.render(lineScene, self.camera);
            if (self.renderTriad) {
              renderer.render(triadScene, self.camera);
            }
            renderer.render(gridScene, self.camera);

            // Different camera since these shouldn't move with the View Cube
            renderer.render(controlScene, controlCamera);
        }
    };

    /**
     * checks whether arrows (orthogonal and roll), drop down menus, and home button should be visible or not at
     * this current time
     */
    var checkControlVisibility = function(){
        // Arrow Visibility

        _orthogonalView = cam.isFaceView();

        (_orthogonalView && !_transparent && !cam.currentlyAnimating) ? showArrows() : hideArrows();

        // Menu Visibility
        _transparent ? hideContext() : showContext();

        // Home Visibility
        _transparent ? hideHome() : showHome();
    };

    /** Hide View Cube Arrows **/
    var hideArrows = function() {
        controlScene.remove(arrowGroup);

        controlBuffer[rollOffset].material.opacity = 0.0;
        controlBuffer[menuOffset].material.opacity = 0.0;
    };

    /** Show View Cube Arrows **/
    var showArrows = function() {
        controlScene.add(arrowGroup);

        var opacity = self.wantRollArrows ? 1.0 : 0.0;
        controlBuffer[rollOffset].material.opacity = opacity;
        controlBuffer[menuOffset].material.opacity = opacity;
    };

    /** Hide the view cube menu button **/
    var hideContext = function() {
        context.material.opacity = (av.isMobileDevice()) ? 1.0 : 0.0;
    };

    /** Show the view cube menu button **/
    var showContext = function() {
        context.material.opacity = self.wantContextMenu ? 1.0 : 0.0;
    };

    /** Hide the home button **/
    var hideHome = function() {
        home.material.opacity = 0.0;
    };

    /** Show the home button **/
    var showHome = function() {
        home.material.opacity = self.wantHomeButton ? 1.0 : 0.0;
    };

    /* Public Methods */
    /** Update the View Cube camera to a new camera view
     * @public
     * @this ViewCube
     * @param {int[]} eye - client provided camera position (in their world coordinates)
     * @param {int[]} centre - client provided pivot point or centre (where the camera is looking at in their world coordinates)
     * @param {int[]} upVector - client provided up vector
     */

    /** Refresh height and width renderer sizes
     * @public
     * @this ViewCube
     */
    this.refreshCube = function () {
        onWindowResize();
    };

    /** Set the size of the View Cube
     * @public
     * @this ViewCube
     * @param {int} width - in pixels
     * @param {int} height - in pixels
     */
    this.setSize = function (width, height) {
        self.width = width;
        self.height = height;

        if(cubeContainer.children.length > 1){
            for(var i = 1; i < cubeContainer.children.length; i++)
                cubeContainer.children[i].style.bottom = (self.height/5).toString() + "px";
        }

        onWindowResize();
    };

    /** Option to turn on and off transparency on mouse out for the view cube
     * @public
     * @this ViewCube
     * @param {boolean} transparent - true to use transparency, false to turn it off
     */
    this.useTransparency = function (transparent){
        _transparent = transparent;
        if(transparent) {
            cubeContainer.onmouseover = mouseOverCube;
            cubeContainer.onmousemove = mouseMoveOverCube;
            cubeContainer.onmouseout = mouseOutCube;
            mouseOutCube();
        }
        else {
            cubeContainer.onmouseover = null;
            cubeContainer.onmouseout = null;
            cubeContainer.onmousemove = null;
            cubeContainer.style.opacity = "1.0";
        }
    };

    this.showTriad = function (show) {
      if (show !== self.renderTriad) {
        self.renderTriad = show;
        requestAnimationFrame(self.render);
      }
    };

    this.dtor = function() {
        this.renderer = null;
    };


    /* Build the cube */
    Init();
};


(function() {

'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

var SelectionType = {
    MIXED: 0,
    REGULAR: 1,
    OVERLAYED: 2
};

function Selector(viewer, model) {

    //Selection support
    var _this = this;
    this.selectedObjectIds = {};
    this.selectionCount = 0;
    this.selectionMode = av.SelectionMode.LEAF_OBJECT;

    var selectedParentMap = {};

    function getInstanceTree() {
        return model.getData().instanceTree;
    }
    
    function getFragmentMap() {
        return model.getData().instanceTree || model.getData().fragmentMap;
    }

    function fireSelectionChangedEvent() {
        //Nothing here, events are done by the MultiModelSelector now.
    }

    function unmarkObject(dbId) {

        var it = getInstanceTree();

        if (selectedParentMap[dbId] > 0) {
            selectedParentMap[dbId]--;
            if (selectedParentMap[dbId] == 0) {
                viewer.highlightObjectNode(model, dbId, false);
            }

        } else if (selectedParentMap[dbId] < 0) {
            throw ("Selection State machine broken. Negatively selected object!");
        }

        if (it) {
            it.enumNodeChildren(dbId, function(childId) {
                unmarkObject(childId);
            }, false);
        }
    }
    

    function markObject(dbId, isChild, selectionType) {

        var it = getInstanceTree();

        if (selectedParentMap[dbId]) {
            selectedParentMap[dbId]++;
        } else {
            switch(selectionType) {
                default:
                case SelectionType.MIXED:
                    viewer.highlightObjectNode(model, dbId, true, isChild);
                    break;
                case SelectionType.REGULAR:
                    viewer.highlightObjectNode(model, dbId, true, true);
                    break;
                case SelectionType.OVERLAYED:
                    viewer.highlightObjectNode(model, dbId, true, false);
                    break;
            }
            selectedParentMap[dbId] = 1;
        }

        if (it) {
            it.enumNodeChildren(dbId, function(childId) {
                markObject(childId, true, selectionType);
            }, false);
        }
    }

    function isSelected(dbId) {

        if ((dbId !== undefined) && _this.selectedObjectIds[dbId])
            return true;
    }


    function select(dbId, selectionType) {

        var it = getInstanceTree();
        selectionType = selectionType || av.SelectionType.MIXED; 
                                            
        if (it) {
            dbId = it.findNodeForSelection(dbId, _this.selectionMode);

            if (!it.isNodeSelectable(dbId))
                return;
        }

        var found = isSelected(dbId);
        if (!found) {
            _this.selectedObjectIds[dbId] = dbId;
            _this.selectionCount++;
            markObject(dbId, false, selectionType);
        }
    }

    function deselect(dbId) {

        var found = isSelected(dbId);
        if (found) {
            unmarkObject(dbId);
            _this.selectedObjectIds[dbId] = 0;
            _this.selectionCount--;
        }
    }

    function selectionIsEqual(dbNodeArray) {
        if( _this.selectionCount !== dbNodeArray.length )
            return false;

        for (var i = 0; i < dbNodeArray.length; i++) {
            if (!isSelected(dbNodeArray[i]))
                return false;
        }
        return true;
    }


    this.getInstanceTree = getInstanceTree;
    this.getFragmentMap = getFragmentMap;

    this.getSelectionLength = function() {
        return _this.selectionCount;
    };


    this.getSelection = function() {
        var ret = [];
        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            if (sset[p]) {
                var dbId = parseInt(p);
                ret.push(dbId);
            }
        }

        return ret;
    };

    this.clearSelection = function(nofire) {
        if (this.selectionCount > 0) {
            var sset = _this.selectedObjectIds;
            for (var p in sset) {
                var dbId = parseInt(p);
                if (dbId !== undefined)
                    unmarkObject(dbId);
            }
            _this.selectedObjectIds = {};
            _this.selectionCount = 0;

            if( !nofire )
                fireSelectionChangedEvent();
        }
    };

    this.deselectInvisible = function() {
        var changed = false;

        var sset = _this.selectedObjectIds;
        var visMan = viewer.visibilityManager;
        for (var p in sset) {
            var dbId = parseInt(p);
            if (dbId && !visMan.isNodeVisible(model, dbId)) {
                deselect(dbId);
                changed = true;
            }
        }

        if (changed) {
            fireSelectionChangedEvent();
        }

        return changed;
    };


    // TODO: Optimize this so both select and toggleSelection don't have to lookup the node index.
    this.toggleSelection = function(dbId, selectionType) {

        if (!dbId) {
            avp.logger.error("Attempting to select node 0.", av.errorCodeString(av.ErrorCodes.VIEWER_INTERNAL_ERROR));
            return;
        }

        if (!isSelected(dbId)) {
            select(dbId, selectionType);
        } else {
            deselect(dbId);
        }
        fireSelectionChangedEvent();
    };


    this.setSelectionMode = function(mode) {
        this.clearSelection(true);
        this.selectionMode = mode;
    };

    this.setSelection = function(dbNodeArray, selectionType) {

        if( selectionIsEqual( dbNodeArray ) )
            return;

        this.clearSelection(true);

        if (dbNodeArray == null || dbNodeArray.length === 0)
            return;

        for (var i = 0; i < dbNodeArray.length; i++) {
            select(dbNodeArray[i], selectionType);
        }

        fireSelectionChangedEvent();
    };


    this.getSelectionBounds = function() {
        var bounds = new THREE.Box3();
        var box = new THREE.Box3();

        var fragmentMap = getFragmentMap();
        if (fragmentMap) {
            var fragList = model.getFragmentList();
            
            var sset = _this.selectedObjectIds;
            for (var p in sset) {
                var dbId = parseInt(p);
                fragmentMap.enumNodeFragments(dbId, function(fragId) {
                    fragList.getWorldBounds(fragId, box);
                    bounds.union(box);
                }, true);
            }
        }
        
        return bounds;
    };

    this.getSelectionVisibility = function () {
        var hasVisible = false,
            hasHidden = false;

        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var dbId = parseInt(p);
            if (dbId) {
                var map = getFragmentMap();
                if (!map || !map.isNodeHidden(dbId)) {
                    hasVisible = true;
                } else {
                    hasHidden = true;
                }
                if (hasVisible && hasHidden) {
                    break;
                }
            }
        }

        return { 
            hasVisible: hasVisible, 
            hasHidden: hasHidden,
            model: model
        };
    };

    this.dtor = function () {
        this.selectedObjectIds = null;
    };

}

avp.Selector = Selector;


function MultiModelSelector(viewer) {

    var _models = [];

    this.addModel = function(model) {
        if (_models.indexOf(model) == -1) {
            model.selector = new Selector(viewer, model);
            _models.push(model);
        }
    };

    this.removeModel = function(model) {
        var idx = _models.indexOf(model);

        // make sure that we don't keep any highlighting proxy
        var selected = model.selector.getSelection();
        model.selector.clearSelection();
        model.selector = null;
        _models.splice(idx, 1);
    };

    function warn() {
        if (_models.length > 1) {
            avp.logger.warn("This selection call does not yet support multiple models.");
        }
    }

    function fireAggregateSelectionChangedEvent() {

        var perModel = [];

        for (var i=0; i<_models.length; i++) {
            var dbIdArray = [];
            var fragIdsArray = [];

            var sset = _models[i].selector.selectedObjectIds;
            var map = _models[i].selector.getFragmentMap();
            for (var p in sset) {
                if (sset[p]) {
                    var dbId = parseInt(p);
                    if (dbId) {
                        dbIdArray.push(dbId);

                        if (map) {
                            map.enumNodeFragments(dbId, function (fragId) {
                                fragIdsArray.push(fragId);
                            }, false);
                        }
                    }
                }
            }

            if (dbIdArray.length) {
                perModel.push({
                    fragIdsArray: fragIdsArray,
                    dbIdArray: dbIdArray,
                    nodeArray: dbIdArray,
                    model: _models[i]
                });
            }
        }

        var event;

        //For backwards compatibility, fire the old selection change event
        //when there is just one model in the scene
        if (_models.length === 1) {
            event = {
                type: av.SELECTION_CHANGED_EVENT,
                fragIdsArray: perModel[0] ? perModel[0].fragIdsArray : [],
                dbIdArray: perModel[0] ? perModel[0].dbIdArray : [],
                nodeArray: perModel[0] ? perModel[0].dbIdArray : [],
                model: _models[0]
            };
            viewer.api.dispatchEvent(event);
        }

        //Always fire the aggregate selection changed event
        event = {
            type: av.AGGREGATE_SELECTION_CHANGED_EVENT,
            selections: perModel
        };
        viewer.api.dispatchEvent(event);

    }


    function deselectInvisible() {

        var changed = false;

        for (var i=0; i<_models.length; i++) {
            changed = _models[i].selector.deselectInvisible() || changed;
        }

        if (changed)
            fireAggregateSelectionChangedEvent();
    }


    this.getSelectionLength = function() {
        var total = 0;

        for (var i=0; i<_models.length; i++) {
            total += _models[i].selector.getSelectionLength();
        }

        return total;
    };

    this.getSelection = function() {
        warn();
        if (_models.length > 1)
            avp.logger.warn("Use getAggregateSelection instead of getSelection when there are multiple models in the scene.");
        return _models[0].selector.getSelection();
    };

    this.getAggregateSelection = function() {
        var res = [];
        for (var i=0; i<_models.length; i++) {
            var selset = _models[i].selector.getSelection();
            if (selset && selset.length)
                res.push( { model:_models[i], selection:selset } );
        }

        return res;
    };

    this.clearSelection = function(nofire) {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.clearSelection(nofire);

        if (!nofire)
            fireAggregateSelectionChangedEvent();
    };

    this.toggleSelection = function(dbId, model, selectionType) {
        if (!model) {
            warn();
            model = _models[0];
        }
        model.selector.toggleSelection(dbId, selectionType);

        fireAggregateSelectionChangedEvent();
    };

    this.setSelectionMode = function(mode) {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.setSelectionMode(mode);
    };

    this.setSelection = function(dbNodeArray, model, selectionType) {
        if (!dbNodeArray || dbNodeArray.length === 0)
            this.clearSelection();
        else {
            if (!model) {
                warn();
                model = _models[0];
            } else {
                for (var i=0; i<_models.length; i++)
                    if (_models[i] !== model)
                         _models[i].selector.clearSelection();
            }
            model.selector.setSelection(dbNodeArray, selectionType);
        }

        fireAggregateSelectionChangedEvent();
    };

    this.getSelectionBounds = function() {
        if (_models.length == 1)
            return _models[0].selector.getSelectionBounds();
        else {
            var bbox = new THREE.Box3();
            for (var i=0; i<_models.length; i++) {
                var tmp = _models[i].selector.getSelectionBounds();
                bbox.union(tmp);
            }
            return bbox;
        }
    };

    this.getSelectionVisibility = function () {

        var res = { 
            // Aggregated results
            hasVisible: false, 
            hasHidden: false,
            // per model specifics 
            details: [] 
        };
        for (var i=0; i<_models.length; i++) {
            var subRes = _models[i].selector.getSelectionVisibility();
            res.hasVisible = res.hasVisible || subRes.hasVisible;
            res.hasHidden = res.hasHidden || subRes.hasHidden;
            res.details.push(subRes);
        }
        return res;
    };

    this.dtor = function () {
        for (var i=0; i<_models.length; i++)
            _models[i].selector.dtor();
    };


    viewer.api.addEventListener( av.ISOLATE_EVENT, function(event) {
        deselectInvisible();
    });

    viewer.api.addEventListener( av.HIDE_EVENT, function(event) {
        deselectInvisible();
    });


}

av.SelectionType = SelectionType;
avp.MultiModelSelector = MultiModelSelector;

})();


(function() {

    'use strict';

    var av = Autodesk.Viewing,
        avp = av.Private;

    var VisibilityManager = function (viewerImpl, model) {
        this.viewerImpl = viewerImpl;

        //Currently the visibility manager works on a single model only
        //so we make this explicit here.
        this.model = model;

        // Keep track of isolated nodes
        this.isolatedNodes = [];

        // Keeps track of hidden nodes. Only applies when there's no isolated node being tracked.
        this.hiddenNodes = [];
    };

    VisibilityManager.prototype.getInstanceTree = function () {
        if (this.model)
            return this.model.getData().instanceTree;
        else
            return null;
    };

    VisibilityManager.prototype.getFragmentMap = function () {
        if (this.model)
            return this.model.getData().instanceTree || this.model.getData().fragmentMap;
        else
            return null;
    };

    VisibilityManager.prototype.getIsolatedNodes = function () {
        return this.isolatedNodes.slice(0);
    };

    VisibilityManager.prototype.getHiddenNodes = function () {
        return this.hiddenNodes.slice(0);
    };

    /** @params {bool} - visible flag applied to all dbIds/fragments. */
    VisibilityManager.prototype.setAllVisibility = function (visible) {

        var root = this.model ? this.model.getRootId() : null;
        if (root) {
            // if we have an instance tree, we call setVisible on the root node
            this.setVisibilityOnNode(root, visible);
        }

        // 2D datasets may need to call setAllVisibility on the model. This can have two possible reasons:
        //  a) they may have no instance tree, so that setting visibility on root (as above) is not possible.
        //  b) even if they have an instance tree, setting visibility on root node will only reach selectable ids.
        //     2D datasets may also contain unselectable objects with id <=0. In this case, the call below
        //     is needed to hide/show these as well when using isolate/show-all.
        var is2d = this.model.getData().is2d;
        if (is2d) {
            this.model.setAllVisibility(visible);
        }
    };

    VisibilityManager.prototype.isNodeVisible = function(dbId) {
        var it = this.getInstanceTree();
        if (it) {
            // get visibility from instance tree
            return !it.isNodeHidden(dbId);
        } else {
            // If there is no instance tree, we have ids, but no hierarchy.
            // Therefore, an id is only hidden if it appears in hiddenNodes or
            // if there are isolated nodes and dbId is not among these.
            return (this.hiddenNodes.indexOf(dbId)==-1 && (this.isolatedNodes.length==0 || this.isolatedNodes.indexOf(dbId)!=-1));
        }
    };

    VisibilityManager.prototype.isolate = function (node) {
        var it     = this.getInstanceTree();
        var rootId = (it ? it.getRootId() : null);
        var isRoot = (typeof node == "number" && node === rootId)
            || (typeof node == "object" && node.dbId === rootId);

        if (node && !isRoot) {
            this.isolateMultiple(Array.isArray(node) ? node : [node]);
        } else {
            this.isolateNone();
        }
    };

    VisibilityManager.prototype.isolateNone = function () {

        this.model.setAllVisibility(true);
        this.viewerImpl.sceneUpdated(true);

        this.setAllVisibility(true);

        this.hiddenNodes = [];
        this.isolatedNodes = [];
        this.viewerImpl.invalidate(true);

        var event = {type: av.ISOLATE_EVENT, nodeIdArray: [], model: this.model};
        this.viewerImpl.api.dispatchEvent(event);
    };

//Makes the children of a given node visible and
//everything else not visible
    VisibilityManager.prototype.isolateMultiple = function (nodeList) {

        //If given nodelist is null or is an empty array or contains the whole tree
        if (!nodeList || nodeList.length == 0) {
            this.isolateNone();
        }
        else {

            this.setAllVisibility(false);

            // For 3D, visibility is controlled via MESH_VISIBLE flag.
            // For 2D, visibility can only be contolled via a texture in MaterialManager. This already
            // happens in the setVisibilityOnNode(..) call above.
            if (!this.model.getData().is2d) {
                this.model.setAllVisibility(false);
                this.viewerImpl.sceneUpdated(true);
            }

            // Needs to happen after setVisibilityOnNode(root).
            this.isolatedNodes = nodeList.slice(0);
            this.hiddenNodes = [];

            for (var i = 0; i < nodeList.length; i++) {
                this.setVisibilityOnNode(nodeList[i], true);
            }

            var event = {type: av.ISOLATE_EVENT, nodeIdArray: nodeList, model: this.model};
            this.viewerImpl.api.dispatchEvent(event);
        }

        //force a repaint and a clear
        this.viewerImpl.invalidate(true);
    };


//Makes the children of a given node visible and
//everything else not visible
    VisibilityManager.prototype.hide = function (node) {

        var event;

        if (Array.isArray(node)) {
            for (var i = 0; i < node.length; ++i) {
                this.setVisibilityOnNode(node[i], false);
            }

            if (node.length > 0) {
                event = {type: av.HIDE_EVENT, nodeIdArray: node, model: this.model};
            }
        } else {
            this.setVisibilityOnNode(node, false);
            event = {type: av.HIDE_EVENT, nodeIdArray: [node], model: this.model};
        }

        if (event)
            this.viewerImpl.api.dispatchEvent(event);
    };

    VisibilityManager.prototype.show = function (node) {

        var event;

        if (Array.isArray(node)) {
            for (var i = 0; i < node.length; ++i) {
                this.setVisibilityOnNode(node[i], true);
            }

            if (node.length > 0) {
                event = {type: av.SHOW_EVENT, nodeIdArray: node, model: this.model};
            }
        } else {
            this.setVisibilityOnNode(node, true);
            event = {type: av.SHOW_EVENT, nodeIdArray: [node], model: this.model};
        }

        if (event)
            this.viewerImpl.api.dispatchEvent(event);
    };

    VisibilityManager.prototype.toggleVisibility = function (node) {
        var hidden = this.getFragmentMap().isNodeHidden(node);
        this.setVisibilityOnNode(node, hidden); //Note -- toggle visibility, so we want !!hidden => hidden

        var event = {type: hidden ? av.SHOW_EVENT : av.HIDE_EVENT, nodeIdArray: [node], model: this.model};
        this.viewerImpl.api.dispatchEvent(event);
    };

    VisibilityManager.prototype.setVisibilityOnNode = function (node, visible) {

        var viewer = this.viewerImpl;
        var model = this.model;
        var fragmentMap = this.getFragmentMap();
        var hidden = !visible;
        var is2d   = model.getData().is2d;
        var matMan = this.viewerImpl.matman();

        if (fragmentMap) {
            //Recursively process the tree under the root (recursion is inclusive of the root)
            fragmentMap.enumNodeChildren(node, function (dbId) {

                fragmentMap.setNodeHidden(dbId, hidden);

                if (is2d) {
                    model.getFragmentList().setObject2DGhosted(dbId, !visible);
                } else {
                    fragmentMap.enumNodeFragments(dbId, function (fragId) {
                        model.setVisibility(fragId, visible);
                    }, false);
                }
            }, true);
        } else {
            //No instance tree, assume fragId = dbId
            if (is2d) {
                model.getFragmentList().setObject2DGhosted(node, !visible);
            } else {
                model.setVisibility(node, visible);
            }
        }

        viewer.sceneUpdated(true);
        this.updateNodeVisibilityTracking(node, visible);
    };

    VisibilityManager.prototype.updateNodeVisibilityTracking = function(node, visible) {

        // Update hidden tracking array.
        var toVisible = visible;
        if (this.isolatedNodes.length > 0) {
            var isoIndex = this.isolatedNodes.indexOf(node);
            if (toVisible && isoIndex === -1) {
                this.isolatedNodes.push(node);
            }
            else if (!toVisible && isoIndex !== -1) {
                this.isolatedNodes.splice(isoIndex, 1);
            }
        } else {
            var hidIndex = this.hiddenNodes.indexOf(node);
            if (!toVisible && hidIndex === -1) {
                this.hiddenNodes.push(node);
            }
            else if (toVisible && hidIndex !== -1) {
                this.hiddenNodes.splice(hidIndex, 1);
            }
        }

        // When operating with the node, we can get simplify stuff.
        var instanceTree = this.getInstanceTree();
        if (instanceTree && instanceTree.root && instanceTree.root.dbId === node) {
            if (visible) {
                this.isolatedNodes = [];
                this.hiddenNodes = [];
            } else {
                this.isolatedNodes = [];
                this.hiddenNodes = [node];
            }
        }
    };

    VisibilityManager.prototype.setNodeOff = function (node, isOff) {
        var viewer = this.viewerImpl;
        var model = this.model;
        var fragmentMap = this.getFragmentMap();
        var is2d   = model.getData().is2d;

        if (fragmentMap) {
            //Recursively process the tree under the root (recursion is inclusive of the root)
            fragmentMap.enumNodeChildren(node, function (dbId) {

                fragmentMap.setNodeOff(dbId, isOff);

                if (is2d) {
                    model.getFragmentList().setObject2DVisible(dbId, !isOff);
                } else {
                    fragmentMap.enumNodeFragments(dbId, function (fragId) {
                        model.getFragmentList().setFragOff(fragId, isOff);
                    }, false);
                }

            }, true);
        } else {
            if (is2d) {
                model.getFragmentList().setObject2DVisible(node, !isOff);
            } else {
                model.getFragmentList().setFragOff(node, isOff);
            }
        }

        viewer.sceneUpdated(true);
    };


    av.Private.VisibilityManager = VisibilityManager;
    
    
    
    function MultiModelVisibilityManager(viewer) {
    
        this.viewer = viewer;
        this.models = [];
    
    }
    
    MultiModelVisibilityManager.prototype.addModel = function(model) {
        if (this.models.indexOf(model) == -1) {
            model.visibilityManager = new VisibilityManager(this.viewer, model);
            this.models.push(model);
        }
    };

    MultiModelVisibilityManager.prototype.removeModel = function(model) {
        var idx = this.models.indexOf(model);

        // clear visibility states (revert all ghosting)
        model.visibilityManager.isolateNone();

        model.visibilityManager = null;
        this.models.splice(idx, 1);
    };

    MultiModelVisibilityManager.prototype.warn = function() {
        if (this.models.length > 1) {
            avp.logger.warn("This selection call does not yet support multiple models.");
        }
    };

    
    MultiModelVisibilityManager.prototype.getIsolatedNodes = function (model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        return model.visibilityManager.getIsolatedNodes();
    };

    MultiModelVisibilityManager.prototype.getHiddenNodes = function (model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        return model.visibilityManager.getHiddenNodes();
    };

    MultiModelVisibilityManager.prototype.isNodeVisible = function(model, dbId) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        return model.visibilityManager.isNodeVisible(dbId);
    };

    MultiModelVisibilityManager.prototype.isolate = function (node, model) {
        var models = model ? [model] : this.models;
        models.forEach(function(mod){
            mod.visibilityManager.isolate(node);
        });
    };

//Makes the children of a given node visible and
//everything else not visible
    MultiModelVisibilityManager.prototype.hide = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.hide(node);
    };

    MultiModelVisibilityManager.prototype.show = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.show(node);
    };

    MultiModelVisibilityManager.prototype.toggleVisibility = function (node, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.toggleVisibility(node);        
    };

    MultiModelVisibilityManager.prototype.setVisibilityOnNode = function (node, visible, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.setVisibilityOnNode(node, visible);
    };

    MultiModelVisibilityManager.prototype.setNodeOff = function (node, isOff, model) {
        if (!model) {
            this.warn();
            model = this.models[0];
        }
        model.visibilityManager.setNodeOff(node, isOff);
    };

    
    
    av.Private.MultiModelVisibilityManager = MultiModelVisibilityManager;

})();

AutodeskNamespace('Autodesk.Viewing');

Autodesk.Viewing.KeyCode = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        ESCAPE: 27,
        SPACE: 32,
        PAGEUP: 33,
        PAGEDOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        INSERT: 45,
        DELETE: 46,
        ZERO: 48,
        SEMICOLONMOZ: 59,
        EQUALSMOZ: 61,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        LCOMMAND: 91,
        RCOMMAND: 93,
        PLUS: 107,
        PLUSMOZ: 171,
        DASHMOZ: 109,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        DASHMOZNEW: 173,
        SEMICOLON: 186,
        EQUALS: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        SLASH: 191,
        LBRACKET: 219,
        RBRACKET: 221,
        SINGLEQUOTE: 222,
        COMMANDMOZ: 224
};


/**
 * Core interface to add and remove canvas interactions to the viewer.
 *
 * This class is created internally by the Viewer api and is available via the "toolController" property
 * of the Viewer3D api object. Client implementations should not normally instantiate this class directly.
 * @param {Object} viewerImpl - The viewer implementation object.
 * @param {Object} viewerApi - The viewer api object.
 * @param {Object} autocam - The Autocam interface object.
 * @param {Object} utilities - The ViewingUtilities object.
 * @param {Object} defaultHandler - The default event handling tool.
 * @constructor
 * @see Autodesk.Viewing.Viewer3D
 * @category Core
 */
Autodesk.Viewing.ToolController = function( viewerImpl, viewerApi, autocam, utilities, defaultHandler )
{
    var av = Autodesk.Viewing;
    var avp = Autodesk.Viewing.Private;

    this.domElement = viewerApi.canvasWrap;
    this.selector = viewerImpl.selector;
    this.autocam = autocam;
    this.lastClickX = -1;
    this.lastClickY = -1;
    this.scrollInputEnabled = true;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isFirefox = (navigator.userAgent.search("Firefox") != -1);
    var isChrome = (navigator.userAgent.search("Chrome") !== -1);
    var isSafari = (navigator.userAgent.search("Safari") !== -1 && !isChrome); // Chrome has both Safari and Chrome in the string

    var kMouseLeft = 0;
    var kMouseRight = 2;

    var kClickThreshold = 2;        // Pixels
    var kDoubleClickDelayThreshold = 500; // ms

    var _tools = {};
    var _toolStack = [];
    var _lock = false;
    var _downX = -1;
    var _downY = -1;

    var _firefoxLMBfix = false;
    var _currentCursor = null;
    var _lastTouchedElement = undefined;
    var _mouseEnabled = false;

    // Save click parameters when clicking with right mouse button
    // and "Left handed mouse setup" is enabled so that we can
    // simulate a double-click with the right mouse button.
    //
    var _checkMouseDoubleClick = {};

    var _this = this;

    var _keys = Autodesk.Viewing.KeyCode;

    this.__registerToolByName = function(tool, toolName)
    {
        _tools[toolName] = tool;
    };

    /**
     * This method registers an event handling tool with the controller.
     * This makes the tool available for activation and deactivation.
     * Tools are registered under one or more names which must be provided via their "getNames" method.
     * The tools "getNames" method must return an array of one or more names.
     * Typically a tool will only have one name but if it wishes to operate in different modes it can use
     * different names to activate the modes. Registered tools have the properties named
     * "utilities" and "controller" added to them which refer to the ViewingUtilities object and this controller
     * respectively. Tools may not use the name "default" which is reserved.
     *  @param {object} tool - The tool to be registered.
     */
    this.registerTool = function(tool)
    {
        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            avp.logger.warn("Cannot register tool with no name.");
            return false;
        }
        var registered = false;
        for( var i = 0; i < names.length; ++i )
        {
            if( names[i] !== "default" )
            {
                this.__registerToolByName(tool, names[i]);
                registered = true;
            }
        }

        tool.utilities = utilities;
        tool.controller = this;
        if (tool.register) tool.register();

        return registered;
    };

    /**
     * This method deregisters an event handling tool with the controller afterwhich it will no longer
     * be available for activation and deactivation. All names that the tool is registered under
     * will be deregistered. If any tool is active at the time of deregistration will first be deactivated
     * and it's "deactivate" method will be called.
     *  @param {object} tool - The tool to be deregistered.
     */
    this.deregisterTool = function(tool)
    {
        this.deactivateTool(tool.getName());

        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            return false;
        }
        for( var i = names.length; --i >= 0; )
            this.__deregisterToolName(names[i]);

        if (tool.deregister) tool.deregister();
        tool.utilities = null;
        tool.controller = null;
        return true;
    };

    this.__deregisterToolName = function(name)
    {
        function cleanStack(name)
        {
            for( var i = _toolStack.length;  --i >= 0;  )
                if( _toolStack[i].activeName === name )
                {
                    _tools[name].deactivate(name);
                    _toolStack.splice(i, 1);
                }
        }
        if( name in _tools )
        {
            cleanStack(name);
            delete _tools[name];
        }
    };

    /**
     * This method returns the tool registered under the given name.
     * @param {string} name - The tool name to look up.
     * @returns {object} The tool registered under the given name or undefined if not found.
     */
    this.getTool = function(name)
    {
        return _tools[name];
    };

    /**
     * This method returns the name of the topmost tool on the tool stack.
     * If no tools are active the name of the default tool is returned (which is "default").
     * @returns {string} The tool name to look up.
     */
    this.getActiveToolName = function()
    {
        var l = _toolStack.length;
        return (l > 0) ? _toolStack[l-1].activeName : "default";
    };

    /**
     * This method returns the name of the topmost tool on the tool stack.
     * If no tools are active the name of the default tool is returned (which is "default").
     * @returns {string} The tool name to look up.
     */
    this.getActiveTool = function()
    {
        var l = _toolStack.length;
        return (l > 0) ? _toolStack[l-1] : _tools["default"];
    };

    this.isToolActivated = function(toolName)
    {
        for (var i = 0; i < _toolStack.length; i++) {

            if (_toolStack[i].activeName === toolName) {
                return true;
            }
        }
        return false;
    };
    
    this.setToolActiveName = function(toolName) 
    {
        var tool = _tools[toolName];
        if (tool) {
            tool.activeName = toolName;
        }
    };

    /**
     * Activates the tool registered under the given name. Activation implies pushing the tool
     * on a stack of "active" tools, each of which (starting from the top of the stack) is given
     * the opportunity to handle incoming events. Tools may "consume" events by returning true
     * from their event handling methods, or they may allow events to be passed down to the next tool
     * on the stack by returning false from the handling methods.
     * Upon activation the tools "activate" method is called with the name under which it has been activated.
     * Activation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked"
     * and "getIsLocked"). Tools must be registered prior to activation (see the methods "registerTool"
     * and "deregisterTool").
     * @param {string} toolName - The name of the tool to be activated.
     * @returns {boolean} True if activation was successful.
     */
    this.activateTool = function(toolName)
    {
        if( _lock )
            return false;

        var tool = _tools[toolName];
        if( tool )
        {
            if (tool.count === undefined)
                tool.count = 0;

            var interceptor = null;
            if (_toolStack.length && _toolStack[_toolStack.length - 1].activeName === "intercept") {
                interceptor = _toolStack.pop();
            }

            for (var i = 0; i < _toolStack.length; i++) {

                if (_toolStack[i] === tool) {
                    tool.count++;
                }
            }

            tool.activeName = toolName;

            // If the tool belongs to a same instance in tool stack, then don't push it into stack.
            if (tool.count === 0) {
                tool.count++;
                _toolStack.push(tool);
            }


            tool.activate(toolName, viewerApi);
            if (interceptor) {
                _toolStack.push(interceptor);
            }

            viewerApi.dispatchEvent(
                {
                    type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                    toolName: toolName,
                    tool: tool,
                    active: true
                });
            return true;
        }
        avp.logger.warn("activateTool not found: " + toolName);
        return false;
    };

    /**
     * The first tool found on the active stack with the given name is removed and its "deactivate" method
     * is called. Once deactivated the tool will no longer receive events via its handler methods.
     * Deactivation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked"
     * and "getIsLocked").
     * @param {string} toolName - The name of the tool to be deactivated.
     * @returns {boolean} True if deactivation was successful.
     */
    this.deactivateTool = function(toolName)
    {
        if( _lock )
            return false;

        for( var i = _toolStack.length;  --i >= 0;  )
        {
            if( _toolStack[i].activeName === toolName )
            {
                if (_tools[toolName].count === 1)
                    _toolStack.splice(i, 1);

                _tools[toolName].count--;

                _tools[toolName].deactivate(toolName);

                viewerApi.dispatchEvent(
                    {
                        type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                        toolName: toolName,
                        tool: _toolStack[i],
                        active: false
                    });

                return true;
            }
        }
        avp.logger.warn("deactivateTool not found: " + toolName);
        return false;
    };

    /**
     * Obtain a list of all the currently registered tool names.
     * @returns {array} List of all registered tool names.
     */
    this.getToolNames = function()
    {
        return Object.keys(_tools);
    };

    /**
     * Set the tool which will be requested to handle events if no other active tool handles them.
     * @param {object} tool - The tool to be registered as the default.
     */
    this.setDefaultTool = function(tool)
    {
        var current = this.getDefaultTool();
        if( tool && tool !== current )
        {
            this.__registerToolByName(tool, "default");
            if( current )
                current.deactivate("default");
            tool.activate("default");
            return true;
        }
        return false;
    };

    /**
     * Get the tool which handle events if no other active tool handles them.
     * @returns {object} The tool to be registered as the default.
     */
    this.getDefaultTool = function()
    {
        return _tools["default"];
    };

    this.setDefaultTool(defaultHandler);

    /**
     * Set the controller into a locked or unlocked state. While locked, tool activation and deactivation
     * is not allowed. Locking the controller is sometimes necessary to force an interaction to remain
     * active until it is fully completed.
     * @param {boolean} state - The state of the controller lock.
     * @returns {boolean} The previous state of the lock (this may be used to restore the lock
     * to it's previous state).
     */
    this.setIsLocked = function(state)
    {
        var prev = _lock;
        _lock = !!state;
        return prev;
    };

    /**
     * Get the current state of the controller lock.
     * @returns {boolean} The state of the lock.
     */
    this.getIsLocked = function()
    {
        return _lock;
    };

    this.__checkCursor = function()
    {
        var cursor = null;
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];
            if( tool.getCursor )
            {
                cursor = tool.getCursor();
                if( cursor )
                    break;
            }
        }
        if( !cursor )
            cursor = "auto";

        if( _currentCursor != cursor )
        {
            viewerApi.canvas.style.cursor = cursor;
            _currentCursor = cursor;
        }
    };

    this.update = function(highResTimestamp)
    {
        this.__checkCursor();

        var refresh = false;

        if( utilities && utilities.update() )
            refresh = true;

        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];
            if( tool.update && tool.update(highResTimestamp) )
                refresh = true;
        }
        if( viewerApi.navigation.getCamera().dirty )
        {
            viewerApi.navigation.updateCamera();
            refresh = true;
            this.cameraUpdated = true;
        } else {
            this.cameraUpdated = false;
        }

        //Delay reporting stationary
        if( refresh )
        {
            viewerApi.navigation.updateCamera();
            this.moveDelay = Date.now() + 150;   // Milliseconds
        }
        else if( this.moveDelay !== 0 )
        {
            var delta = this.moveDelay - Date.now();
            if( delta > 0 )
                refresh = true;
            else
                this.moveDelay = 0;
        }
        return refresh;
    };


    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.__clientToCanvasCoords = function (event, normalized, screen)
    {
        var rect = viewerImpl.canvas.getBoundingClientRect();
        var width  = rect.width;
        var height = rect.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX = event.clientX - rect.left;
        var canvasY = event.clientY - rect.top;
        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;

        // Vector: [0, 1].
        // 0 = top left, +ve right and down.
        //
        if (normalized)
            normalized.set(canvasX / width, canvasY / height, 0.0);

        if (screen)
            screen.set(canvasX, canvasY);
    };

    this.__invokeStack = function( method, arg1, arg2 )
    {
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];

            if( tool[method] && tool[method](arg1, arg2) )
            {
                //avp.logger.log(method + " consumed by " + tool.getName() + " = " + arg1.type);
                return true;
            }
        }
        var last = this.getDefaultTool();
        if( last[method] && last[method](arg1, arg2) )
        {
            //avp.logger.log(method + " consumed by " + last.getName() + " = " + arg1.type);
            return true;
        }
        return false;
    };

    this.distributeEvent = function(methodName, arg1, arg2)
    {
        return this.__invokeStack(methodName, arg1, arg2);
    };

    this.handleResize = function()
    {
        viewerApi.navigation.setScreenViewport( viewerApi.container.getBoundingClientRect() );

        // Call handleResize on all tools in case they need it:
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _toolStack[n];

            if( tool.handleResize )
                tool.handleResize();
        }
    };

    this.handleSingleClick = function( event )
    {
        var button = this.applyButtonMappings( event );
        this.lastClickX = event.clientX;
        this.lastClickY = event.clientY;

        if( this.__invokeStack("handleSingleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleClick = function( event )
    {
        var button = this.applyButtonMappings( event );

        if( this.__invokeStack("handleDoubleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleSingleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleSingleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleDoubleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleWheelInput = function(delta, event)
    {
        if( this.__invokeStack("handleWheelInput", delta) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.applyButtonMappings = function( event )
    {
        var button = event.button;

        // Check for Firefox spoof: Control+LMB converted to RMB.
        // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
        if( "buttons" in event )
        {
            // This method sometimes gets called more than once with
            // the same event:
            if( event.firefoxSpoof )
            {
                button = kMouseLeft;
            }
            // For button down the 1 bit will be on indicating LMB.
            // For button up it's off so check the flag to see if we
            // switched the down event.
            else if( _firefoxLMBfix && !(event.buttons & 1) ) // Button up?
            {
                event.firefoxSpoof = true;
                _firefoxLMBfix = false;
                button = kMouseLeft;
            }
            else if( (button === kMouseRight) && (event.buttons & 1) )
            {
                button = kMouseLeft;    // Convert back to reality.
                event.firefoxSpoof = _firefoxLMBfix = true;
            }
        }
        if( viewerApi.navigation.getUseLeftHandedInput() )
        {
            button = (button === kMouseLeft)  ? kMouseRight :
                     (button === kMouseRight) ? kMouseLeft  : button;
        }
        return button;
    };

    this.applyKeyMappings = function( event, state )
    {
        switch( event.keyCode )
        {
            case _keys.LCOMMAND:
            case _keys.RCOMMAND:
            case _keys.COMMANDMOZ:
                // Most likely is a Mac but check anyway.
                // We need to ignore Command + Shift combo:
                return ( isMac && event.metaKey && event.shiftKey ) ? null : _keys.CONTROL;

            case _keys.SHIFT:
                // We need to ignore Command + Shift combo:
                return ( state && isMac && event.metaKey ) ? null : _keys.SHIFT;

            case _keys.EQUALSMOZ:   return _keys.EQUALS;

            case _keys.DASHMOZNEW:
            case _keys.DASHMOZ:     return _keys.DASH;
        }
        return event.keyCode;
    };

    this.handleKeyDown = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyDown", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleKeyUp = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyUp", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonDown = function( event, button )
    {
        if( this.__invokeStack("handleButtonDown", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonUp = function( event, button )
    {
        if( this.__invokeStack("handleButtonUp", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleMouseMove = function( event )
    {
        if( this.__invokeStack("handleMouseMove", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleBlur = function( event )
    {
        if( this.__invokeStack("handleBlur", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    // ====================================================
    // Event handlers: (only use "_this" in these methods):

    this.keydown = function( event )
    {
        if (!_this.domElement.contains(_lastTouchedElement) ||
            document.activeElement instanceof HTMLInputElement ||
            document.activeElement instanceof HTMLTextAreaElement ||
            document.activeElement instanceof HTMLSelectElement) return;

        // Support for HTML5 editable divs
        if (document.activeElement) {
            var divIsEditable = document.activeElement.getAttribute('contenteditable');
            if (divIsEditable ===  'true' || divIsEditable === '') {
                // TODO: Proper handle of value 'inherit'
                return;
            }
        }

        // Ignore command key shortcuts on the mac.
        // We don't seem to get key up events for these keys.
        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyDown(event);
    };

    this.keyup = function( event )
    {
        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyUp(event);
    };

    function shouldCheckDoubleClick(button, event) {
        return (viewerApi.navigation.getUseLeftHandedInput() && button === 0) || (isFirefox && button === 1) ||
            (isMac && !isSafari && button === 0 && event.ctrlKey);
    }

    this.mousedown = function( event )
    {
        // Don't do blur in full screen (IE issue)
        if (!(av.isIE11 && av.inFullscreen())) {
            document.activeElement && document.activeElement.blur && document.activeElement.blur();
        }

        _this.__clientToCanvasCoords(event);

        var buttonDown = _this.applyButtonMappings( event );
        _this.handleButtonDown( event, buttonDown );

        _downX = event.canvasX;
        _downY = event.canvasY;

        if( shouldCheckDoubleClick(buttonDown, event) )
        {
            var cmdc = _checkMouseDoubleClick;

            var delayOK = ((cmdc.time !== undefined) &&
                ((event.timeStamp - cmdc.time) < kDoubleClickDelayThreshold));

            var positionOK = ((cmdc.x !== undefined && cmdc.y !== undefined) &&
                (Math.abs(cmdc.x - event.canvasX) <= kClickThreshold) &&
                (Math.abs(cmdc.y - event.canvasY) <= kClickThreshold));

            if (!delayOK || !positionOK || (cmdc.clickCount && 2 <= cmdc.clickCount)) {
                cmdc.clickCount = 0;
            }

            if (!cmdc.clickCount) {
                cmdc.clickCount = 1;
                cmdc.x = event.canvasX;
                cmdc.y = event.canvasY;
                cmdc.time = event.timeStamp;

            } else if (cmdc.clickCount === 1) {
                cmdc.clickCount = 2;
            }
        }

        function handleUp(event)
        {
            var buttonUp = _this.applyButtonMappings( event );
            if( buttonUp === buttonDown )
            {
                document.removeEventListener( 'mouseup', handleUp );
                _this.mouseup(event);
            }
        }

        document.addEventListener( 'mouseup', handleUp, false );

        _this.registerWindowMouseMove();
    };

    this.mousemove = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var deltaX = _downX - event.canvasX;
        var deltaY = _downY - event.canvasY;
        if( Math.abs(deltaX) > kClickThreshold || Math.abs(deltaY) > kClickThreshold )
        {
            _downX = -1;
            _downY = -1;
        }
        _this.handleMouseMove(event);
    };

    this.mouseup = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var buttonUp = _this.applyButtonMappings( event );
        _this.handleButtonUp( event, buttonUp );

        var deltaX = _downX - event.canvasX;
        var deltaY = _downY - event.canvasY;

        _downX = -1;
        _downY = -1;

        if( Math.abs(deltaX) <= kClickThreshold && Math.abs(deltaY) <= kClickThreshold )
            _this.handleSingleClick( event );

        if( shouldCheckDoubleClick(buttonUp, event) )
        {
            var cmdc = _checkMouseDoubleClick;
            if (cmdc.clickCount === 2) {
                _this.handleDoubleClick(event);

                cmdc.clickCount = 0;
                cmdc.x = undefined;
                cmdc.y = undefined;
                cmdc.time = undefined;
            }
        }

        _this.unregisterWindowMouseMove();
    };

    this.doubleclick = function( event )
    {
         _this.__clientToCanvasCoords(event);

        _downX = event.canvasX;
        _downY = event.canvasY;

        _this.handleDoubleClick( event );
    };

    this.mousewheel = function( event )
    {
        if (!_this.scrollInputEnabled) {
            return;
        }

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
            delta = event.wheelDelta / 40;
        }
        else if ( event.detail ) { // Firefox
            delta = - event.detail;
        }
        _this.handleWheelInput( delta, event );
    };

    this.blur = function(event)
    {
        _this.handleBlur(event);
    };

    // ??? this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

    this.mouseover = function(e)
    {
        _lastTouchedElement = e.target;
        // ??? if (_lastTouchedElement != viewerImpl.canvas) _this.autoMove(-1, false)
    };

    // to maintain drag continuity outside the canvas element
    // move mousemove/over listeners from canvas to window
    this.registerWindowMouseMove = function() {
        window.addEventListener( 'mousemove', _this.mousemove );
        window.addEventListener( 'mouseover', _this.mouseover );
        _this.domElement.removeEventListener( 'mousemove', _this.mousemove );
        _this.domElement.removeEventListener( 'mouseover', _this.mouseover );
    };

    this.unregisterWindowMouseMove = function() {
        window.removeEventListener( 'mousemove', _this.mousemove );
        window.removeEventListener( 'mouseover', _this.mouseover );
        _this.domElement.addEventListener( 'mousemove', _this.mousemove );
        _this.domElement.addEventListener( 'mouseover', _this.mouseover );
    };

    this.enableMouseButtons = function(state)
    {   
        if( state && !_mouseEnabled )
        {
            this.domElement.addEventListener( 'mousedown', this.mousedown );
            this.domElement.addEventListener( 'dblclick',  this.doubleclick );
            this.domElement.addEventListener( 'mousemove', this.mousemove );
            this.domElement.addEventListener( 'mouseover', this.mouseover );
        }
        else if( !state && _mouseEnabled )
        {
            this.domElement.removeEventListener( 'mousedown', this.mousedown );
            this.domElement.removeEventListener( 'dblclick',  this.doubleclick );
            this.domElement.removeEventListener( 'mousemove', this.mousemove );
            this.domElement.removeEventListener( 'mouseover', this.mouseover );
        }
        var returnValue = _mouseEnabled;
        _mouseEnabled = state;

        return returnValue;
    };

    // If we want to continue listenting to mouse movements outside of the window
    // we need to tie our event listener to the window

    this.domElement.addEventListener( 'mousewheel',     this.mousewheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', this.mousewheel, false ); // firefox

    //** this.domElement.addEventListener( 'touchstart', function( event ) { _this.touchstart( event )}, false );
    //** this.domElement.addEventListener( 'touchmove', function( event ) { _this.touchmove( event )}, false );

    window.addEventListener( 'keydown', this.keydown, false );
    window.addEventListener( 'keyup',   this.keyup,   false );
    window.addEventListener( 'blur', this.blur, false );

    this.uninitialize = function () {
        if( _mouseEnabled ) {
            // remove them all just to be sure, doesn't hurt
            this.domElement.removeEventListener('mousemove', this.mousemove);
            this.domElement.removeEventListener('mouseover', this.mouseover);
            window.removeEventListener( 'mousemove', _this.mousemove );
            window.removeEventListener( 'mouseover', _this.mouseover );
        }
        window.removeEventListener('keydown', this.keydown);
        window.removeEventListener('keyup', this.keyup);
        window.removeEventListener('blur', this.blur);

        this.domElement = null;
        this.selector = null;
        this.autocam = null;
        // Deactivate all active tools
        while( _toolStack.length > 0 )
            this.deactivateTool(_toolStack[_toolStack.length - 1].activeName);
        _tools = null;
        _toolStack = null;
        _this = null;
        utilities = null;
        viewerApi = null;
        viewerImpl = null;
        _lastTouchedElement = null;
    };

    // Compatibility methods. TODO: eliminate these
    this.set2DMode = function(state) {};
    this.setAutocam = function(autocam) {};
    this.syncCamera = function() {};

    // TODO: implement this in navapi - then set autocam home from navapi values
    this.recordHomeView = function()
    {
        var camera = viewerApi.navigation.getCamera();
        autocam.sync( camera );
        autocam.setHomeViewFrom( camera );
    };

    /**
     * Whether mouse scroll wheel (and/or two-finger vertical swipe) will trigger a camera zoom operation.
     * @param {boolean} isEnabled
     */
    this.setMouseWheelInputEnabled = function(isEnabled) {
        this.scrollInputEnabled = isEnabled;
    };
};

AutodeskNamespace('Autodesk.Viewing');

/**
 * Variety of utilities convenient to navigation and tool development.
 *
 * This class is instantiated internally and made available to all registered interaction tools
 * via their "utilities" property.
 * @see {@link Autodesk.Viewing.ToolController}
 * @param {object} viewerImpl - The viewer implementation object.
 * @param {object} autocam - The Autocam interface object.
 * @param {object} navigation - The Navigation interface object.
 * @constructor
 * @category Core
 */
Autodesk.Viewing.ViewingUtilities = function( viewerImplIn, autocam, navapi )
{
    this.autocam = autocam;
    this.viewerImpl = viewerImplIn;

    var kIndicatorPixelSize = 5;    // Pixels
	var _camera = navapi.getCamera();
    var _savePivot = {};
    var _savePivotSet = {};
    
    function PivotIndicator( viewerImpl )
    {
        var kFadeTimeMilliseconds = 500;
        var kIndicatorColor   = 0x007F00;
        var kIndicatorOpacity = 0.6;

        var myFadeTime = 0;
        var myGeometry = new THREE.SphereGeometry( 1.0 );
        var myMaterial = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
        var myMesh = new THREE.Mesh( myGeometry, myMaterial );
        var myViewerImpl = viewerImpl;
        var myPivotScale = 1.0;

        myViewerImpl.createOverlayScene("pivot");
        myMesh.visible = false;

        this.shown = function()
        {
			return myMesh.visible;
        };

        this.show = function( position, scale, fade )
        {
            myMesh.scale.x = scale * myPivotScale;
            myMesh.scale.y = scale * myPivotScale;
            myMesh.scale.z = scale * myPivotScale;

            myMesh.position.set(position.x, position.y, position.z);
            myMaterial.opacity  = kIndicatorOpacity;

            myMesh.visible = true;
            myViewerImpl.addOverlay("pivot", myMesh);
            myViewerImpl.invalidate(false, false, true);

            if( fade )
            {
                myFadeTime = Date.now() + kFadeTimeMilliseconds;
            }
            else
                myFadeTime = 0;
        };

        this.hide = function()
        {
            if( myMesh.visible )
            {
                myMesh.visible = false;
                myViewerImpl.removeOverlay("pivot", myMesh);
                myViewerImpl.invalidate(false, false, true);
                myFadeTime = 0;
            }
        };

        this.fade = function()
        {
            if( myFadeTime > 0 )
            {
                var fadeDelta = myFadeTime - Date.now();

                if( fadeDelta <= 0 )
                {
                    this.hide();
                    return true;
                }
                var opacity = (fadeDelta / kFadeTimeMilliseconds) * kIndicatorOpacity;
                myMaterial.opacity  = opacity;
                return true;
            }
            return false;
        };

        this.fading = function()
        {
            return (myFadeTime > 0);
        };

        /**
         * Changes the Pivot graphic size.
         * Set default size with scale value of 1.
         */
        this.setSize = function(scale) {
            myPivotScale = scale;
        };

        /**
         * Change Pivot color.
         * Example, red is 0xFF0000 
         */
        this.setColor = function(color, opacity) {
            myMaterial.color = new THREE.Color( color );
            
            // opacity is optional
            if (opacity !== undefined) {
                kIndicatorOpacity = opacity;
                myMaterial.opacity = kIndicatorOpacity;
            }
        };
    }

    var _pivotIndicator  = new PivotIndicator(this.viewerImpl);

    function computeOrthogonalUp(pos, coi, worldUp)
    {
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    }

    /**
     * This method triggers a camera view transition as specified by the parameters.
     *  @param {THREE.Vector3} pos - The new world space position of the camera.
     *  @param {THREE.Vector3} coi - The new center of interest (look at point).
     *  @param {number} fov - The new field of view for the camera in degrees.
     *  @param {THREE.Vector3} up - The new camera up direction.
     *  @param {THREE.Vector3} worldUp - The new world up direction.
     *  @param {boolean} reorient - If true the given camera up parameter is ignored
     *  and a new up direction will be calculated to be aligned with the given world up direction.
     *  @param {THREE.Vector3} pivot - The new pivot point.
     */
    this.transitionView = function( pos, coi, fov, up, worldUp, reorient, pivot )
    {
        worldUp = worldUp || navapi.getWorldUpVector();

        var upVec = reorient ? computeOrthogonalUp(pos, coi, worldUp) : up;
        if( !upVec )
            upVec = _camera.up;
        
        pivot = pivot || coi;

        var targetView = {
            position: pos,
              center: coi,
               pivot: pivot,
                 fov: fov,
                  up: upVec,
             worldUp: worldUp,
             isOrtho: (_camera.isPerspective === false)
        };
        autocam.goToView(targetView);
    };

    /**
     * This method triggers a camera view transition to the registered home view for the current scene.
     */
    this.goHome = function()
    {
        this.viewerImpl.track({ name: 'navigation/home', aggregate: 'count' });
        autocam.goHome();
    };

    /**
     * This method performs a hit test with the current model using a ray cast from the given screen coordinates.
     *  @param {number} x - The normalized screen x coordinate in [0, 1].
     *  @param {number} y - The normalized screen y coordinate in [0, 1].
     *  @returns {THREE.Vector3} The world space hit position or null if no object was hit.
     */
    this.getHitPoint = function(x, y)
    {
        y = 1.0 - y;    // Invert Y so 0 == bottom.

        // Map to [-1, 1]
        x = x * 2.0 - 1.0;
        y = y * 2.0 - 1.0;

        var vpVec = new THREE.Vector3(x, y, 1);

        var result = this.viewerImpl.hitTestViewport(vpVec, false);
        return result ? result.intersectPoint : null;
    };

    /**
     * This method activates the in scene pivot indicator.
     * The pivot is positioned at the current camera's pivot point.
     * @param {boolean} fadeIt - If true the indicator will be displayed and then fade away after a short period.
     * @see {@link Autodesk.Viewing.Navigation}
     */
    this.activatePivot = function(fadeIt)
    {
        // Only show pivot for 3D models
        if (!this.viewerImpl.model || this.viewerImpl.model.is2d())
            return;

        var distance = _camera.isPerspective ? navapi.getPivotPlaneDistance()
                                             : navapi.getEyeVector().length();
        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var indicatorSize = kIndicatorPixelSize * worldHeight / (viewport.height * devicePixelRatio);

        _pivotIndicator.show( navapi.getPivotPoint(), indicatorSize, fadeIt );
    };

    /**
     * This method changes the display state of the in scene pivot indicator.
     * If the current scene is 2D this method has no effect.
     * @param {boolean} state - The requested display state for the indicator.
     * @param {boolean} fadeIt - If true and "state" is also true, the indicator will be displayed
     * and then fade away after a short period.
     * @see {@link Autodesk.Viewing.Navigation}
     */
    this.pivotActive = function( state, fadeIt )
    {
        state = state && !navapi.getIs2D();  // Currently disabled in 2D mode.

        fadeIt = fadeIt || false;

        if( !state && _pivotIndicator.shown() )
        {
            _pivotIndicator.hide();
            return;
        }
        if( state )
            this.activatePivot(fadeIt);
    };

    /**
     * Invoke this method to refresh the pivot indicator and continue its fading action if required.
     */
    this.pivotUpdate = function()
    {
        if( _pivotIndicator.shown() && _pivotIndicator.fade() )
            this.viewerImpl.invalidate(false, false, true);
    };

    /**
     * Set the current pivot point and pivot set flag.
     * If the pivot indicator is active its position will be updated accordingly. If a temporary pivot was previously applied, its saved state will be cleared.
     * @param {THREE.Vector3} newPivot - The world space position of the new pivot point.
     * @param {boolean} preserveView - If false the camera's view direction will change
     * to look at the new pivot point. If true the camera's view will not be changed.
     * @param {boolean} isset - The new state of the pivot set flag.
     * @see {@link Autodesk.Viewing.Navigation}
     */
    this.setPivotPoint = function( newPivot, preserveView, isset )
    {
        navapi.setPivotPoint(newPivot);

        if( !preserveView )
            navapi.setTarget(newPivot);

        if( isset )
            navapi.setPivotSetFlag(true);

        this.setTemporaryPivot(null);

        // Disallow showing the pivot when in 2D.
        if (navapi.getIs2D())
            return;

        if( _pivotIndicator.shown() ) // The pivot indicator location may need updating:
            this.activatePivot(_pivotIndicator.fading());
    };

    /**
     * Save a copy of the current pivot point and pivot set flag.
     * @param {string} name - Optional unique name of the saved location.
     */
    this.savePivot = function(name)
    {
        if( !name )
            name = "default";

        _savePivot[name]    = navapi.getPivotPoint();
        _savePivotSet[name] = navapi.getPivotSetFlag();
    };

    /**
     * Restore the saved copy of the current pivot point and pivot set flag.
     * Once restored the saved value is erased.
     * @param {string} name - Optional unique name of the saved location.
     */
    this.restorePivot = function(name)
    {
        if( !name )
            name = "default";

        if( _savePivot[name] )
        {
            var set =_savePivotSet[name]; // Get value before calling setPivotPoint
            this.setPivotPoint( _savePivot[name], true, set );
            if( !set )
            {
                // Force the flag off, setPivotPoint only turns it on.
                navapi.setPivotSetFlag(false);
            }
            delete(_savePivot[name]);
            delete(_savePivotSet[name]);
        }
    };

    /**
     * Allows the caller to save the current pivot and replace it with a new location.
     * If while the temporary pivot is active a new pivot is set via the setPivotPoint method,
     * the saved pivot will be cleared to avoid restoring an out of date pivot location.
     * @param {THREE.Vector3} newPivot - The new pivot to be assigned or null to clear any previously saved pivot.
     */
    this.setTemporaryPivot = function( newPivot )
    {
        if( newPivot )
        {
            var pivot    = navapi.getPivotPoint();
            var pivotSet = navapi.getPivotSetFlag();

            this.setPivotPoint(newPivot, true, pivotSet);

            _savePivot["TEMP"]    = pivot;
            _savePivotSet["TEMP"] = pivotSet;
        }
        else
        {
            delete(_savePivot["TEMP"]);
            delete(_savePivotSet["TEMP"]);
        }
    };

    /**
     * Restore a pivot value that was saved by a call to setTemporary Pivot.
     */
    this.removeTemporaryPivot = function()
    {
        this.restorePivot("TEMP");
    };

    /**
     * Changes the Pivot graphic size.
     * @param {Number} scale - Default size value is 1
     */
    this.setPivotSize = function(scale) {
        _pivotIndicator.setSize(scale);
    };

    /**
     * Change Pivot color and opacity.
     * Example, to get red 100% solid (non-transparent) use setPivotColor(0xFF0000, 1)
     * @param {Number} color - RBG Hex color.
     * @param {Number} [opacity] - Opacity value from 0 (transparent) to 1 (opaque).
     */
    this.setPivotColor = function(color, opacity) {
        _pivotIndicator.setColor(color, opacity);
    };

    /**
     * Return the bounding box of the current model or model selection.
     * @param {boolean} ignoreSelection - If true the current selection is ignored and the model bounds is returned.
     * @returns {THREE.Box3}
     */
    this.getBoundingBox = function( ignoreSelection )
    {
        return this.viewerImpl.getFitBounds(ignoreSelection);
    };

    /**
     * Request a camera transition to fit the current model or model selection into the view frustum.
     * @param {boolean} immediate - If true the transition will be immediate,
     * otherwise animated over a short time period.
     * @returns {object} - Fit positioning information with properties "position" and "target".
     */
    this.fitToView = function(immediate)
    {
        this.viewerImpl.track({ name: 'navigation/fit', aggregate: 'count' });
        this.viewerImpl.fitToView( this.viewerImpl.api.getSelection() );
        this.activatePivot(true);
    };

    this.update = function()
    {
        if( navapi.getRequestFitToView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestFitToView(false);
            this.fitToView();
        }
        if( navapi.getRequestHomeView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestHomeView(false);
            this.goHome();
        }
        var request = navapi.getRequestTransition();
        if( request && !navapi.getTransitionActive() )
        {
            navapi.setRequestTransition(false);
            this.transitionView( request.position, request.coi, request.fov, request.up, request.worldUp, request.reorient, request.pivot );
        }
        return false;
    };
};

AutodeskNamespace('Autodesk.Viewing');
//
// This object handles the default click behaviour, some of which is controlled
// via the "setClickBehavior" configuration.
//
Autodesk.Viewing.DefaultHandler = function( viewerImpl, navapi, utilities )
{
    this.clickConfig = null;

    this.getNames = function()
    {
        return [ "default" ];
    };

    this.getName = function()
    {
        return this.getNames()[0];
    };

    this.setClickBehavior = function(config)
    {
        this.clickConfig = config;
    };

    this.getClickBehavior = function()
    {
        return this.clickConfig;
    };

    this.activate = function(name) {};
    this.deactivate = function(name) {};

    this.handleAction = function(actionArray, rayData)
    {
        for (var i=0; i < actionArray.length; ++i) {
            switch(actionArray[i]) {
            case "selectOnly":
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.setSelection([rayData.dbId], rayData.model);
                    }
                }
                break;
            case "deselectAll":
                if (viewerImpl.selector) {
                   viewerImpl.selector.setSelection([]);
                }
                break;
            case "selectToggle":
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.toggleSelection(rayData.dbId, rayData.model);
                    }
                }
                break;
            case "isolate":
                if (rayData) {
                    viewerImpl.isolate(rayData.dbId);
                }
                break;
            case "showAll":
                viewerImpl.showAll();
                break;
            case "setCOI":
                if (rayData && rayData.intersectPoint) {
                    utilities.setPivotPoint( rayData.intersectPoint, true, true );
                    utilities.pivotActive(true, true);
                }
                break;
            case "hide":
                if (rayData) {
                    viewerImpl.hide(rayData.dbId);
                }
                break;
			case "show":
                if (rayData) {
                    viewerImpl.show(rayData.dbId);
                }
                break;
			case "toggleVisibility":
                if (rayData) {
                    viewerImpl.toggleVisibility(rayData.dbId);
                }
                break;
            case "focus":
                // As a side effect of focus we also select
                if (viewerImpl.selector) {
                    if (rayData) {
                        viewerImpl.selector.setSelection([rayData.dbId], rayData.model);
                    } else {
                        viewerImpl.selector.setSelection([]);
                    }
                    utilities.fitToView();
                }
                break;
            }
        }
    };

    this.handleSingleClick = function( event, button )
    {
        var control = event.ctrlKey || event.metaKey;
        var shift   = event.shiftKey;
        var alt     = event.altKey;

        if (button === 0) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            var key = "click";

            if (control) key += "Ctrl";
            if (shift)   key += "Shift";
            if (alt)     key += "Alt";

            var objectKey = result ? "onObject" : "offObject";

            if (this.clickConfig && this.clickConfig[key] && this.clickConfig[key][objectKey]) {
                this.handleAction(this.clickConfig[key][objectKey], result);
                return true;
            }
        }
        else if (button === 1 && shift && !alt && !control) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if( result && result.intersectPoint )
            {
                utilities.setPivotPoint( result.intersectPoint, true, true );
                utilities.pivotActive(true, true);
                return true;
            }
        }
        return false;
    };

    this.handleDoubleClick = function( event, button )
    {
        if( viewerImpl.selector && button === 0 )
        {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if (result) {
                viewerImpl.selector.setSelection([result.dbId], result.model);
            }
            else {
                viewerImpl.selector.clearSelection();
            }
            utilities.fitToView();
            return true;
        }
        if( button === 1 )
        {
            navapi.fitBounds(false, utilities.getBoundingBox(true));
            navapi.setPivotSetFlag(false);
            return true;
        }
        return false;
    };

    this.handleSingleTap = function( event )
    {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
        viewerImpl.api.triggerSingleTapCallback(event);

        if( event.hasOwnProperty("pointers") && event.pointers.length === 2 )
        {
            navapi.setRequestHomeView(true);
            return true;
        }
        if( viewerImpl.selector)
        {
            var vp = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(vp, false);

            if (result) {
                viewerImpl.selector.setSelection([result.dbId], result.model);
				viewerImpl.api.triggerSelectionChanged([result.dbId]);
            }
            else {
                viewerImpl.selector.clearSelection();
                viewerImpl.api.triggerSelectionChanged(null);
            }
            return true;
        }
        return false;
    };

    this.handleDoubleTap = function( event )
    {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
        viewerImpl.api.triggerDoubleTapCallback(event);

        var result = this.handleSingleTap(event, 0);
        utilities.fitToView();
        return result;
    };

    this.handlePressHold = function( event )
    {
        if( event.type === "press" )
        {
            event.clientX = event.pointers[0].clientX;
            event.clientY = event.pointers[0].clientY;

            return viewerImpl.api.triggerContextMenu(event);
        }
        return false;
    }
}

AutodeskNamespace('Autodesk.Viewing');

Autodesk.Viewing.GestureRecognizers = {
    singletap: [Hammer.Tap, { event: 'singletap', threshold: 7.0, time: 400 } ],
    singletap2: [Hammer.Tap, { event: 'singletap2', pointers: 2, threshold: 7.0, time: 400 } ],
    press: [Hammer.Press, { event: 'press', time: 500, threshold: 50.0 } ],
    doubletap: [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 300, threshold: 6, posThreshold: 30 } ],
    doubletap2: [Hammer.Tap, { event: 'doubletap2', pointers: 2, taps: 2, interval: 300, threshold: 6, posThreshold: 40 } ],
    drag: [Hammer.Pan, { event: 'drag', pointers: 1 } ],
    drag3: [Hammer.Pan, { event: 'drag3', pointers: 3, threshold: 15 } ],
    pan: [Hammer.Pan, { event: 'pan', pointers: 2, threshold: 20 } ],
    pinch: [Hammer.Pinch, { event: 'pinch', pointers: 2, enable: true, threshold: 0.05 } ],
    rotate: [Hammer.Rotate, { event: 'rotate', pointers: 2, enable: true, threshold: 7.0 } ]
};

Autodesk.Viewing.GestureHandler = function(viewerApi)
{
    var av = Autodesk.Viewing;

    var _navapi = viewerApi.navigation;
    var _names = [ "gestures" ];
    var _this = this;
    var _mouseEnabled = true;
    var _twoPointerSwipeEnabled = true;
    var hammer = null;
    var _isActive = false;

    var isTouch = av.isTouchDevice();

    _navapi.setIsTouchDevice(isTouch);

    if( isTouch )
    {
        hammer = new Hammer.Manager(viewerApi.canvasWrap, {
            recognizers: [
                av.GestureRecognizers.drag,
                av.GestureRecognizers.doubletap,
                av.GestureRecognizers.doubletap2,
                av.GestureRecognizers.singletap,
                av.GestureRecognizers.singletap2,
                av.GestureRecognizers.press,
                av.GestureRecognizers.drag3,
                
                // Note: These recognizers are active only when _twoPointerSwipeEnabled is true
                av.GestureRecognizers.pan,
                av.GestureRecognizers.pinch,
                av.GestureRecognizers.rotate
            ],
            inputClass: Hammer.TouchInput
        });
        hammer.get('pinch').recognizeWith([hammer.get('drag')]);
        
        viewerApi.canvasWrap.addEventListener( 'touchstart', this.onTouchStart, false );
    }

    this.onTouchStart = function(event) {
        event.preventDefault();
    };

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    this.isActive = function()
    {
        return _isActive;
    };

    /**
    function dirToString(obj) {
        var output = [];
        for(var key in obj) {
            if(obj.hasOwnProperty(key)) {
                var value = obj[key];
                if(Array.isArray(value)) {
                    value = "Array("+ value.length +"):"+ value;
                } else if(value instanceof HTMLElement) {
                    value = value +" ("+ value.outerHTML.substring(0, 50) +"...)";
                }
                output.push(key +": "+ value);
            }
        }
        return output.join("\n")
    };
    **/


    this.__clientToCanvasCoords = function (event)
    {
        var rect = viewerApi.impl.canvas.getBoundingClientRect();
        var width  = rect.width;
        var height = rect.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX, canvasY;

        if( event.hasOwnProperty("center") )
        {
            canvasX = event.center.x - rect.left;
            canvasY = event.center.y - rect.top;
        }
        else
        {
            canvasX = event.pointers[0].clientX - rect.left;
            canvasY = event.pointers[0].clientY - rect.top;
        }
        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;
    };


    this.distributeGesture = function(event)
    {
        function endsWith(str, suffix)
        {
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleGesture", event) )
            event.preventDefault();

        if( endsWith(event.type, "end") ){
            _this.controller.enableMouseButtons(_mouseEnabled);
        }
    };

    this.onSingleTap = function(event)
    {
        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleSingleTap", event) )
            event.preventDefault();
    };

    this.onDoubleTap = function(event)
    {
        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleDoubleTap", event) )
            event.preventDefault();
    };

    this.onPressHold = function(event)
    {
        _this.__clientToCanvasCoords(event);

        // Slight hack to stop the mouse down event that the browser
        // generates during a press hold:
        if( event.type === "press" )
            _mouseEnabled = _this.controller.enableMouseButtons(false);
        else
            _this.controller.enableMouseButtons(_mouseEnabled);

        if( _this.controller.distributeEvent("handlePressHold", event) )
            event.preventDefault();
    };

    this.activate = function(name)
    {
        if( hammer && !_isActive)
        {
            hammer.on("dragstart dragmove dragend", this.distributeGesture);
            hammer.on("singletap", this.onSingleTap);
            hammer.on("singletap2", this.onSingleTap);
            hammer.on("doubletap", this.onDoubleTap);
            hammer.on("doubletap2", this.onDoubleTap);
            hammer.on("press pressup", this.onPressHold);
            hammer.on("drag3start drag3move drag3end", this.distributeGesture);

            if (_twoPointerSwipeEnabled) {
                hammer.on("panstart panmove panend", this.distributeGesture);
                hammer.on("pinchstart pinchmove pinchend", this.distributeGesture);
                hammer.on("rotatestart rotatemove rotateend", this.distributeGesture);
            }

            // we only want to trigger a tap, when we don't have detected a doubletap
            hammer.get('doubletap2').recognizeWith('doubletap');
            hammer.get('singletap2').recognizeWith('singletap');
            hammer.get('singletap').requireFailure('doubletap');
        }

        _isActive = true;
    };

    this.deactivate = function(name)
    {
        if( hammer && _isActive)
        {
            hammer.off("dragstart dragmove dragend", this.distributeGesture);
            hammer.off("singletap", this.onSingleTap);
            hammer.off("singletap2", this.onSingleTap);
            hammer.off("doubletap", this.onDoubleTap);
            hammer.off("doubletap2", this.onDoubleTap);
            hammer.off("press pressup", this.onPressHold);
            hammer.off("drag3start drag3move drag3end", this.distributeGesture);

            if (_twoPointerSwipeEnabled) {
                hammer.off("panstart panmove panend", this.distributeGesture);
                hammer.off("pinchstart pinchmove pinchend", this.distributeGesture);
                hammer.off("rotatestart rotatemove rotateend", this.distributeGesture);
            }
        }

        _isActive = false;
    };


    this.update = function()
    {
        return false;
    };


    this.handleBlur = function(event) {
        return false;
    };

    /**
     * Disables two finger swipe functionality (pan, rotate, zoom) so that a
     * mobile user can scroll the page where the viewer is being embedded.
     */
    this.disableTwoFingerSwipe = function() {
        _twoPointerSwipeEnabled = false;
        if (hammer) {
            hammer.remove(Hammer.Pan);
            hammer.remove(Hammer.Pinch);
            hammer.remove(Hammer.Rotate);
            hammer.off("panstart panmove panend", this.distributeGesture);
            hammer.off("pinchstart pinchmove pinchend", this.distributeGesture);
            hammer.off("rotatestart rotatemove rotateend", this.distributeGesture);
        }
    }
};

AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.OrbitDollyPanTool = function( viewerImpl, viewerApi )
{
    var avp = Autodesk.Viewing.Private;

    var _this = this;
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kAutoDeltaZ  = 1.5;         // Dolly increment
    var kAutoDeltaXY = 0.01;
    var kAutoScreenXY = 20;
    var kDollyDragScale = 100.0;
    var kDollyPinchScale = 0.5;
    var kOrbitScale = 2.0;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["orbit", "freeorbit", "dolly", "pan"];

    var _activeMode = _names[0];
    var _activations = [ _activeMode ];   // Safeguard
    var _activatedMode = _activeMode;

    var _touchType = null;
    var _pinchScale = 1.0;
    var _prevPinchScale = 1.0;
    var _prevPinchLength = 0;
    var _pinchLength = 0;
    var _deltaRoll = 0.0;
    var _prevRoll = 0.0;

    var _activeModeLocked = false;
    var _autoCamStartXY = null;
    var _interactionActive = false;
    var _lastMouseX, _lastMouseY;

    var _keys = {
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
              SPACE: 32,
             PAGEUP: 33,
           PAGEDOWN: 34,
               LEFT: 37,
                 UP: 38,
              RIGHT: 39,
               DOWN: 40,
               ZERO: 48,
             EQUALS: 187,
               DASH: 189
    };

    // Interaction Triggers:
    var kNone = -5;
    var kKeyboard = -4;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;
    var kTouch = 3;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _touchStartXY  = new THREE.Vector2();
    var _startXY  = new THREE.Vector2();
    var _moveXY   = new THREE.Vector2();
    var _deltaXY  = new THREE.Vector2();
    var _motionDelta = new THREE.Vector3();

    var _rotateStart = new THREE.Vector3();
    var _rotateEnd = new THREE.Vector3();
    var _pivotToEye = new THREE.Vector3();
    var _targetToEye = new THREE.Vector3();
    var _projVector = new THREE.Vector3();
    var _objectUp = new THREE.Vector3();
    var _mouseOnBall = new THREE.Vector3();
    var _rotateNormal = new THREE.Vector3();
    var _quaternion = new THREE.Quaternion();
    var _noRoll = false;
    var _staticMoving = true;
    var _dynamicDampingFactor = 0.2;

    var _autoMove = [false, false, false, false, false, false];  // left, right, up, down, in, out
    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0, SPACE: 0 };

    // Remove rollover effect when mouse is not over the canvas.
    var _onMouseOut = function(event) {
            viewerImpl.renderer().rolloverObjectViewport(0, 0, [0]);
        };

    var kDampingFactor = 0.6;
    var kLookSpeedDefault = 5.0;
    var kDollySpeedDefault = 0.025;
    var kMinDollySpeed = 0.01;
    var kDollyScale = 0.6;

    var _trackingDistance = 1.0;
    var _boundingBox;

    var myLookSpeed = kLookSpeedDefault;
    var myDollySpeed = kDollySpeedDefault;

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        // avp.logger.log("ACTIVATE: " + _activatedMode + " => " + name);
        _activations.push(name);
        _activatedMode = name;

        viewerImpl.canvas.addEventListener('mouseout', _onMouseOut);  
    };

    this.deactivate = function(name)
    {
        var end = _activations.length - 1;
        if( end > 0 && _activations[end] === name )
        {
            _activations.pop();
            _activatedMode = _activations[end-1];

            // avp.logger.log("DEACTIVATE: " + name + " => " + _activatedMode );
        }    

        if (_activations.length === 0)
        {
            viewerImpl.canvas.removeEventListener('mouseout', _onMouseOut);
        }
    };

    this.adjustDollyLookSpeed = function( direction )
    {
        if( direction === 0 )
        {
            myDollySpeed = kDollySpeedDefault;
            myLookSpeed  = kLookSpeedDefault;
        }
        else
        {
            myDollySpeed *= (direction > 0) ?  1.10 : 0.90;
            myLookSpeed  *= (direction > 0) ?  1.10 : 0.90;

            // May need more appropriate minimums (and maximums) here.
            if( myDollySpeed < 0.000001 )
                myDollySpeed = 0.000001;

            if( myLookSpeed < 0.000001 )
                myLookSpeed = 0.000001;
        }
    };

    this.getDollySpeed = function(dollyTarget)
    {
        // Calculate the distance that one unit of virtual dolly will move:
        var view     = _navapi.getEyeVector();
        var position = _navapi.getPosition();
        var projectedLength = dollyTarget.clone().sub(position).dot(view.normalize());
        var distance = projectedLength * myDollySpeed;
        return (Math.abs(distance) < kMinDollySpeed) ? ((distance < 0) ? -kMinDollySpeed : kMinDollySpeed) : distance;
    };

    this.getLookSpeed = function()
    {
        return myLookSpeed;
    };

    this.coiIsActive = function()
    {
        return _navapi.getPivotSetFlag() && _navapi.isPointVisible(_navapi.getPivotPoint());
    };

    this.adjustSpeed = function( direction )
    {
        this.adjustDollyLookSpeed( direction );

        if( this.utilities.autocam )
            this.utilities.autocam.orbitMultiplier = this.getLookSpeed();
    };

    this.getTriggeredMode = function()
    {
        // Fusion wants Shift+Middle to go back to orbit
        if ((_activeTrigger === kMouseMiddle) && _modifierState.SHIFT)
            return _activations[1]; // TODO_NOP: return to chosen orbit behavior, don't use _activations

        return (isDolly() || _motionDelta.z !== 0.0) ? shouldPanOverrideDolly() ? "pan" : "dolly"
            : isTrack() ? "pan"
            : (_touchType === 'pan' || _touchType === 'pinch') ? "dollypan"
            : _activatedMode;
    }

    // TO DO: Where/when do we push/pop tool state?
    function isTrack()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && !mod.SHIFT && !(mod.ALT ^ mod.CONTROL))
            || ((_activeTrigger === kMouseRight)  && mod.SHIFT && mod.CONTROL)
            || ((_activeTrigger === kMouseMiddle) && !mod.SHIFT && !mod.CONTROL)
            || ((_activeTrigger === kMouseMiddle) && mod.ALT)
            || ((_activeTrigger === kMouseMiddle) && mod.CONTROL && !mod.ALT)
            || ((_activeTrigger === kMouseLeft) && mod.SHIFT && !mod.CONTROL && !mod.ALT)
            || ((_activatedMode === "pan") && (_activeTrigger !== kMouseMiddle) && !mod.ALT && !(_touchType === "pinch"))
            || (mod.SPACE);
    }

    function isDolly()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && mod.SHIFT && !mod.ALT && !mod.CONTROL)
            || ((_activeTrigger === kMouseRight)  && mod.ALT && !mod.SHIFT && !mod.CONTROL)
            || ((_activatedMode === "dolly") && !mod.ALT && !(_touchType === "pinch"))
    }

    function shouldPanOverrideDolly()
    {
        var mod = _modifierState;
        return !mod.CONTROL && !mod.ALT && !mod.SHIFT && (_activeTrigger === kMouseRight || _activeTrigger === kMouseMiddle);
    }

    this.initTracking = function(x, y)
    {
        var distance;

        if( !_camera.isPerspective )
        {
            distance = _navapi.getEyeVector().length();
        }
        else
        {
            // Decide what point in world space defines the plane
            // orthogonal to the view that will be used to track
            // the camera. If we get an intersection point use it,
            // otherwise if the pivot point is set use that. The
            // fallback is to use the mid-point of the view frustum.

            distance = (_camera.near + _camera.far) * 0.5;

            var p = this.utilities.getHitPoint(x, y);
            var position = _navapi.getPosition();
            if( p && p.sub )
            {
                // Calculate orthogonal distance along view vector:
                var hitToEye = p.sub(position);
                var view = _navapi.getEyeVector().normalize();
                distance = Math.abs(view.dot(hitToEye));
            }
            else
            {
                var usePivot = _navapi.getPivotSetFlag() && _navapi.isPointVisible(_navapi.getPivotPoint());
                if( usePivot )
                {
                    var pivotDistance = _navapi.getPivotPlaneDistance();
                    if( pivotDistance > kEpsilon )
                    {
                        distance = pivotDistance;
                    }
                }
            }
        }
        _trackingDistance = distance;
    };

    function pivotIsBehind()
    {
        var pivotVector = _navapi.getPivotPoint().sub(_navapi.getPosition());
        return (pivotVector.dot(_navapi.getEyeVector()) <= 0.0);
    }

    this.initOrbit = function()
    {
        // If the pivot point is behind us we pivot around the center of the view:
        this.utilities.setTemporaryPivot(pivotIsBehind() ?  _navapi.getTarget() : null);
    };

    this.getActiveMode = function()
    {
        return _activeMode;
    };

    this.getCursor = function()
    {
        switch( _activeMode )
        {
            case "freeorbit":
            case "orbit":
                return 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAt1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAzMzP6+vri4uISEhKKioqtra2dnZ2EhIR9fX10dHRkZGQdHR3t7e3Hx8e5ubm1tbWoqKhWVlZKSko4ODgICAjv7+/o6OjMzMyxsbFOTk4pKSkXFxcEBAT29vbW1tZ6enpISEgLCwvhzeX+AAAAGXRSTlMANRO0nHRJHfnskIxQRKh89syDVwTWZjEJxPFEswAAAOFJREFUKM+1j+lygkAQhIflEAJe0Rw9u4CCeKKoSTTX+z9XoMJWWeX+ssrvZ3f19DQ5zOw/0DUMQPlmQ72bE2adBp8/Rp3CQUi3ILx+bxj4fjDs9T1Bmo6bbPPN8aDU4bjJt4nb+de789kSFyxn826jW3ICLNZZKU8nWWbrBTCRVm04U8TpjquRFf1Go0d7l8aYOrUR7FGEFr1S9LGymwthgX2gE/Kl0cHPOtF2xOWZ5QpIC93RflW4InkDoPRXesd5LJIMQPzV7tCMa7f6BvhJL79AVDmYTNQ1NhnxbI/uwB8H5Bjd4zQPBAAAAABJRU5ErkJggg==), auto';

            case "dolly":
                return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAgVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8mJiYAAADNzc2/v7+fn59paWlPT08MDAwICAj6+vqpqak7Ozv29vby8vLp6em2traAgIBkZGRZWVlAQEAaGhpISEgkS7tbAAAAFHRSTlMAOvhpZD8mkQWegMy9qY1YVE01EYiqlE0AAADZSURBVCjPbY9ZloMgEAAbEbfsmRZZXbJn7n/AAX2RQVN/VD26AXLOeZLDGo6IbfI9tHq8cdxuj1HwvgCoaiHqKoRk+M3hB9jueUW8PnfsE/bJ3vms7nCkq7NoE3s99AXxoh8vFoXCpknrn5faAuJCenT0xPkYqnxQFJaU0gdZrsKm8aHZrAIffBj40mc1jsTfIJRWegq6opTMvlfqLqYg7kr1ZB7jFgeaMC59N//8O4WZ1IiPF8b5wMHcJn8zB4g4mc77zpxgAbMSUVoGK4iV0hL4wrksz+H0Bw5+E+HrniDQAAAAAElFTkSuQmCC), auto";

            case "pan":
                return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAABHVBMVEUAAABPTk4AAAAAAAAJCQkRERE0MzQQEBAODg4QEBB4d3dbWlo9PDw/Pj4vLy8sLCwZGBgWFhYcHBwKCgoSEhIAAAAKCgoICAgKCgoQEBAODg4EBAQICAgPDw8REREMDAx2dnY0NDQvLy9QUFAaGhomJSYjIyM7OjokJCQNDA0mJiYNDQ0AAAAUFBQJCQkQEBAEBAQNDQ0PDw8VFRX///+amJkAAAD5+fnz8/PKycn9/f339vbi4eLR0dDNzMyAgIB8e3xycHH7+/vw7+/o6OjX1ta7urq4t7iwsLCnp6eioqKbmppva21OTk74+Pjl5eXc3Nzb29vLy8vDw8PDwsKrqqqdnZ2WlpaSkpKTkZKMiouEg4NkZGRISEgxLzBpgbsEAAAANHRSTlMA+fiQXgngKSYG/vX17uvBuqackpCNg3BpUkpAPBwTDvj18+vl0s/NwrOwoZZ+TDg4NBkBGrzX8QAAAP5JREFUKM99j9Vuw0AQRdeuKZyGkyZNmbnXDLHDVGb8/8/oy7paK1bO0+oc7WiGnGiaxq+QRTQAOh8f9Jv4H/Ge8PZPrCdlvkxfYluUT2WyyCq3mZ7unwlKVLcqOzA/Mf71j0TWJ/Ym6rPeca05Ni4iIevYc7yoUD2zQFhq71BdI9nvBeBabFDSPe8DswlUc1Riw3VxbH0NHBUPQ0jrbDnPYDjALQBMq9E7nkC5y7VDKTZlUg8Q0lmjvl74zlYErgvKa42GPKf3/a0kQmYCDY1SYMDosqMoiWrGwz/uAbNvc/fNon4kXRKGq+PUo2Mb96afV0iUxqGU2s4VBbKUP65NL/LKF+7ZAAAAAElFTkSuQmCC), auto";
        }
        return null;
    };

    this.getMotionDelta = function(dxyz, dxy)
    {
        // Add any offset triggered by key controls:
        // TODO: Change these to scale based on real time so fast frame
        // rate doesn't cause super fast motion.

        var autoDeltaZ = (_navapi && _navapi.getReverseZoomDirection()) ? -kAutoDeltaZ : kAutoDeltaZ;
        if( isMac )
            autoDeltaZ *= -1;   // Match the "natural" scroll direction on Mac.

        if( _autoMove[0] ) { _moveXYZ.x += kAutoDeltaXY; _moveXY.x += kAutoScreenXY; }
        if( _autoMove[1] ) { _moveXYZ.x -= kAutoDeltaXY; _moveXY.x -= kAutoScreenXY; }
        if( _autoMove[2] ) { _moveXYZ.y += kAutoDeltaXY; _moveXY.y += kAutoScreenXY; }
        if( _autoMove[3] ) { _moveXYZ.y -= kAutoDeltaXY; _moveXY.y -= kAutoScreenXY; }
        if( _autoMove[4] ) { _moveXYZ.z += autoDeltaZ; }
        if( _autoMove[5] ) { _moveXYZ.z -= autoDeltaZ; }

        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);

        if( dxy )
        {
            dxy.set(_moveXY.x - _startXY.x, _moveXY.y - _startXY.y);
        }
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);

        _startXY.copy(_moveXY);
    };

    function getMouseProjectionOnBall(pageX, pageY)
    {
        var viewport = {left: 0, top: 0, width: window.innerWidth, height: window.innerHeight};

        _mouseOnBall.set(
            (pageX - viewport.width * 0.5 - viewport.left) / (viewport.width * 0.5),
            (viewport.height * 0.5 + viewport.top - pageY) / (viewport.height * 0.5),
            0.0
        );

        var length = _mouseOnBall.length();
        if (_noRoll)
        {
            if (length < Math.SQRT1_2)
            {
                _mouseOnBall.z = Math.sqrt(1.0 - length*length);
            }
            else
            {
                _mouseOnBall.z = .5 / length;
            }
        }
        else if (length > 1.0)
        {
            _mouseOnBall.normalize();
        }
        else
        {
            _mouseOnBall.z = Math.sqrt(1.0 - length * length);
        }
        _pivotToEye.copy(_camera.position).sub(_camera.pivot);
        _projVector.copy(_camera.up).setLength(_mouseOnBall.y)
        _projVector.add(_objectUp.copy(_camera.up).cross(_pivotToEye).setLength(_mouseOnBall.x));
        _projVector.add(_pivotToEye.setLength(_mouseOnBall.z));
        return _projVector;
    }

    function freeOrbit()
    {
        if (!_navapi.isActionEnabled('orbit')) {
            return;
        }

        _pivotToEye.subVectors(_camera.position, _camera.pivot);
        _targetToEye.subVectors(_camera.position, _camera.target);
        var targetDist = _targetToEye.length();
        _targetToEye.normalize();

        var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());
        if (angle)
        {
            angle *= kOrbitScale;
            _rotateNormal.crossVectors(_rotateStart, _rotateEnd).normalize();
            _quaternion.setFromAxisAngle(_rotateNormal, -angle);

            _pivotToEye.applyQuaternion(_quaternion);
            _camera.up.applyQuaternion(_quaternion);
            _rotateEnd.applyQuaternion(_quaternion);
            _targetToEye.applyQuaternion(_quaternion);

            if (_staticMoving)
            {
                _rotateStart.copy(_rotateEnd);
            }
            else
            {
                _quaternion.setFromAxisAngle(_rotateNormal, angle * (_dynamicDampingFactor - 1.0));
                _rotateStart.applyQuaternion(_quaternion);
            }
        }

        _camera.position.addVectors(_camera.pivot, _pivotToEye);
        _camera.target.subVectors(_camera.position, _targetToEye.multiplyScalar(targetDist));
        _camera.dirty = true;
    }

    this.getFitBounds = function()
    {
        if (this.utilities.viewerImpl.zoomBoundsChanged){
            _boundingBox = this.utilities.viewerImpl.getVisibleBounds(true);
            this.utilities.viewerImpl.zoomBoundsChanged = false;
        }

        return _boundingBox;
    };

    this.update = function()
    {
        var wheelEnded = false;
        var updatePivot = false;
        var viewport;

        this.getMotionDelta(_motionDelta, _deltaXY);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( !_activeModeLocked )
            this.checkInteractionMode();

        _activeModeLocked = (_activeTrigger > kWheel);

        if( _activeModeLocked )
            this.controller.setIsLocked(true);

        if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
        {
            switch( _activeMode )
            {
                case "orbit":
                    if( this.utilities.autocam && this.utilities.autocam.startState )
                    {
                        _deltaXY.x = -_deltaXY.x;
                        if( _autoCamStartXY )
                            this.utilities.autocam.orbit(_moveXY, _autoCamStartXY, _deltaXY.multiplyScalar(kOrbitScale), this.utilities.autocam.startState);
                    }
                    break;

                case "freeorbit":
                    freeOrbit();
                    break;

                case "dolly":
                    var dollyTarget, screenX, screenY;

                    deltaZ *= kDollyScale;

                    if( _activeTrigger >= kMouseLeft )
                    {
                        // Map XY movement to Z:
                        deltaY = -deltaY;   // Invert Y
                        deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                        
                        if (_navapi.getReverseZoomDirection()) {
                             deltaZ *= -1;
                        }

                        deltaZ *= kDollyDragScale;
                        deltaX = 0.0;
                        deltaY = 0.0;

                        // Towards center of screen:
                        screenX = screenY = 0.5;
                    }
                    else
                    {
                        // Towards cursor position:
                        viewport = _navapi.getScreenViewport();
                        if (_lastMouseX && _lastMouseY)
                        {
                            screenX = _lastMouseX / viewport.width;
                            screenY = _lastMouseY / viewport.height;
                        }
                        else
                        {
                            screenX = screenY = 0.5;
                        }
                    }
                    if( !_navapi.getIs2D() && _navapi.getZoomTowardsPivot() )
                    {
                        if( !this.coiIsActive() )
                        {
                            // Center of screen if pivot is not active
                            dollyTarget = _navapi.getWorldPoint(0.5, 0.5);
                        }
                        else
                            dollyTarget = _navapi.getPivotPoint();
                    }
                    else
                        dollyTarget = _navapi.getWorldPoint(screenX, screenY);

                    _navapi.dollyFromPoint(deltaZ * this.getDollySpeed(dollyTarget), dollyTarget, this.getFitBounds());
                    break;

                case "pan":
                    // Moving camera down/left moves the model up/right:
                    _navapi.panRelative(-deltaX, deltaY, _trackingDistance);
                    break;

                case "dollypan":

                    if( deltaX !== 0.0 || deltaY !== 0.0 )
                        _navapi.panRelative(-deltaX, deltaY, _trackingDistance);

                    // Towards cursor position:
                    viewport = _navapi.getScreenViewport();
                    screenX = _lastMouseX / viewport.width;
                    screenY = _lastMouseY / viewport.height;

                    dollyTarget = _navapi.getWorldPoint(screenX, screenY);
                    var position = _navapi.getPosition();
                    var distance = _navapi.getIs2D() ? position.sub(dollyTarget).length() : _trackingDistance;
                    var touchScale = _prevPinchLength / _pinchLength - 1;

                    var distanceDelta = touchScale * distance;

                    _navapi.dollyFromPoint(distanceDelta, dollyTarget, this.getFitBounds());

                    var vview   = new THREE.Vector3();
                    var qrotate = new THREE.Quaternion();

                    var up = _navapi.getCameraUpVector();
                    var view = vview.copy(_camera.position).sub(_camera.target).normalize();
                    qrotate.setFromAxisAngle( view, _deltaRoll * 1.2 );
                    up.applyQuaternion( qrotate );
                    if (!_navapi.getIs2D()) 
                        _navapi.setCameraUpVector(up);

                    _prevPinchLength = _pinchLength;
                    _prevPinchScale = _pinchScale;
                    _trackingDistance = distance + distanceDelta;
                    break;
            }
            updatePivot = true;
        }
        this.stepMotionDelta(_motionDelta, (_activeMode !== "pan" && _activeMode !== 'dollypan'));

        // If a wheel event triggered this we've now handled it,
        if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
        {
            this.interactionEnd(kWheel);
            wheelEnded = true;
            updatePivot = true;
        }

        // Show pivot if a clutch key is being held.
        if( (_modifierState.SHIFT || _modifierState.ALT) && (_names.indexOf(viewerApi.getActiveNavigationTool()) !== -1)) {
            updatePivot = true;
        }

        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);

                this.utilities.removeTemporaryPivot();
            }
            this.utilities.autocam.endInteraction();
            _activeTrigger = kNone;
            if( _activeModeLocked )
                this.controller.setIsLocked(false);
            _activeModeLocked = false;
            _autoCamStartXY = null;
            _touchType = null;
        }
        if( updatePivot )
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (_activeTrigger <= kWheel));
        else
            this.utilities.pivotUpdate();

        return _camera.dirty;
    };


    this.checkInteractionMode = function()
    {
        var newMode = this.getTriggeredMode();

        if( newMode !== _activeMode )
        {
			_activeMode = newMode;

            if( (_activeMode === "pan" && _activeTrigger > kWheel) || (_activeMode === "dollypan") )
                this.initTracking(_startXYZ.x, _startXYZ.y);
        }
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;

            if( trigger > kWheel )
            {
                if( _activeMode === "pan" )
                    this.initTracking(_startXYZ.x, _startXYZ.y);

                if( _activeMode === "orbit" )
                    this.initOrbit();
            }
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (trigger === kWheel));

            if( this.utilities.autocam )
            {
                this.utilities.autocam.sync(_camera);
                this.utilities.autocam.startInteraction(_startXY.x, _startXY.y);
                _autoCamStartXY = _startXY.clone();
            }
        }
    };

    this.interactionCheck = function()
    {
        // Restart keyboard interaction if certain keys are still down:
        //
        if( _autoMove[0]
         || _autoMove[1]
         || _autoMove[2]
         || _autoMove[3]
         || _autoMove[4]
         || _autoMove[5]
         || _modifierState.SHIFT
         || _modifierState.CONTROL
         || _modifierState.ALT
         || _modifierState.SPACE ) this.interactionStart(kKeyboard, true);
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".


    this.handleWheelInput = function(delta)
    {
        if( this.isDragging )
            return false;

        //Auto-update the center of zoom (pivot) to center on the cursor
        //on mouse wheel.
        if( _navapi.getIs2D() ) {
            // TODO: Perhaps this should be in the update method
            // to avoid unnecessary calls.
            var viewport = _navapi.getScreenViewport();
            var point = viewerImpl.intersectGround(_lastMouseX + viewport.width, _lastMouseY + viewport.height);
            this.utilities.setPivotPoint( point, true, true );
        }

        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.resetKeys = function()
    {
        // Turn off any auto motion that may be stuck due to lost focus
        this.autoMove(-1, false);

        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
        _modifierState.SPACE = 0;
    };

    this.autoMove = function(index, state)
    {
        if( !state || !this.isDragging )
        {
            if( index < 0 )
                _autoMove[0] =
                _autoMove[1] =
                _autoMove[2] =
                _autoMove[3] =
                _autoMove[4] =
                _autoMove[5] = state;
            else
                _autoMove[index] = state;

            if( !state )
                this.interactionEnd(kKeyboard);

            this.interactionCheck();
        }
    };

    this.updateModifierState = function( event )
    {
        /* See SPK-930 and SPK-928
        _modifierState.CONTROL = ((isMac && event.metaKey) || (!isMac && event.ctrlKey)) ? 1 : 0;
         */
        _modifierState.CONTROL = ((isMac && event.metaKey) || event.ctrlKey) ? 1 : 0;
        _modifierState.SHIFT = (event.shiftKey) ? 1 : 0;
        _modifierState.ALT = (event.altKey) ? 1 : 0;
    };

    this.handleKeyDown = function( event, keyCode )
    {
        this.updateModifierState(event);
        var handled = false;

        switch( keyCode )
        {
            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.LEFT:     this.autoMove(0, true); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, true); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, true); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, true); handled = true; break;
            case _keys.UP:       this.autoMove(4, true); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, true); handled = true; break;

            default:
                return false;
        }
        if( !this.isDragging )
            this.interactionStart(kKeyboard);

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        this.updateModifierState(event);
        var handled = false;

        switch( keyCode )
        {
            case _keys.LEFT:     this.autoMove(0, false); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, false); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, false); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, false); handled = true; break;
            case _keys.UP:       this.autoMove(4, false); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, false); handled = true; break;

            default:
                return false;
        }
        if( handled )
        {
            this.interactionEnd(kKeyboard);

            if( !_interactionActive )
                this.interactionCheck();
        }
        return handled;
    };

    function endsWith(str, suffix)
    {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function fingerSeparation(event)
    {
        var dx = event.pointers[1].clientX - event.pointers[0].clientX;
        var dy = event.pointers[1].clientY - event.pointers[0].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    this.handleDollyPan = function(event)
    {
        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        var viewport = _navapi.getScreenViewport();
        _moveXY.x  = _lastMouseX;
        _moveXY.y  = _lastMouseY;
        _moveXYZ.x = _moveXY.x / viewport.width;
        _moveXYZ.y = _moveXY.y / viewport.height;

        _pinchLength = fingerSeparation(event);

        var roll = THREE.Math.degToRad(event.rotation);
        _deltaRoll = roll - _prevRoll;
        if (Math.abs(_deltaRoll) > 1.0)
            _deltaRoll = 0;
        _prevRoll = roll;

        if( endsWith(event.type, "start") )
        {
            _prevPinchLength = _pinchLength;
            _prevPinchScale = 1.0;
            _deltaRoll = 0;
            _prevRoll = roll;
        }

        _pinchScale = event.scale;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                if( _touchType !== "drag" ) {
                    this.handleButtonDown(event, 0);                    
                    _touchType = "drag";
                }
                return this.handleMouseMove(event);

            case "dragend":
                // We seem to often get a lone dragend after a multi-touch.
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;


            case "panstart":
                _touchType = "pan";
                this.handlePanStart(event);
                this.handleDollyPan(event);
                return true;

            case "panmove":
                if( _touchType !== "pan" ) {
                    _touchType = "pan";
                    this.handlePanStart(event);
                }
                return this.handleDollyPan(event);

            case "panend":
                if( _touchType === "pan" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;


            case "pinchstart":
                this.isDragging = true;
                _touchType = "pinch";

                _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
                _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

                _touchStartXY.set(event.canvasX, event.canvasY);
                _startXY.set(event.canvasX, event.canvasY);
                
                _activeModeLocked = false;
                this.interactionStart(kTouch);
                this.handleDollyPan(event);
                return true;

            case "pinchmove":
                return (_touchType === "pinch") ? this.handleDollyPan(event) : false;

            case "pinchend":
                if( _touchType === "pinch" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;
        }
        return false
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);

        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _startXY.set(event.canvasX, event.canvasY);
        _moveXYZ.copy(_startXYZ);
        _moveXY.copy(_startXY);

        _rotateStart.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));
        _rotateEnd.copy(_rotateStart);

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        this.isDragging = true;

        this.interactionStart(button);
        return true;
    };

    this.handlePanStart = function (event) {
        this.isDragging = true;

        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _touchStartXY.set(event.canvasX, event.canvasY);
        _startXY.set(event.canvasX, event.canvasY);

        this.interactionStart(kTouch);
        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);

        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);

        _rotateEnd.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));
        _rotateStart.copy(_rotateEnd);

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        this.interactionEnd(button);

        this.isDragging = false;
        return true;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);

        //Handles non-dragging mouse move over the canvas.
        //Updates the last known mouse point for
        //using during mouse wheel (as zoom center) and
        //will eventually be needed for mouse over highlighting
        if(!this.isDragging )
        {
            _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            _startXY.set(event.canvasX, event.canvasY);
            _moveXYZ.x = _startXYZ.x;
            _moveXYZ.y = _startXYZ.y;
            _moveXY.copy(_startXY);

            _lastMouseX = event.canvasX;
            _lastMouseY = event.canvasY;

            //mouse over highlighting
            // TODO: Perhaps this should be in the update method
            // to avoid unnecessary calls.
            if(event.target === viewerImpl.canvas)
            {
                viewerImpl.rolloverObject(_lastMouseX, _lastMouseY);
            }

            return false;
        }
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);

        _rotateEnd.copy(getMouseProjectionOnBall(event.canvasX, event.canvasY));

        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        return true;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        this.interactionEnd(_activeTrigger);
    };

    viewerApi.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
        _this.handleBlur(event);
    });
};


(function() {
	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

avp.init_UnifiedCamera = function(THREE) {

if (typeof av.UnifiedCamera !== "undefined")
    return;

var UnifiedCamera = function ( clientWidth, clientHeight)
{
    THREE.Camera.call( this );

    this.fov = 45;
    this.near = 0.1;
    this.far = 100000;
    this.aspect = clientWidth / clientHeight;

    this.left = -clientWidth / 2;
    this.right = clientWidth / 2;
    this.top = clientHeight / 2;
    this.bottom = -clientHeight / 2;
    this.clientWidth = clientWidth;
    this.clientHeight = clientHeight;

    this.target  = new THREE.Vector3(0, 0, -1);
    this.worldup = new THREE.Vector3(0, 1, 0);

    this.orthographicCamera = new THREE.OrthographicCamera( this.left, this.right, this.top, this.bottom,  this.near, this.far );
    this.perspectiveCamera = new THREE.PerspectiveCamera( this.fov, this.aspect, this.near, this.far);

    this.zoom = 1;

    this.toPerspective();
};

//Constant FOV used to make math right for Ortho cameras.
UnifiedCamera.ORTHO_FOV = (2 * Math.atan(0.5)) * 180.0 / Math.PI;

UnifiedCamera.prototype = Object.create( THREE.Camera.prototype );

UnifiedCamera.prototype.clone = function ()
{
	var camera = new UnifiedCamera(this.right * 2.0, this.top * 2.0);

	THREE.Camera.prototype.clone.call( this, camera );

    camera.position.copy(this.position);
    camera.up.copy(this.up);
    if( this.target )
        camera.target = this.target.clone();
    if( this.worldup )
        camera.worldup = this.worldup.clone();
    if( this.worldUpTransform )
        camera.worldUpTransform = this.worldUpTransform.clone();

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;
    camera.fov = this.fov;
    camera.aspect = this.aspect;
    camera.zoom = this.zoom;

    camera.isPerspective = this.isPerspective;

    this.updateProjectionMatrix();

	return camera;
};

UnifiedCamera.prototype.__computeFovPosition = function(fov)
{
    if( Math.abs(this.fov - fov)  <= 0.0001 )
        return this.position.clone();

    var eye = this.target.clone().sub( this.position );

    var oldFOV = THREE.Math.degToRad(this.fov);
    var newFOV = THREE.Math.degToRad(fov);

    var distance = eye.length() * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
    var offset = eye.normalize().multiplyScalar( -distance );

    return this.target.clone().add(offset);
};

UnifiedCamera.prototype.toPerspective = function()
{
    // Switches to the Perspective Camera

    if( !this.isPerspective && this.saveFov ) {
        this.position.copy(this.__computeFovPosition(this.saveFov));
        this.fov = this.saveFov;
    }

    this.perspectiveCamera.aspect = this.aspect;
    this.perspectiveCamera.near = this.near;
    this.perspectiveCamera.far = this.far;

    this.perspectiveCamera.fov = this.fov / this.zoom ;
    this.perspectiveCamera.updateProjectionMatrix();

    this.projectionMatrix = this.perspectiveCamera.projectionMatrix;

    this.isPerspective = true;
};

UnifiedCamera.prototype.toOrthographic = function()
{
    if( this.isPerspective ) {
        this.saveFov = this.fov;
        var newFov = UnifiedCamera.ORTHO_FOV;
        this.position.copy(this.__computeFovPosition(newFov));
        this.fov = newFov;
    }

    this.orthoScale = this.target.clone().sub(this.position).length();

    var halfHeight = this.orthoScale * 0.5;
    var halfWidth = halfHeight * this.aspect;

    this.left   = this.orthographicCamera.left   = -halfWidth;
    this.right  = this.orthographicCamera.right  =  halfWidth;
    this.top    = this.orthographicCamera.top    =  halfHeight;
    this.bottom = this.orthographicCamera.bottom = -halfHeight;

    this.orthographicCamera.near = this.near;
    this.orthographicCamera.far = this.far;

    this.orthographicCamera.updateProjectionMatrix();

    this.projectionMatrix = this.orthographicCamera.projectionMatrix;

    this.isPerspective = false;
};

UnifiedCamera.prototype.updateProjectionMatrix = function()
{
    if ( this.isPerspective ) {
        this.toPerspective();
    } else {
        this.toOrthographic();
    }
};

UnifiedCamera.prototype.setSize = function( width, height )
{
    this.aspect = width / height;
    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;

};


UnifiedCamera.prototype.setFov = function( fov )
{
    this.fov = fov;
    this.updateProjectionMatrix();
};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
UnifiedCamera.prototype.setLens = function ( focalLength, frameHeight )
{
    if ( frameHeight === undefined ) frameHeight = 24;

    var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

    this.setFov( fov );

    return fov;
};


UnifiedCamera.prototype.getCameraChangedEvent = function() {
    return {type: av.CAMERA_CHANGE_EVENT, camera: this};
};

av.UnifiedCamera = UnifiedCamera;

}

})();

(function() {

	'use strict';

var av = Autodesk.Viewing,
    avp = av.Private;

/**
 * This is the core interface to camera controls and navigation. 
 * The active navigation object can normally be obtained from the "navigation" property of the Viewer3D instance. 
 * Client implementations should not normally instantiate this class directly.
 * 
 *  @class
 *  @memberof Autodesk.Viewing
 *  @alias Autodesk.Viewing.Navigation
 *  @category Core
 *  @param {THREE.Camera} camera - The main camera object used to render the scene.
 *  @constructor
 */
function Navigation(camera)
{
    var kMinFOV  = 6.88; // 200 mm
    var kMaxFOV  = 100;  // 10 mm
    var kEpsilon = 0.000001;
    var kDefaultMinDistance = 0.00001;

    this.__options = {
        dollyToPivot: false,
        orbitPastPoles: true,
        reverseDolly: false,
        reverseHorizontalLook: false,
        reverseVerticalLook: false,
        useLeftHandedInput: false,
        usePivotAlways: false,
        lockNavigation: false
    };

    // which actions are allowed when navigation is locked
    this.__lockSettings = {
        orbit: false,
        pan: false,
        zoom: false,
        roll: false,
        fov: false,
        gotoview: false,
        walk: false
    };

    // Change these constants to alter the margin ratios (think, percentages/100).
    // The margins are how much to add above and below. For example, setting the
    // margin to 25% (0.25) would give a margin of 25% above, 50% in the middle for
    // content, and 25% below. This value should never be >= 0.50, as that would
    // leave no area for the content to display.
    // The offsets are how much to shift the view. For example, shifting 50% (0.50)
    // vertically would move the displayed area such that only the bottom half of
    // the drawing area would be seen.
    this.FIT_TO_VIEW_VERTICAL_MARGIN = 0.05;
    this.FIT_TO_VIEW_VERTICAL_OFFSET = 0.00;
    this.FIT_TO_VIEW_HORIZONTAL_MARGIN = 0.05;
    this.FIT_TO_VIEW_HORIZONTAL_OFFSET = 0.00;

    this.__pivotIsSetFlag = false;
    this.__fitToViewRequested = false;
    this.__homeViewRequested = false;
    this.__transitionActive = false;
    this.__destinationView = null;
    this.__is2D = false;
    this.__isTouchDevice = false;
    this.__kEpsilon = kEpsilon;
    this.__minDistance = kDefaultMinDistance;

    // Only for 2D: Optional constraints to keep data within the view.
    var _maxViewRegion    = undefined;  // {THREE.Box3} restrict zoom-out/pan to keep it well visible (only xy used)
    var _maxPixelsPerUnit = undefined;  // Restrict zoom-in so that a world-space unit does not exceed a given
                                        // number of pixels on screen.
    var _maxDistanceFactor = 2.0;
    var _minDistanceFactor = 200.0;

    var _camera = null;

    var _viewport = { left: 0, top: 0, width: 1, height: 1 };

    this.uninitialize = function()
    {
        this.setCamera(null);
    };

    /**
     * Set or unset the current camera used for navigation. Normally set via the constructor.
     * The camera should be of type Autodesk.Viewing.UnifiedCamera.
     *  @param {Autodesk.Viewing.UnifiedCamera} camera - the current camera object.
     */
    this.setCamera = function(camera)
    {
        if( camera !== _camera )
        {
            _camera = camera;
            if( camera )
            {
                if( !camera.hasOwnProperty("target") )
                    camera.target = new THREE.Vector3(0, 0, 0);

                if( !camera.hasOwnProperty("pivot") )
                    camera.pivot = new THREE.Vector3(0, 0, 0);

                camera.worldup = camera.up.clone();  // Initial assumption!!
                camera.dirty = true;
            }
        }
    };

    /**
     *  @returns {THREE.Camera} - the current camera object.
     */
    this.getCamera = function()
    {
        return _camera;
    };

    /**
     * Set the current canvas viewport in screen coordinates.
     * Invoked internally on canvas resize.
     *  @param {Object} viewport - Rectangle with properties left, top, width, height.
     */
    this.setScreenViewport = function( viewport )
    {
        _viewport = viewport;
    };

    /**
     * Get the current canvas viewport in screen coordinates.
     *  @returns {Object} with properties left, top, width, height.
     */
    this.getScreenViewport = function()
    {
        return _viewport;
    };

    /**
     * @private
     */
    this.__setUp = function(up)
    {
        if( up && _camera )
        {
            var upCheck = up.clone().normalize();
            var diff = upCheck.sub( _camera.worldup );
            if( diff.lengthSq() !== 0.0 )
            {
                _camera.worldup.copy(up).normalize();
                _camera.dirty = true;
                return true;
            }
        }
        return false;
    };

    /**
     * @private
     */
    this.__getUp = function()
    {
        return _camera ? _camera.worldup : new THREE.Vector3(0, 1, 0);
    };

    /**
     * Sets the cameras position and view direction.
     *  @param {THREE.Vector3} position - the new position for the camera in world space.
     *  @param {THREE.Vector3} target - the point in world space that the camera should look towards.
     */
    this.setView = function( position, target )
    {
        if( _camera && position && target )
        {
            _camera.position.copy(position);
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     * Orient the camera's up direction with the current world up direction
     */
    this.orientCameraUp = function()
    {
        if( _camera && this.isActionEnabled('roll') )
        {
            _camera.up.copy(this.getAlignedUpVector()); // New up aligned with world up
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the pivot point for orbit navigation.
     */
    this.getPivotPoint = function()
    {
        return _camera ? _camera.pivot.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Sets the Vector3 world space position of the pivot point for orbit navigation.
     *  @param {THREE.Vector3} pivot - the new pivot position.
     */
    this.setPivotPoint = function( pivot )
    {
        if( _camera && pivot )
        {
            _camera.pivot.copy(pivot);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the camera.
     */
    this.getPosition = function()
    {
        return _camera ? _camera.position.clone() : new THREE.Vector3(0, 0, 1);
    };

    /**
     * Sets the Vector3 world space position of camera.
     *  @param {THREE.Vector3} pos - the new camera position.
     */
    this.setPosition = function( pos )
    {
        if( _camera && pos )
        {
            _camera.position.copy(pos);
            _camera.dirty = true;
        }
    };

    /**
     * Sets the Vector3 world space position towards which the camera should be pointing.
     *  @param {THREE.Vector3} target - the new camera look at point.
     */
    this.setTarget = function(target)
    {
        if( _camera && target )
        {
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position towards which the camera is pointing.
     */
    this.getTarget = function()
    {
        return _camera ? _camera.target.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Get the current camera view vector. This vector is not normalized and its
     * length is the distance between the camera position and the camera look at point.
     *  @returns {THREE.Vector3} the current camera view vector in world space.
     */
    this.getEyeVector = function ()
    {
        return _camera ? _camera.target.clone().sub( _camera.position ) : new THREE.Vector3(0, 0, -1);
    };

    /**
     * Get a vector from the camera location to the center of the input bounding box.
     * @param {THREE.Box3} bounds - Bounding box.
     * @returns {THREE.Vector3} - The vector from the camera location to the center of the input bounds.
     */
    this.getEyeToCenterOfBoundsVec = function (bounds)
    {
        return _camera ? bounds.center().sub(_camera.position) : new THREE.Vector3(0, 0, -1);
    };

    /**
     *  @returns {number} the minimum allowed vertical field of view in degrees.
     */
    this.getFovMin = function()
    {
        return kMinFOV;
    };

    /**
     *  @returns {number} the maximum allowed vertical field of view in degrees.
     */
    this.getFovMax = function()
    {
        return kMaxFOV;
    };

    /**
     * Returns true if the point is visible.
     *
     * @param {THREE.Vector3} point - The point in world coordinates.
     *
     * @returns {boolean} - True if the point is within the camera's frustum.
     */
    this.isPointVisible = function(point)
    {
        var cameraFrustum = new THREE.Frustum().setFromMatrix(_camera.projectionMatrix.clone().multiply(_camera.matrixWorldInverse));
        return cameraFrustum.containsPoint(point);
    };

    /**
     * Set the current vertical field of view.
     *  @param {number} fov - the new field of view in degrees (value is clamped to the minimum and maximum field of view values).
     *  @param {boolean} adjustPosition - If true, the camera position will be modified to keep either the world space area
     *                                    of the view at the pivot point unchanged (if it is set and visible) or the world
     *                                    space area of view at the camera look at point unchanged.
     */
    this.setVerticalFov = function(fov, adjustPosition)
    {
        // If camera is not perspective don't allow fov change
        if( _camera && !_camera.isPerspective)
            return;

        if( fov < kMinFOV ) fov = kMinFOV;
        else if( fov > kMaxFOV ) fov = kMaxFOV;

        if( _camera && this.isActionEnabled('fov') )
        {
            if( Math.abs(_camera.fov - fov)  <= kEpsilon )
                return;

            if( adjustPosition )
            {
                var usePivot = this.__pivotIsSetFlag && this.isPointVisible(this.getPivotPoint());

                var pos = this.getPosition();
                var eye = this.getEyeVector();

                var oldFOV = THREE.Math.degToRad(_camera.fov);
                var newFOV = THREE.Math.degToRad(fov);

                var oldDistance = usePivot ? this.getPivotPlaneDistance() : eye.length();
                var newDistance = oldDistance * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);

                var delta = eye.normalize().multiplyScalar(oldDistance - newDistance);
                this.setPosition(pos.add(delta));

                if (usePivot) {
                    this.setTarget(this.getTarget().add(delta));
                }
            }
            _camera.setFov(fov);
            _camera.dirty = true;
        }
    };

    /**
     * Compute camera position and look at point which will fit the given bounding box in the view frustum at the given field of view angle.
     *  @param {THREE.Vector3} oldpos - existing camera position
     *  @param {THREE.Vector3} oldcoi - existing camera look at point
     *  @param {number} fov - field of view (in degrees) to use for fit calculation in degrees
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @param {number} aspect - optional aspect ratio of window, horizontal/vertical
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.computeFit = function(oldpos, oldcoi, fov, bounds, aspect)
    {
        if( !bounds || bounds.empty() )
            return {position: oldpos, target: oldcoi};

        aspect = (aspect === undefined) ? 1.0 : aspect;

        var coi  = bounds.center();
        var size = bounds.size();

        var eye = oldpos.clone().sub(oldcoi).normalize();

        var fovHalfWorldWidth = Math.tan(THREE.Math.degToRad(fov * 0.5));
        var fitToViewDistance = 0.0;
        // make sure up is orthogonal to eye view direction
        var up = this.computeOrthogonalUp(oldpos, oldcoi);
        var right = eye.clone().cross(up).normalize();

        var v1 = new THREE.Vector3();
        // if size.z is 0.0 (normal for 2D), we only go to 4, as we need only the four corners of a square.
        var corners = (size.z === 0.0) ? 4 : 8;
        for (var i = 0; i < corners; i++) {
            // get the Nth corner of the bounding box, centered around its center
            v1.set(
                ((i&0x1)==0) ? -0.5*size.x : 0.5*size.x,
                ((i&0x2)==0) ? -0.5*size.y : 0.5*size.y,
                ((i&0x4)==0) ? -0.5*size.z : 0.5*size.z
            );

            // Fit each bounds and find that distance, also depending on the aspect ratio.
            // The eyeDot distance brings our 2d test plane to where the corner is located
            // along the z axis, so is indeed a signed distance.
            // The other two distances, computed with up and right vectors, are positive,
            // which is why Math.abs is used.

            // Dot product with the eye vector is how far to move the 2D viewing plane
            // to contain the point. Matters only for perspective camera.
            var eyeDot = 0.0;
            if( camera.isPerspective ) {
                eyeDot = v1.dot(eye);
            }
            var upDot = Math.abs(v1.dot(up));
            var rightDot = Math.abs(v1.dot(right));

            // vertical distance used to compute how far back to move the camera
            var testDistance = eyeDot +
                (1.0 + ( 2.0 * this.FIT_TO_VIEW_VERTICAL_MARGIN / ( 1.0 - 2.0 * this.FIT_TO_VIEW_VERTICAL_MARGIN ))) *
                upDot / fovHalfWorldWidth;
            if ( fitToViewDistance < testDistance )
                fitToViewDistance = testDistance;

            // horizontal distance used to compute how far back to move the camera
            testDistance = eyeDot +
                (1.0 + ( 2.0 * this.FIT_TO_VIEW_HORIZONTAL_MARGIN / ( 1.0 - 2.0 * this.FIT_TO_VIEW_HORIZONTAL_MARGIN ))) *
                rightDot / (aspect * fovHalfWorldWidth);
            if ( fitToViewDistance < testDistance )
                fitToViewDistance = testDistance;
        }

        // adjust coi by vertical percentage, which keeps it centered above the view controls
        coi.add( up.multiplyScalar(-fitToViewDistance*this.FIT_TO_VIEW_VERTICAL_OFFSET));
        coi.add( right.multiplyScalar(fitToViewDistance*this.FIT_TO_VIEW_HORIZONTAL_OFFSET));

        eye.multiplyScalar( fitToViewDistance );

        var pos = coi.clone().add( eye );
        return {position: pos, target: coi};
    };

    /**
     * Compute a vector which is orthogonal to the given view and aligned with the world up direction.
     *  @param {THREE.Vector3} pos - view position
     *  @param {THREE.Vector3} coi - center of interest (view look at point)
     *  @returns {THREE.Vector3} up direction orthogonal to the given view
     */
    this.computeOrthogonalUp = function(pos, coi)
    {
        var worldUp = this.__getUp();
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    };

    /**
     * Causes the current camera position to be changed in order to fit the given bounds into the current view frustum.
     *  @param {boolean} immediate - if false the camera position will animate to the new location.
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @param {boolean} reorient - if true the camera up direction will be reoriented with the world up.
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.fitBounds = function(immediate, bounds, reorient)
    {
        var oldcoi = this.getTarget();
        var pos    = this.getPosition();

        if( !this.isActionEnabled('gotoview') || !bounds || bounds.empty() )
            return {position: pos, target: oldcoi};

        var fov = this.getVerticalFov();
        var fit = this.computeFit(pos, oldcoi, fov, bounds, _camera.aspect);
        var up  = reorient ? this.computeOrthogonalUp(pos, oldcoi) : _camera.up;

        if( immediate )
        {
            _camera.up.copy(up);
            this.setView(fit.position, fit.target);
        }
        else
        {
            this.setRequestTransitionWithUp( true, fit.position, fit.target, fov, up );
        }
        this.setPivotPoint(fit.target);
        this.setPivotSetFlag(true);

        return fit;
    };

    /**
     * Compute the minimum required distance to keep _maxViewRegion fully visible at once.
     * @param {THREE.Box3} bounds
     * @private
     */
    this.computeOverviewDistance = function(bounds) {
        if (this.__is2D) {
            var size       = bounds.size();
            var aspect     = _camera.aspect;

            // Restrict zoom-out, so that it stops if maxViewRegion fits into the canvas
            // For ortho-cameras, we have (see UnififiedCamera.toOrthographic)
            //  frustumHeight == orthoScale == distance
            //  frustumWidth                == distance * aspect
            // Therefore, the distances at which the x/y-extent of the model matches the canvas is:
            var maxDistX = size.x / aspect;
            var maxDistY = size.y;

            // allow enough zoom-out that neither x nor y is cropped
            return Math.max(maxDistX, maxDistY);
        }
        else {
            var fov = this.getVerticalFov();
            var size = bounds.size();
            var diameter = size.length();
            if( diameter === 0.0 )
                diameter = 2.0;

            if (_camera.isPerspective) {
                return (0.5 * diameter / Math.tan(THREE.Math.degToRad(fov * 0.5)));
            } else {
                return diameter;
            }
        }
    };

    /**
     * Helper function used to for dolly operations. 
     * It adjusts the given scaleFactor if needed to preserve zoom-in/out restrictions.
     * @param {Number} scaleFactor - Distance scale factor going to be applied by a dolly interaction
     * @param {THREE.Box3} bounds - bounding box to fit
     * @returns {Number} adjustedScaleFactor
     * @private
     */
    this.applyDollyConstraint = function(scaleFactor, bounds) {

        // default: just return identity if no constraint is active
        if (!(_maxViewRegion || _maxPixelsPerUnit || _maxDistanceFactor)) {
            return scaleFactor;
        }

        var adjustedScaleFactor = scaleFactor;


        // restrict max distance, only if zooming out.
        if ((_maxViewRegion || (_maxDistanceFactor && bounds)) && scaleFactor > 1) {
            // For orthographic cameras, the length of the eye vector is what we need
            // to limit, not the distance to the bounds, which works for perpsective cameras
            var viewVec = _camera.isPerspective ? this.getEyeToCenterOfBoundsVec(bounds) : this.getEyeVector();

            var maxDist;
            if(_maxViewRegion)
                // stop zoom-out if the whole viewRegion becomes smaller than half of the screen
                maxDist = _maxDistanceFactor * this.computeOverviewDistance(_maxViewRegion);
            else
                // stop zoom-out if the model's bounding box becomes smaller than half (_maxDistanceFactor) of the screen
                maxDist = _maxDistanceFactor * this.computeOverviewDistance(bounds);

            // restrict scale-factor, so that viewVec.z doesn't exceed maxDist
            var maxScaleFactor = Math.abs(maxDist / viewVec.length());


            // after changing canvas width, the maxDist constraint may be temporarily broken.
            // we don't want to jump the camera back in this case - only avoid zooming out even more.
            // Therefore, we never force a scaleFactor below 1.0 (=no change).
            maxScaleFactor = Math.max(maxScaleFactor, 1.0);

            // apply zoom-out restriction
            adjustedScaleFactor = Math.min(adjustedScaleFactor, maxScaleFactor);
        }


        // restrict zoom-in, so that a single world-space unit does not exceed maxPixelsPerUnit.
        if ((_maxPixelsPerUnit || (_minDistanceFactor && bounds)) && this.__is2D) {

            // At a given distance d, the world-space size to match the canvas height is the frustum height.
            // Therefore, the pixel size of a world-space unit (ppu) is:
            //  ppu = canvasHeight / frustumHeight = canvasHeight / distance
            // Therefore, the distance at which we reach ppu == maxPixelsPerUnit is:
            var minDist;
            if(_maxPixelsPerUnit)
                minDist = _camera.clientHeight / _maxPixelsPerUnit;
            else
                minDist = this.computeOverviewDistance(bounds) / _minDistanceFactor;

            // restrict scale-factor, so that viewVec.z doesn't fall below minDist
            var viewVec = this.getEyeVector();
            var minScaleFactor = minDist / -viewVec.z;

            // Just restrict movement, but don't let the camera jump (see maxScaleFactor comment above)
            minScaleFactor = Math.min(minScaleFactor, 1.0);

            // apply zoom-in restriction
            adjustedScaleFactor = Math.max(adjustedScaleFactor, minScaleFactor);
        }

        return adjustedScaleFactor;
    };

    /**
     * If a _maxViewRegion is set (only for 2D mode), this function adjusts
     * the given panning offset, so that the camera keeps within the given view region (in xy).
     * @param {THREE.Vector3} offsetVector to be added by panning movement
     * @private
     */
    this.applyPanningConstraint2D = function(inOutOffset) {

        // default: just do nothing unless we are using 2D with _maxViewRegion constraint
        if (!this.__is2D || !_maxViewRegion) {
            return;
        }

        // compute new camera pos after offset + constraint
        var newPosX = (_camera.position.x + inOutOffset.x);
        var newPosY = (_camera.position.y + inOutOffset.y);
        newPosX = THREE.Math.clamp(newPosX, _maxViewRegion.min.x, _maxViewRegion.max.x);
        newPosY = THREE.Math.clamp(newPosY, _maxViewRegion.min.y, _maxViewRegion.max.y);

        // compute resulting adjusted offset
        var offsetX = newPosX - _camera.position.x;
        var offsetY = newPosY - _camera.position.y;

        // We only want to restrict the panning movement, but don't jump suddenly
        // back if the camera is already outside. Therefore, we restrict
        // the adjusted offset to be within 0.0 (= no change) and the initial one.
        var offsetXMin = Math.min(inOutOffset.x, 0.0);
        var offsetYMin = Math.min(inOutOffset.y, 0.0);
        var offsetXMax = Math.max(inOutOffset.x, 0.0);
        var offsetYMax = Math.max(inOutOffset.y, 0.0);
        offsetX = THREE.Math.clamp(offsetX, offsetXMin, offsetXMax);
        offsetY = THREE.Math.clamp(offsetY, offsetYMin, offsetYMax);

        // replace offsetVector.xy by adjusted values
        inOutOffset.x = offsetX;
        inOutOffset.y = offsetY;
    };

    /**
     * Update the current camera projection matrix and orient the camera to the current look at point.
     * Invoked internally prior to rendering a new frame with the current camera.
     */
    this.updateCamera = function()
    {
        if( _camera )
        {
            _camera.updateProjectionMatrix();
            this.orient( _camera, _camera.target, _camera.position, _camera.up );
            _camera.dirty = false;
        }
    };

    this.setCamera(camera);

    /**
     * Applies zooming and panning restrictions when viewing 2D models. Invoke without
     * parameters to clear any previous setting.
     * 
     * @param {THREE.Box3} [viewRegion]   - in world space. If specified, navigation is restricted so that this region
     *                                      always spans >= half of the screen extent in x and y.
     * @param {Number}  [maxPixelPerUnit] - Restrict zoom-In, so that a single unit in world-space never
     *                                      exceeds maxPixelPerUnit on screen.
     */
    this.setConstraints2D = function(viewRegion, maxPixelPerUnit) {
        _maxViewRegion    = viewRegion;
        _maxPixelsPerUnit = maxPixelPerUnit;
    };
}

Navigation.prototype.constructor = Navigation;

/**
 * @private
 */
Navigation.prototype.setIs2D = function( state )
{
    this.__is2D = !!state;
};

/**
 * @private
 */
Navigation.prototype.getIs2D = function()
{
    return this.__is2D;
};

/**
 * @private
 */
Navigation.prototype.setIsTouchDevice = function( state )
{
    this.__isTouchDevice = !!state;
};

/**
 * @private
 */
Navigation.prototype.getIsTouchDevice = function()
{
    return this.__isTouchDevice;
};

/**
 * Rotate the given object so that its negative Z axis is directed towards the given point in world space. 
 * Used internally to orient the camera towards the target look at point. 
 * This is a modified version of THREE.Object3D.lookAt method that uses different solution for the singular 
 * case when (view X up) == 0.
 *  @param {THREE.Object3D} object - the object to be oriented
 *  @param {THREE.Vector3} target - the world space point to orient towards
 *  @param {THREE.Vector3} from - the world space position of the object being rotated
 *  @param {THREE.Vector3} up - the direction to align the objects Y axis with
 */
Navigation.prototype.orient = function()
{
    var m1;
    var x;
    var y;
    var z;

    function init_three() {
        if (m1)
            return;

        m1 = new THREE.Matrix4();
        x = new THREE.Vector3();
        y = new THREE.Vector3();
        z = new THREE.Vector3();
    }

    return function ( object, target, from, up )
    {
        init_three();

        var te = m1.elements;

        z.subVectors( from, target ).normalize();
        if ( z.lengthSq() === 0 ) {
            z.z = 1;
        }
        x.crossVectors( up, z ).normalize();
        if ( x.lengthSq() === 0 ) {
            // If Z is up then cross with Y to get X
            // otherwize cross with Z to get X.
            if( up.z > up.y )
                z.y -= 0.0001;
            else
                z.z += 0.0001;

            x.crossVectors( up, z ).normalize();
        }
        y.crossVectors( z, x );

        te[0] = x.x; te[4] = y.x; te[8] = z.x;
        te[1] = x.y; te[5] = y.y; te[9] = z.y;
        te[2] = x.z; te[6] = y.z; te[10] = z.z;

        object.setRotationFromMatrix( m1 );
    };
}();

/**
 * Convert a vertical field of view angle in degrees to a 35mm camera focal length value.
 *  @param {number} fov - vertical field of view in degrees
 *  @returns {number} focal length in millimeters
 */
Navigation.prototype.fov2fl = function ( fov )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a vertical field-of-view, return the focal length in millimeters
    // that it corresponds to in a 35mm film camera.
    var rads = THREE.Math.degToRad(fov);
    if (rads <= 0.0)
        rads = 0.0001;
    return Math.round( k35mmVerticalCameraBackSize / Math.tan(rads * 0.5) );
};

/**
 * Convert a 35mm camera focal length value to a vertical field of view angle in degrees.
 *  @param {number} fl - focal length in millimeters
 *  @returns {number} vertical field of view in degrees
 */
Navigation.prototype.fl2fov = function ( fl )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a focal length, return the vertical field of view that
    // this would correspond to in a 35mm camera.
    if (fl <= 0)
        fl = 0.0001;

    var rads = 2.0 * Math.atan(k35mmVerticalCameraBackSize / fl);
    return THREE.Math.radToDeg(rads);
};

/**
 * Set the up direction for the camera. The given vector should be orthogonal to the current view direction.
 *  @method
 *  @param {THREE.Vector3} up - the new up direction vector
 */
Navigation.prototype.setCameraUpVector = function(up)
{
    if( this.isActionEnabled('roll') )
    {
        var camera = this.getCamera();
        camera.up.copy(up);
        camera.dirty = true;
    }
};

/**
 * Get the world space vector which is the current cameras up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Navigation.prototype.getCameraUpVector = function()
{
    var right = this.getCameraRightVector(false);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the orthogonal to the view direction and aligned with the world up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Navigation.prototype.getAlignedUpVector = function()
{
    var right = this.getCameraRightVector(true);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the right side direction of the current camera.
 *  @method
 *  @param {boolean} worldAligned - if true get the right vector aligned with the world up, otherwise use the current camera's up direction.
 *  @returns {THREE.Vector3} the current camera right direction, orthogonal to view and up (normalized)
 */
Navigation.prototype.getCameraRightVector = function(worldAligned)
{
    var right = new THREE.Vector3();
    var up  = worldAligned ? this.getWorldUpVector() : this.getCamera().up;
    var eye = this.getEyeVector();
    right.crossVectors(eye, up);
    if( right.lengthSq() === 0 )
    {
        // If eye and up are collinear, choose vector:
        // If the eye direction is mostly along the y axis, choose +Z as up, else choose +Y as up.
        // If they match (e.g., both are zero), pick +Z, the default for maps and most mechanical.
        if( Math.abs(eye.z) >= Math.abs(eye.y) )
            up.set(0,1,0);
        else
            up.set(0,0,1);

        right.crossVectors(eye, up);
    }
    return right.normalize();
};

/**
 * Change the current world up direction.
 *  @param {THREE.Vector3} up - the new world up direction
 *  @param {boolean} reorient - if true, make sure the camera up is oriented towards the world up direction.
 */
Navigation.prototype.setWorldUpVector = function(up, reorient)
{
    if( this.isActionEnabled('roll') )
    {
        this.__setUp(up);

        if( reorient )
            this.orientCameraUp();
    }
};

/**
 * Get the current world up direction.
 *  @returns {THREE.Vector3} the current world up direction (normalized)
 */
Navigation.prototype.getWorldUpVector = function()
{
    return this.__getUp().clone();
};

/**
 * Compute a world right direction based on the current world up direction. 
 * This will return the normalized cross product of the current up direction with one 
 * of the major axes to provide a usable world right direction.
 *  @method
 *  @returns {THREE.Vector3} the computed world right direction
 */
Navigation.prototype.getWorldRightVector = function()
{
    var right = new THREE.Vector3();
    right.copy(this.__getUp());

    if (Math.abs(right.z) <= Math.abs(right.y))
    {
        // Cross(Vertical, ZAxis)
        right.set(right.y, -right.x, 0);
    }
    else if (right.z >= 0)
    {
        // Cross(YAxis, Vertical)
        right.set(right.z, 0, -right.x);
    }
    else
    {
        // Cross(Vertical, YAxis)
        right.set(-right.z, 0, right.x);
    }
    return right.normalize();
};

/**
 *  @returns {number} the current camera vertical field of view in degrees
 */
Navigation.prototype.getVerticalFov = function()
{
    return this.getCamera().fov;
};

/**
 *  @returns {number} the current camera horizontal field of view in degrees
 */
Navigation.prototype.getHorizontalFov = function()
{
    var viewport = this.getScreenViewport();
    return this.getCamera().fov * (viewport.width / viewport.height);
};

/**
 *  @returns {number} the current camera focal length based on a 35mm camera lens model
 */
Navigation.prototype.getFocalLength = function()
{
    return this.fov2fl(this.getVerticalFov());
};

/**
 * Set the current cameras field of view using a 35mm camera focal length value
 *  @param {number} millimeters - focal length in millimeters
 *  @param {boolean} adjustPosition - If true, the camera position will be modified to keep either the world space area
 *                                    of the view at the pivot point unchanged (if it is set and visible) or the world
 *                                    space area of view at the camera look at point unchanged.
 */
Navigation.prototype.setFocalLength = function(millimeters, adjustPosition)
{
    this.setVerticalFov(this.fl2fov(millimeters), adjustPosition);
};

/**
 * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseZoomDirection = function( state )
{
    this.__options.reverseDolly = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseHorizontalLookDirection = function( state )
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.setReverseHorizontalLookDirection is not applicable to 2D");
        return;
    }

    this.__options.reverseHorizontalLookDirection = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for vertical look operations.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Navigation.prototype.setReverseVerticalLookDirection = function( state )
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.setReverseVerticalLookDirection is not applicable to 2D");
        return;
    }

    this.__options.reverseVerticalLookDirection = !!state;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default direction for camera dolly (zoom) operations.
 *  @returns {boolean} - value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseZoomDirection = function()
{
    return this.__options.reverseDolly;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default horizontal look direction
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseHorizontalLookDirection = function()
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.getReverseHorizontalLookDirection is not applicable to 2D");
        return false;
    }

    return this.__options.reverseHorizontalLookDirection;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default vertical look direction
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Navigation.prototype.getReverseVerticalLookDirection = function()
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.getReverseVerticalLookDirection is not applicable to 2D");
        return false;
    }

    return this.__options.reverseVerticalLookDirection;
};

/**
 * Set or unset a view navigation option to request the default direction for camera dolly (zoom) operations to be towards the camera pivot point. If unset the default direction would normally be towards the cursor position.
 *  @param {boolean} state - value of the option, true for towards the pivot, false for default
 */
Navigation.prototype.setZoomTowardsPivot = function( state )
{
    this.__options.dollyToPivot = !!state;
};

/**
 * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
 *  @returns {boolean} - value of the option, true for towards the pivot, false for default
 */
Navigation.prototype.getZoomTowardsPivot = function()
{
    return this.__options.dollyToPivot;
};

/**
 * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
 *
 * Not applicable to 2D.
 *
 *  @param {boolean} state - value of the option, true to allow orbiting past the poles.
 */
Navigation.prototype.setOrbitPastWorldPoles = function( state )
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.setOrbitPastWorldPoles is not applicable to 2D");
        return;
    }

    this.__options.orbitPastPoles = !!state;
};

/**
 * Get the state of the view navigation option that allows orbit controls to continue past the world up/down direction.
 *
 * Not applicable to 2D.
 *
 *  @returns {boolean} - value of the option, true if orbiting past the poles is allowed.
 */
Navigation.prototype.getOrbitPastWorldPoles = function()
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.orbitPastWorldPoles is not applicable to 2D");
        return false;
    }

    return this.__options.orbitPastPoles;
};

/**
 * Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
 *  @param {boolean} state - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
 */
Navigation.prototype.setUsePivotAlways = function( state )
{
    this.__options.usePivotAlways = !!state;
};

/**
 * Get the state of the view navigation option that requests full use of the pivot point.
 *  @returns {boolean} - value of the option, if the pivot should be used as the orbit origin.
 */
Navigation.prototype.getUsePivotAlways = function()
{
    return this.__options.usePivotAlways;
};

/**
 * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
 *  @param {boolean} state - value of the option, true to request reversal of mouse button assignments.
 */
Navigation.prototype.setUseLeftHandedInput = function( state )
{
    this.__options.useLeftHandedInput = !!state;
};

/**
 * Get the state of the view navigation option that requests mouse button reversal.
 *  @returns {boolean} - value of the option, true if reversal is requested.
 */
Navigation.prototype.getUseLeftHandedInput = function()
{
    return this.__options.useLeftHandedInput;
};

/**
 * Lock or unlock view modification operations.
 * For a more granular control of locked operations, see {@link setLockSettings}.
 *  @param {boolean} state - when true changes to the current camera parameters are not allowed.
 */
Navigation.prototype.setIsLocked = function( state )
{
    this.__options.lockNavigation = !!state;
};

/**
 * Get the state of the current view modification lock.
 * For a more granular control of locked operations, see {@link setLockSettings}.
 *  @returns {boolean} - true if view modifications are not currently allowed.
 */
Navigation.prototype.getIsLocked = function()
{
    return this.__options.lockNavigation;
};

/**
 * Set the availability of specific camera actions when navigation is locked using {@link setIsLocked}.
 *  @param {object} settings Map of <action>:<bool> pairs specifying whether the given camera
 *  action is *enabled* even when the navigation is locked.
 *  The configurable actions are 'orbit', 'pan', 'zoom', 'roll', 'fov', or 'gotoview'.
 *  By default, none of the camera actions are available when the navigation is locked.
 */
Navigation.prototype.setLockSettings = function(settings)
{
    for (var action in this.__lockSettings) {
        if (settings.hasOwnProperty(action)) {
            this.__lockSettings[action] = settings[action];
        }
    }
};

/**
 * Get the availability of specific camera actions when navigation is locked using {@link setIsLocked}.
 *  @returns {object} Map of <action>:<bool> pairs specifying whether the given camera
 *  action is *enabled* even when the navigation is locked.
 */
Navigation.prototype.getLockSettings = function()
{
    var settings = {};
    for (var action in this.__lockSettings) {
        settings[action] = this.__lockSettings[action];
    }
    return settings;
};

/**
 * Check the availability of a camera action.
 *  @param {string} action Camera action.
 *  @returns {boolean} True if the camera action is currently enabled.
 */
Navigation.prototype.isActionEnabled = function(action) {
    return !this.__options.lockNavigation || this.__lockSettings[action] === true;
};

/**
 * Set or unset a view navigation option which indicates that the pivot camera parameter is set and can be used for orbit and zoom controls.
 *  @param {boolean} state - value of the option. When not set orbit and zoom operations should occur at the look at position in the center of the current view.
 */
Navigation.prototype.setPivotSetFlag = function( state )
{
    this.__pivotIsSetFlag = !!state;
};

/**
 * Get the state of the view navigation option that indicates the pivot is set.
 *  @returns {boolean} - value of the option, true if pivot may be used.
 */
Navigation.prototype.getPivotSetFlag = function()
{
    return this.__pivotIsSetFlag;
};

/**
 * Issue a request to change the current cameras view position to fit the active model data into the current view frustum.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 */
Navigation.prototype.setRequestFitToView = function( state )
{
    if( this.isActionEnabled('gotoview') )
        this.__fitToViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera repositioning to fit the active model data. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Navigation.prototype.getRequestFitToView = function()
{
    return this.__fitToViewRequested;
};

/**
 * Issue a request to change the current cameras view to the current "home" view. The home view includes position, view direction, world up direction and field of view.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 */
Navigation.prototype.setRequestHomeView = function( state )
{
    if( this.isActionEnabled('gotoview') )
        this.__homeViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera change to the current "home" view. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Navigation.prototype.getRequestHomeView = function()
{
    return this.__homeViewRequested;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {boolean} reorient - set to true to recalculate up vector
 *  @param {THREE.Vector3} pivot - the new pivot point
 */
Navigation.prototype.setRequestTransition = function( state, pos, coi, fov, reorient, pivot )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: this.getCamera().up.clone(),
             worldUp: this.getWorldUpVector(),
            reorient: reorient,
               pivot: pivot ? pivot.clone() : coi.clone()
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters which inlude both the camera up direction and optionally the world up direction.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view.
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {THREE.Vector3} up -  use this as the target camera up direction
 *  @param {THREE.Vector3} worldUp - (optional) use this as the target world up direction
 *  @param {THREE.Vector3} pivot - the new pivot point
 */
Navigation.prototype.setRequestTransitionWithUp = function( state, pos, coi, fov, up, worldUp, pivot )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: up.clone(),
             worldUp: worldUp ? worldUp : this.getWorldUpVector(),
            reorient: false,
               pivot: pivot ? pivot.clone() : coi.clone()
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Get the state of the view navigation option requesting a camera transition to a new view.
 *  @returns {Object} - If a transition request is active, an object with properties "position" (Vector3), "coi" (Vector3), "fov" (Number), "up" (Vector3), "worldUp" (Vector3), "reorient" (boolean). Returns null when no transition is active.
 *  @see setRequestTransitionWithUp
 */
Navigation.prototype.getRequestTransition = function()
{
    return this.__destinationView;
};

/**
 * Set a status indicating that the current camera view is in a transitioning state.
 * Used internally to indicate that a transition is active.
 *  @param {boolean} state - value of the transtion status
 */
Navigation.prototype.setTransitionActive = function( state )
{
    this.__transitionActive = !!state;
};

/**
 *  Check the status of a view transition request.
 *  @returns {boolean} - value of the transtion status
 */
Navigation.prototype.getTransitionActive = function()
{
    return this.__transitionActive;
};

/**
 *  @param {number} atDistance - Distance from the camera at which to compute the view frustum size.
 *  @returns {THREE.Vector2} The size of the view frustum at this distance from the camera.
 */
Navigation.prototype.getWorldSize = function(atDistance)
{
    var viewport = this.getScreenViewport();
    var aspect = viewport.width / viewport.height;
    var worldHeight = 2.0 * atDistance * Math.tan(THREE.Math.degToRad(this.getCamera().fov * 0.5));
    var worldWidth  = worldHeight * aspect;

    return new THREE.Vector2(worldWidth, worldHeight);
};

/**
 *  Get a world point from normalized screen coordinates by projecting to the plane at the pivot point.
 *  @param {number} x - Normalized screen X coordinate in [0, 1] range (left == 0)
 *  @param {number} y - Normalized screen Y coordinate in [0, 1] range (top == 0)
 *  @returns {THREE.Vector3} - Point in world space
 */
Navigation.prototype.getWorldPoint = function(x, y)
{
    /*
    var x = (mouseX - this.viewport.left) / this.viewport.width;
    var y = (mouseY - this.viewport.top) / this.viewport.height;
    */
    y = 1.0 - y;    // Invert Y so 0 == bottom and map to [-1, 1]
    x = x * 2.0 - 1.0;
    y = y * 2.0 - 1.0;
    var camera = this.getCamera();
    var clickPoint;

    if( camera.isPerspective )
    {
        clickPoint = new THREE.Vector3(x, y, 1.0);
        clickPoint = clickPoint.unproject(camera);
    }
    var view     = this.getEyeVector();
    var position = this.getPosition();
    var direction, distance;

    if( !camera.isPerspective || isNaN(clickPoint.x) )
    {
        // Calculate a point based on the view...
        var xysize = this.getWorldSize(view.length());
        var trackX = this.getCameraRightVector(false).multiplyScalar( (x * 0.5) * xysize.x );
        var trackY = this.getCameraUpVector().multiplyScalar( (y * 0.5) * xysize.y );
        direction = view.clone().add(trackX).add(trackY).normalize();
        // avp.logger.log("GWP: ALT(" + direction.x.toFixed(3) + ", "+ direction.y.toFixed(3) + ", "+ direction.z.toFixed(3) + ")" + x + ", " + y);
    }
    else
    {
        direction = clickPoint.sub(position).normalize();
        // avp.logger.log("GWP: DIR(" + direction.x.toFixed(3) + ", "+ direction.y.toFixed(3) + ", "+ direction.z.toFixed(3) + ")");
    }
    var pivot = this.getPivotPoint();
    var denominator = direction.dot(view);
    // LMV-2582 and LMV-2284
    // old: var usePivot = this.__pivotIsSetFlag && (this.getIs2D() || (camera.isPerspective && this.isPointVisible(pivot)));
    var usePivot = this.__pivotIsSetFlag && (this.getIs2D() || (camera.isPerspective && (denominator > 0.0)));
    if( usePivot )
    {
        // get the length along the view direction of the point.
        distance = (denominator !== 0.0)
                 ? Math.abs(pivot.sub(position).dot(view)) / denominator
                 : pivot.sub(position).length();
    }
    else
    {
        distance = camera.isPerspective ? (camera.near + camera.far) * 0.5
                                        : camera.orthoScale;
    }
    return direction.multiplyScalar(distance).add(position);
};

/**
 * @returns {number} - The perpendicular distance from the camera to the plane containing the pivot point.
 */
Navigation.prototype.getPivotPlaneDistance = function()
{
    var pivot = this.getPivotPoint();
    var view  = this.getEyeVector();
    var position = this.getPosition();

    return pivot.sub(position).dot(view.normalize());
};

/**
 * Pan the camera a relative distance up/down or left/right.
 *  @param {number} deltaX - Normalized X distance to pan left/right (negative/positive).
 *  @param {number} deltaY - Normalized Y distance to pan down/up (negative/positive).
 *  @param {number} atDistance - Pan distance is scaled by the size of the view frustum at this distance from the camera.
 */
Navigation.prototype.panRelative = function( deltaX, deltaY, atDistance )
{
    if (!this.isActionEnabled('pan')) {
        return;
    }

    var trackSpeed = this.getWorldSize(atDistance);
    var offsetX = deltaX * trackSpeed.x;
    var offsetY = deltaY * trackSpeed.y;

    var trackX = this.getCameraRightVector(false).multiplyScalar( offsetX );
    var trackY = this.getCameraUpVector().multiplyScalar( offsetY );

    var offsetVector = trackX.add(trackY);

    // restrict panning if we use 2D mode with constraints
    this.applyPanningConstraint2D(offsetVector);

    this.setView( this.getPosition().add(offsetVector), this.getTarget().add(offsetVector) );
};

/**
 * Dolly the camera a distance along the vector from a given point to its current position. The dolly distance is clamped to not go past the point.
 *  @param {number} distance - World space distance to move the camera by.
 *  @param {THREE.Vector3} point - World space position used to define the dolly direction.
 */
Navigation.prototype.dollyFromPoint = function( distance, point, bounds)
{
    if( !this.isActionEnabled('zoom') || Math.abs(distance) <= this.__kEpsilon )
        return;

    var position = this.getPosition();
    var dollyVec = point.clone().sub(position);

    // For orthographic cameras the distance from the target to the eye
    // determines the zoom. So we need to make sure the dolly point is
    // is in the plane of the target, relative to the view direction.
    // If we don't do this, then the target will drift in the view
    // direction and the zoom to distance calculation is wrong.
    var viewVec = this.getEyeVector();
    if ( !this.getCamera().isPerspective ) {
        var viewLenSq = viewVec.lengthSq();
        var dollyDot = viewVec.dot( dollyVec );
        if (dollyDot == 0)  // Not a dolly, this is a pan
            return;
        dollyVec.multiplyScalar( viewLenSq / dollyDot );
        point = position.clone().add( dollyVec );
    }

    var oldLength = dollyVec.length();
    var newLength = oldLength + distance;
    if( newLength < this.__minDistance )
        newLength = this.__minDistance;

    var scaleFactor = newLength / oldLength;

    // restrict min/max distance if a viewRegion or maxPixelPerUnit constraint is set.
    scaleFactor = this.applyDollyConstraint(scaleFactor, bounds);

    if( Math.abs(scaleFactor - 1.0) > this.__kEpsilon )
    {
        dollyVec.multiplyScalar( scaleFactor );
        dollyVec.set(-dollyVec.x, -dollyVec.y, -dollyVec.z);
        var newPosition = dollyVec.add(point);

        // Compute a new look at point from the new position:
        var viewVec = this.getEyeVector();

        // For ortho cameras we must scale the view vector to actually
        // perform an ortho zoom operation:
        if( !this.getCamera().isPerspective )
            viewVec.multiplyScalar( scaleFactor );

        this.setView( newPosition, viewVec.add(newPosition) );
    }
};

/**
 *  Change current camera to perspective camera.
 *
 *  Not applicable to 2D.
 */
Navigation.prototype.toPerspective = function()
{
    if( this.getIs2D() )
    {
        avp.logger.warn("Autodesk.Viewing.Navigation.toPerspective is not applicable to 2D");
        return;
    }

    var camera = this.getCamera();

    if( !camera.isPerspective )
    {
        camera.toPerspective();
        camera.dirty = true;
    }
};

/**
 *  Change current camera to orthographic camera
 */
Navigation.prototype.toOrthographic = function()
{
    var camera = this.getCamera();

    if( camera.isPerspective )
    {
        camera.toOrthographic();
        camera.dirty = true;
    }
};

/** 
 * Helper method that snaps a Vector3 to one of the 3 main orthogonal axis.
 * @param {THREE.Vector3} v - vector to snap, it gets modified.
 */
Navigation.snapToAxis = function(v) {
    var absv = new THREE.Vector3(Math.abs(v.x), Math.abs(v.y), Math.abs(v.z));

    if (absv.x > absv.y && absv.x > absv.z)
        v.set(v.x > 0 ? 1 : -1, 0, 0);
    else if (absv.y > absv.x && absv.y > absv.z)
        v.set(0, v.y > 0 ? 1 : -1, 0);
    else
        v.set(0, 0, v.z > 0 ? 1 : -1);

    return v;
};

Autodesk.Viewing.Navigation = Navigation;

})();

AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.HotGestureTool = function( viewerApi )
{
    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isActive = false;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["hottouch"];

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };
    var _commandKeyDown = false;
    var _setMode = null;
    var _saveMode = null;
    var _fovActive = false;
    var _rollActive = false;
    var _startEvent = null;

    var _keys = {
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
             ESCAPE: 27,
           LCOMMAND: 91,
           RCOMMAND: 93,
         COMMANDMOZ: 224
    };

    var ORBIT   = "orbit";
    var ROLL    = "worldup";
    var FOV     = "fov";

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
    };

    this.deactivate = function(name)
    {
    };
    
    this.__checkStart = function()
    {
        // Since the start event triggers the tool change we re-send the
        // start event so that the new tool can trigger from it.
        if( _startEvent )
        {
            this.controller.distributeEvent("handleGesture", _startEvent);
            _startEvent = null;
        }
    };

    this.update = function()
    {
        if( this.controller.getIsLocked() )
            return false;

        var got = viewerApi.getActiveNavigationTool();
        var wantRoll = (_fovActive === false && _rollActive === true);
        var wantFov  = (_fovActive === true && _rollActive === false);

        if( wantRoll || wantFov )
        {
            var want = wantRoll ? ROLL : FOV;

            if( got === want )
                return false;

            if( got === _setMode )  // We set it we can change it
            {
                viewerApi.setActiveNavigationTool(want);
                _setMode = want;
                this.__checkStart();
                return false;
            }
            _saveMode = got;
            viewerApi.setActiveNavigationTool(want);
            _setMode = want;
            this.__checkStart();
        }
        else if( _setMode )
        {
            viewerApi.setActiveNavigationTool(_saveMode);
            _setMode = null;
            _saveMode = null;
        }
        return false;
    };

    this.resetKeys = function()
    {
        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
    };

    this.updateModifierState = function( event )
    {
        _modifierState.CONTROL = event.ctrlKey  ? 1 : 0;
        _modifierState.SHIFT   = event.shiftKey ? 1 : 0;
        _modifierState.ALT     = event.altKey   ? 1 : 0;
    };

    this.handleGesture = function( event )
    {
        if( event === _startEvent )
            return false;

        switch( event.type )
        {
            case "drag3start":
                if (viewerApi.navigation.isActionEnabled('fov')) {
                    _startEvent = event;
                    _fovActive = true;
                }
                break;

            case "drag3move":
                break;

            case "drag3end":
                _fovActive = false;
                break;

            case "rotatestart":
                if (viewerApi.navigation.isActionEnabled('roll')) {
                    _startEvent = event;
                    _rollActive = true;
                }
                break;

            case "rotatemove":
                break;

            case "rotateend":
                _rollActive = false;
                break;
        }
        return false
    };

    this.handleKeyDown = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 1;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; break;
            case _keys.ALT:     _modifierState.ALT = 1;     break;
        }
        return false;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; break;
            case _keys.ALT:     _modifierState.ALT = 0;     break;
        }
        return false;
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        return false;
    };
}

'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback
 * @param {number[]} keycodes - The key combination that triggered this callback.
 * @returns {boolean} True if the press event was handled, false otherwise.
 */

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback
 * @param {number[]} keycodes - The key combination that triggered this callback.
 * @returns {boolean} True if the release event was handled, false otherwise.
 */

/**
 * @typedef {Object} Autodesk.Viewing.HotkeyManager~Hotkey
 * @property {number[]} keycodes - The keycode combination (order doesn't matter).
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback} [onPress] - The callback used when the combination is engaged.
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback} [onRelease] - The callback used when the combination is disengaged.
 */

/**
 * Management of hotkeys for the viewer.
 *
 * Access the members and methods via the singleton theHotkeyManager.
 * @constructor
 * @category Core
 */
Autodesk.Viewing.HotkeyManager = function () {
    var stack = []; // The hotkey stack

    var keys = []; // The keys that are currently held

    // Pending items
    var onPressQueue = [];
    var onReleaseQueue = [];

    /**
     * Enum for keycodes.
     * @readonly
     * @enum {number}
     */
    var KEYCODES = Autodesk.Viewing.KeyCode;

    var _names = ["hotkeys"];

    function getNames()
    {
        return _names;
    }

    function getName()
    {
        return _names[0];
    }

    // Apparently javascript sorts by string values by default so we need
    // our own sort function.
    function compare(a, b) {
        return a - b;
    }

    /**
     * Pushes new hotkeys onto the stack.
     *
     * @param {string} id - The id for this hotkey set.
     * @param {Autodesk.Viewing.HotkeyManager~Hotkey[]} hotkeys - The list of hotkeys.
     * @param {object} [options] - An optional dictionary of options for this hotkey set.
     * @param {boolean} [options.tryUntilSuccess] - When true, the onPress callback will be called until it returns true
     * or the hotkey state changes. The onRelease callback will be called until it returns true or
     * until the combination is reengaged. Stops propagation through the stack. Non-blocking.
     * @returns {boolean} True if the hotkeys were successfully pushed.
     */
    function pushHotkeys(id, hotkeys, options) {
        var idAlreadyUsed = stack.some(function(element) {
            return element.id === id;
        });

        if (idAlreadyUsed) {
            return false;
        }

        for (var i = 0; i < hotkeys.length; i++) {
            stack.push({
                id: id,
                keys: hotkeys[i].keycodes.sort(compare).join(),
                onPress: hotkeys[i].onPress,
                onRelease: hotkeys[i].onRelease,
                options: options || {}
            });
        }

        return true;
    }

    /**
     * Removes hotkeys associated with an ID from the stack.
     *
     * @param {string} id - The id associated with the hotkeys.
     * @returns {boolean} True if the hotkeys were successfully popped.
     */
    function popHotkeys(id) {
        var found = false;
        for (var i = stack.length - 1; i >= 0; i--) {
            if (stack[i].id === id) {
                stack.splice(i, 1);
                found = true;
            }
        }

        return found;
    }

    function cleanQueues() {
        var index = keys.join();

        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.keys === index) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.keys !== index) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }
    }

    function handleKeyDown(event, keyCode) {
        if (keys.indexOf(keyCode) !== -1) {
            // Ignore duplicate key down events. (see ToolController.applyKeyMappings())
            return;
        }

        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = 0;
        while (i < keys.length && keys[i] < keyCode) {
            i++;
        }
        keys.splice(i, 0, keyCode);

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function handleKeyUp(event, keyCode) {
        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = keys.indexOf(keyCode);
        if (i > -1) {
            keys.splice(i, 1);
        }

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function update() {
        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.onRelease(item.keys.split()) === true) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.onPress(item.keys.split()) === true) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        return false;
    }

    function handleBlur() {
        // Release all keys.
        for (var i = keys.length - 1; i >= 0; i--) {
            handleKeyUp(null, keys[i]);
        }
    }

    return {
        pushHotkeys: pushHotkeys,
        popHotkeys: popHotkeys,
        handleKeyDown: handleKeyDown,
        handleKeyUp: handleKeyUp,
        handleBlur: handleBlur,
        getName: getName,
        getNames: getNames,
        activate: function(){},
        deactivate: function(){},
        update: update,
        KEYCODES: KEYCODES
    };
};

Autodesk.Viewing.theHotkeyManager = new Autodesk.Viewing.HotkeyManager();

AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.FovTool = function( viewerApi )
{
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kFovDragScale = -1.0;
    var kDampingFactor = 0.6;
    var kWheelThresholdMs = 100;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["fov"];

    var _interactionActive = false;

    var _wheelAccum = 0;
    var _wheelOldest = null;
    var _wheelNewest = null;
    var _wheelContinuous = false;

    var _mouseButtons = 0; // Track mouse buttons that are held

    // Interaction Triggers:
    var kNone = -5;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        _mouseButtons = 0;
    };

    this.deactivate = function(name)
    {
        _activeTrigger = kNone;
    };
    
    this.getCursor = function()
    {
        return _mouseButtons !== 0 && _activeTrigger === kNone ? null : "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnAwMD/yEhIf8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAGknJyf/goKC/8/Pz/8aGhr/AAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAABTFBQU/2lpaf/MzMz///////////+Wlpb/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAOAAAAKFTU1P/t7e3////////////8PDw////////////AQEB/wAAAAEAAAAAAAAAFAAAAH0KCgr/AAAAYwAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAjCwsL/6Ghof/t7e3///////Dw8P9MTEz/LS0t//Pz8///////Ghoa/wAAABoAAAANDQ0N/319ff+rq6v/Y2Nj/wAAAK8AAABGAAAA////////////AAAA/wAAAF0hISH/jIyM////////////sLCw/xEREf8AAACHAAAArKysrP//////V1dX/wAAAFcAAABSUlJS//f39///////8PDw/6+vr/86Ojr/LS0t////////////FRUV/1xcXP/Gxsb/+Pj4//Hx8f9MTEz/AAAAsAAAAEcAAAAAAAAAZ2dnZ///////pKSk/wAAAKQAAACtra2t///////////////////////m5ub/kZGR/wAAAP8AAAD/q6ur//Hx8f//////vb29/x0dHf8AAACIAAAAAAAAAAAAAAAAAAAAOjo6Ov//////5+fn/wAAAOcAAADd3d3d////////////////////////////+/v7/9bW1v/i4uL//v7+//Pz8/9hYWH/AAAAvQAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAJycnJ//6+vr//////wMDA/8AAADv7+/v/////////////////////////////////////////////////7y8vP8ODg7/AAAAKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJiYmJv/6+vr//////wkJCf8AAADv7+/v//////////////////////////////////f39//9/f3//////+np6f+UlJT/GBgY/wAAAH0AAAACAAAAAAAAAAAAAAAAAAAAKSkpKf///////v7+/w0NDf8AAADd3d3d////////////////////////////29vb/39/f/+Xl5f/5+fn////////////5ubm/1RUVP8CAgL/AAAAPwAAAAAAAAAAAAAAOTk5Of//////8PDw/wgICP8AAAChoaGh/////////////////+np6f+YmJj/QkJC/wAAAP8AAAD/UFBQ/7e3t//39/f///////////+oqKj/EBAQ/wAAAIgAAAAAAAAAZ2dnZ///////29vb/wEBAf8AAAA4NTU1/9zc3P/t7e3/tbW1/01NTf8AAACYAAAA////////////AwMD/wsLC/9oaGj/y8vL////////////8fHx/zg4OP8AAACWAAAApaWlpf//////n5+f/wAAAJ8AAAAAAAAAczg4OP9LS0v/EhIS/wAAAE0AAAAAAAAA////////////FRUV/wAAABUAAABoJSUl/4GBgf/i4uL///////////9+fn7/Pz8///b29v//////SkpK/wAAAEoAAAAAAAAAAAAAADgAAABLAAAAEgAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAJQAAAIE8PDz/np6e//z8/P/////////////////8/Pz/CQkJ/wAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAA8DAwM/09PT/+7u7v///////////+QkJD/AAAAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////Dw8P/wAAAA8AAAAAAAAAAAAAAAAAAAAAAAAADAAAAFIYGBj/aGho/729vf8WFhb/AAAAJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////FRUV/wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAQEB/w8PD/8AAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////DAwM/wAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/h/nO/4fw1D+HwFy/h4BRu4YAHOGEABkAAAAXAAAIFwAAOBnAAHgIAAD4GUAAOB4AABgXAAAIGMAAABtggAAVMYYAHT+HgE7/g8BcP4Pw2/+D+dc/h//XP///2c=), auto";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);
    };

    function promoteDelta(delta)
    {
        // promote a wheel delta to a full wheel stop (3)
        if ( delta < 0 && delta > -3 ) {
            return -3;
        }
        return ( delta > 0 && delta < 3 ) ? 3 : delta;
    }

    this.getAccumulatedWheelDelta = function()
    {
        var now = Date.now();
        var delta = 0;

        if ( _wheelNewest && now - _wheelNewest > kWheelThresholdMs ) {
            // Newest event in accumulator has aged out; assume wheel motion has stopped.
            delta = promoteDelta(_wheelAccum);
            _wheelAccum = 0;
            _wheelOldest = null;
            _wheelNewest = null;
            _wheelContinuous = false;
        }
        else if ( _wheelOldest && (now - _wheelOldest) > kWheelThresholdMs ) {
            // Oldest event in accumulator has aged out; process continuously.
            if ( _wheelContinuous ) {
                if( Math.abs(_wheelAccum) >= 3 ) {
                    delta = _wheelAccum;
                    _wheelAccum = 0;
                }
            } else {
                delta = promoteDelta(_wheelAccum);
                _wheelContinuous = true;
                _wheelAccum = 0;
            }
        }
        return delta;
    };

    this.update = function()
    {
        var wheelEnded = false;
        var updatePivot = _activeTrigger > kNone;

        if( _activeTrigger > kNone )
        {
            this.controller.setIsLocked(true);
            this.getMotionDelta(_motionDelta);

            var deltaX = _motionDelta.x;
            var deltaY = _motionDelta.y;
            var deltaZ = _motionDelta.z;

            if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
            {
                updatePivot = true;
                if( _activeTrigger >= kMouseLeft )
                {
                    // Map XY movement to Z:
                    deltaY = -deltaY;   // Invert Y
                    deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                    if( deltaZ !== 0.0 )
                    {
                        deltaZ *= kFovDragScale;
                        _navapi.setVerticalFov(_navapi.getVerticalFov() * (1.0 + deltaZ), true);
                    }
                }
                else 
                {
                    // Translate wheelAccum backwards to determine the number of wheel stops.
                    var deltaFocalLength = this.getAccumulatedWheelDelta() / 3;
                    if( deltaFocalLength !== 0.0 )
                        _navapi.setFocalLength(_navapi.getFocalLength() + deltaFocalLength, true);
                }
            }
            this.stepMotionDelta(_motionDelta, true);

            // If a wheel event triggered this we've now handled it,
            if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
            {
                this.interactionEnd(kWheel);
                wheelEnded = true;
            }
        }

        if( updatePivot )
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), true);
        else
            this.utilities.pivotUpdate();

        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);
            }
            _activeTrigger = kNone;
            this.controller.setIsLocked(false);
        }
        return _camera.dirty;
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority 
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;
        }

        // Switch to perspective
        _navapi.toPerspective();
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    
    this.handleWheelInput = function(delta)
    {
        if( _activeTrigger > kWheel )
            return false;

        // Match original reverse behaviour:
        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;
        _wheelAccum += delta;
        var now = Date.now();
        if ( !_wheelOldest ) {
            _wheelOldest = now;
        }
        _wheelNewest = now;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                return this.handleButtonUp(event, 0);

            case "drag3start":
                _touchType = "drag";
                // Fake the mouse for now. Coord should be centroid.
                return this.handleButtonDown(event, 0);

            case "drag3move":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "drag3end":
                if( _touchType === "drag" )
                    this.handleButtonUp(event, 0);

                _touchType = null;
                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        _mouseButtons += 1 << button;

        if (button !== kMouseRight) {
            _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            _moveXYZ.copy(_startXYZ);

            this.interactionStart(button);
            return true;
        }

        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        if (button !== kMouseRight) {
            _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            this.interactionEnd(button);
            return true;
        }

        return false;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return (_activeTrigger > kWheel);
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.interactionEnd(_activeTrigger);
        return false;
    };

};

AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.WorldUpTool = function( viewerImpl, viewerApi )
{
    var kRingSizeMin = 0.35; // Proportion of screen height
    var kRingSizeMax = 0.80; // Proportion of screen height
    var kRingSizeDefault = 0.65; // Proportion of screen height

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["worldup"];
    var self = this;

    // Returns the projection of (x,y,z) onto the plane with this unit normal
    var projectAxis = function()
    {
        var projectionVec = new THREE.Vector3();

        return function (x, y, z, normal)
        {
            var vec = new THREE.Vector3(x, y, z);
            var projectionLength = normal.dot(vec);
            projectionVec.copy(normal);
            projectionVec.multiplyScalar(projectionLength);
            return vec.sub(projectionVec);
        }
    }();

    // /** @constructor */
    function RollInteraction( viewerImpl, camera )
    {
        var kRollColor = 0xBBBBBB;
        var kHudFov = 30;
        var kHudWorldScale = 2.0 * Math.tan(THREE.Math.degToRad(kHudFov * 0.5));

        var myMaterial  = new THREE.MeshPhongMaterial({
            color:       kRollColor,
            ambient:     kRollColor,
            opacity:     0.5,
            transparent: true,
            depthTest:   false,
            depthWrite:  false,
        });

        // Preallocate these as work objects:
        var myVec1   = new THREE.Vector3();
        var myVec2   = new THREE.Vector3();
        var myRotate = new THREE.Quaternion();

        // Use our own camera for the Roll HUD:
        // var myCamera = camera.clone();   // There's a bug in Object3D.clone()
        var myCamera = new THREE.PerspectiveCamera(kHudFov, camera.aspect, camera.near, camera.far);
        var mySceneCamera = camera;
        var myRingScale = 1.0;
        var myRingSize = 1.0;
        var myLookAtPoint = null;
        var myReferenceCircle = null;
        var myReferenceXaxis = null;
        var myReferenceYaxis = null;
        var myReferenceZaxis = null;
        var myReferenceGeometry = null;
        var myReferenceUp = null;
        var mySnapPoints = null;
        var mySnapFlags = null;
        var mySnapAngles = new Array(6);
        var myClosestAngle = 0.0;
        var myRollAngle = 0.0;
        var myAnglesFlipped = false;
        var myCurrentlySnapped = true;  // Assume initially true
        var mySnappedRoll = 0.0;
        var kSnapInThreshold  = 5.0 * Math.PI / 180.0;
        var kSnapOutThreshold = 7.0 * Math.PI / 180.0;
        var myDistance = 1.0;

        var kNOSNAP = 1e3;
        var kAliasLengthThreshold = 0.1;

        viewerImpl.createOverlayScene("roll", null, null, myCamera);

        function angleDiff(a, b)
        {
            var diff = Math.abs(a - b);
            if( diff > kTwo_PI )
                return diff;

            return Math.min(kTwo_PI - diff, diff);
        }

        function isThisAxis(index, worldUp)
        {
            var snapVec = getSnapVector(index);
            if( snapVec.distanceToSquared(worldUp) < kEpsilon )
                return true;

            myVec2.set(-worldUp.x, -worldUp.y, -worldUp.z);
            return (snapVec.distanceToSquared(myVec2) < kEpsilon);
        }

        function filterSnapAngles(snapLengths, worldUp)
        {
            // For some rotation axes the snap angles for two axes can be close together.
            // Snapping to one or the other doesn't give expected results. This filters
            // the snap angles and removes one of the close angles. When two angles are
            // withing AliasSnapThreshold, one of the angles is removed. The one we keep
            // is the one with the longest projection length unless it happens to be the
            // current up direction.

            // This threshold should be greater than the snap out threshold plus the snap
            // in threshold so that when two snap points are close together there is room
            // to snap out of one and into the other.
            var kAliasSnapThreshold = kSnapInThreshold + kSnapOutThreshold + (2.0 * Math.PI / 180.0);

            for (var i = 0; i < 6; ++i)
            {
                if( mySnapAngles[i] === kNOSNAP )
                    continue;

                for (var j = i + 1; j < 6; ++j)
                {
                    if( mySnapAngles[j] === kNOSNAP )
                        continue;

                    var diff = angleDiff(mySnapAngles[i], mySnapAngles[j]);

                    if (diff < kAliasSnapThreshold)
                    {
                        if( (snapLengths[i] < snapLengths[j] && !isThisAxis(i, worldUp))
                        ||  isThisAxis(j, worldUp) )
                        {
                            mySnapAngles[i] = kNOSNAP;
                            break;  // angle i is removed stop checking
                        }
                        else
                            mySnapAngles[j] = kNOSNAP;
                    }
                }
            }
        }

        // Calculate the opposite angle from angle. angle should be
        // from -PI to PI, or kNOSNAP
        function oppositeAngle(angle)
        {
            if( angle > kTwo_PI )
                return angle;
            if( angle <= 0.0 )
                return angle + Math.PI;
            return angle - Math.PI;
        }

        function updateSnapPoints(viewVec, cameraUp, worldUp)
        {
            var normal = viewVec.clone().normalize();
            var snaps   = new Array(3);
            var lengths = new Array(6);

            // Project the 6 axis vectors onto the view plane:
            snaps[0] = projectAxis(1.0, 0.0, 0.0, normal);
            snaps[1] = projectAxis(0.0, 1.0, 0.0, normal);
            snaps[2] = projectAxis(0.0, 0.0, 1.0, normal);

            var i;
            var left = cameraUp.clone().cross(normal).normalize();

            for( i=0; i < 3; ++i )
            {
                var snap = snaps[i];
                lengths[i] = snap.length();

                // A short projection length means the axis was too close to
                // the view vector:
                if( lengths[i] < kAliasLengthThreshold )
                {
                    mySnapAngles[i] = kNOSNAP;
                }
                else
                {
                    snap.multiplyScalar(1.0 / lengths[i]);
                    mySnapAngles[i] = Math.atan2(left.dot(snap), cameraUp.dot(snap));
                }
            }
            mySnapAngles[3] = oppositeAngle(mySnapAngles[0]);
            mySnapAngles[4] = oppositeAngle(mySnapAngles[1]);
            mySnapAngles[5] = oppositeAngle(mySnapAngles[2]);
            lengths[3] = lengths[0];
            lengths[4] = lengths[1];
            lengths[5] = lengths[2];

            filterSnapAngles(lengths, worldUp);

            for( i=0; i < 6; ++i )
            {
                if( mySnapAngles[i] !== kNOSNAP )
                {
                    var z = myVec2.set(0.0, 0.0, 1.0);
                    myRotate.setFromAxisAngle( z, mySnapAngles[i] );
                    // The radius of the circle is 0.5 so place the points
                    // just outside the circle:
                    var pos = myVec2.set(0.0, 0.54, 0.0);
                    pos.applyQuaternion( myRotate );
                    mySnapPoints[i].position.copy(pos);
                    mySnapPoints[i].visible = true;
                }
                else
                    mySnapPoints[i].visible = false;
            }
        }

        function buildReferenceGeometry()
        {
            myReferenceGeometry = new THREE.Object3D();

            // The roll hud geometry is built with unit diameter and then scaled
            // to world space later.
            var geom   = new THREE.RingGeometry( 0.5 - 0.01 * myRingScale, 0.5, 60 );
            var circle = new THREE.Mesh( geom, myMaterial );

            myReferenceCircle = circle;

            var thick = 0.007 * myRingScale;
            var geomX = new THREE.BoxGeometry( 0.930, thick, thick );
            var geomY = new THREE.BoxGeometry( thick, 0.930, thick );
            var geomZ = new THREE.BoxGeometry( thick, thick, 0.930 );

            myReferenceXaxis = new THREE.Mesh( geomX, myMaterial );
            myReferenceYaxis = new THREE.Mesh( geomY, myMaterial );
            myReferenceZaxis = new THREE.Mesh( geomZ, myMaterial );

            myReferenceGeometry.add( myReferenceXaxis );
            myReferenceGeometry.add( myReferenceYaxis );
            myReferenceGeometry.add( myReferenceZaxis );

            myReferenceUp = new THREE.Mesh( new THREE.CircleGeometry( 0.005 ), myMaterial );
            myReferenceGeometry.add(myReferenceUp);

            mySnapPoints = new Array(6);
            mySnapFlags  = new Array(6);
            for( var i = 0;  i < 6;  ++i )
            {
                var r1 = 0.0050 * myRingScale;
                var r2 = 0.0025 * myRingScale;
                mySnapPoints[i] = new THREE.Mesh( new THREE.CircleGeometry( r1, 16 ), myMaterial );
                mySnapFlags[i]  = new THREE.Mesh( new THREE.CircleGeometry( r2, 16 ), myMaterial );
                mySnapFlags[i].visible = false;
                mySnapPoints[i].add(mySnapFlags[i]);
                circle.add(mySnapPoints[i]);
            }
            myReferenceGeometry.add( circle );

            return myReferenceGeometry;
        }

        function getReferenceGeometry(scale, lookAtPoint, viewVec, worldUp, cameraUp)
        {
            if( !myReferenceGeometry )
                myReferenceGeometry = buildReferenceGeometry();

            _navapi.orient(myReferenceCircle, lookAtPoint, myCamera.position, worldUp);

            updateSnapPoints(viewVec, cameraUp, worldUp);

            myReferenceGeometry.scale.x = scale;
            myReferenceGeometry.scale.y = scale;
            myReferenceGeometry.scale.z = scale;

            myReferenceGeometry.position.copy(lookAtPoint);

            return myReferenceGeometry;
        }

        function getSnapVector(index)
        {
            myVec1.set(0.0, 0.0, 0.0);
            if( index >= 0 )
            {
                var v = (index >= 3) ? -1 : 1;
                index %= 3;
                if( index === 0 ) myVec1.x = v;
                if( index === 1 ) myVec1.y = v;
                if( index === 2 ) myVec1.z = v;
            }
            if( myAnglesFlipped )
                myVec1.multiplyScalar(-1);

            return myVec1;
        }

        function closestSnap(dtheta, snapThresh)
        {
            var diff = angleDiff(mySnapAngles[0], dtheta);
            var closest = 0;
            for (var i = 1; i < 6; ++i)
            {
                var d = angleDiff(mySnapAngles[i], dtheta);
                if (d < diff)
                {
                    diff = d;
                    closest = i;
                }
            }
            myClosestAngle = diff;
            return (diff < snapThresh) ? closest : -1;
        }

        function setWorldUp(upvec)
        {
            _navapi.setWorldUpVector(upvec, true);
        }

        function applyRoll(angle)
        {
            if( angle === 0.0 )
                return;

            var kStableRollThreshold = 30.0 * Math.PI / 180.0;
            var view = myVec2.copy(myCamera.position).sub(myLookAtPoint).normalize();

            // Create a quaterion rotation about the roll axis by the angle:
            myRotate.setFromAxisAngle( view, angle );

            // Check the angle between the view vector and the world up.
            // When we get close the roll about the view vector becomes unstable
            // so we jump the up vector to the camera's current vertical.
            // This should be OK because if we're here we know we aren't snapped.
            var up = _navapi.getWorldUpVector();
            var viewUpAngle = Math.abs(view.angleTo(up));
            if( viewUpAngle < kStableRollThreshold || (Math.PI - viewUpAngle) < kStableRollThreshold )
            {
                up.copy(_navapi.getCameraUpVector());  // This is the actual camera up
            }
            // Rotate the current up vector by that quaternion:
            up.applyQuaternion( myRotate );

            setWorldUp(up);
        }

        function justNowSnapped()
        {
            if( !myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapInThreshold);
                if( closest >= 0 )
                {
                    myClosestAngle = 0.0;
                    myCurrentlySnapped = true;
                    myRollAngle = mySnapAngles[closest];
                    return getSnapVector(closest);
                }
            }
            return false;
        }

        function justNowUnsnapped()
        {
            if( myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapOutThreshold);
                if( closest < 0 )
                {
                    myCurrentlySnapped = false;
                    return true;
                }
                myClosestAngle = 0.0;
            }
            return false;
        }

        function isReallySnapped(angle, threshold, i, worldUp)
        {
            var circleSnapped = (angle < threshold);
            if( circleSnapped )
            {
                // Check if the up direction really is the same:
                var snapUp = getSnapVector(i);
                return (snapUp.distanceToSquared(worldUp) < kEpsilon);
            }
            return false;
        }

        function updateIndicators(worldUp, cameraUp)
        {
            // Check if the camera is upside down. If so, up is down.
            var wDotC = worldUp.dot(cameraUp);
            var flipped = (wDotC < 0.0);
            if( flipped )
                cameraUp = cameraUp.clone().multiplyScalar(-1);

            // Need to re-orient and position the UP indicator.
            // The scalar is the middle radius of the ring geometry.
            _navapi.orient(myReferenceUp, myLookAtPoint, myCamera.position, cameraUp);
            myReferenceUp.position.copy(cameraUp.multiplyScalar(0.495));

            var isSnapped = false;
            var threshold = myCurrentlySnapped ? kSnapOutThreshold : kSnapInThreshold;
            for (var i = 0; i < 6; ++i)
            {
                var angle = angleDiff(mySnapAngles[i], myRollAngle);
                var snapped = isReallySnapped(angle, threshold, i, worldUp);
                if( snapped )
                    isSnapped = true;
                var proximityScale = snapped ? 4.0 : (1.0 - 3.0 * angle / Math.PI) * 3.0;
                if( proximityScale < 1.0 )
                    proximityScale = 1.0;

                // Keep the snap point sizes independent of the ring size:
                proximityScale *= myRingScale;

                // This turns off/on the inner snap indicator circle within
                // each of the snap points:
                mySnapFlags[i].visible = snapped;
                var snap = mySnapPoints[i];
                snap.scale.x = proximityScale;
                snap.scale.y = proximityScale;
                snap.scale.z = proximityScale;
            }
            myReferenceXaxis.visible = isSnapped;
            myReferenceYaxis.visible = isSnapped;
            myReferenceZaxis.visible = isSnapped;

            return isSnapped;
        }

        this.updateRollCamera = function(size, distance)
        {
            myCamera.position.copy(mySceneCamera.position);
            myCamera.quaternion.copy(mySceneCamera.quaternion);
            myCamera.up.copy(mySceneCamera.up);
            myCamera.aspect = mySceneCamera.aspect;

            if( size && distance )
            {
                myCamera.near = distance - size;
                myCamera.far  = distance + size;
            }
            myCamera.updateProjectionMatrix();
        };

        this.isSnapped = function()
        {
            return myCurrentlySnapped;
        };

        this.resize = function()
        {
            var worldHeight = myDistance * kHudWorldScale;
            var worldWidth  = worldHeight * mySceneCamera.aspect;
            var worldSize   = ((mySceneCamera.aspect < 1.0) ? worldWidth : worldHeight) * myRingSize;

            myReferenceGeometry.scale.x = worldSize;
            myReferenceGeometry.scale.y = worldSize;
            myReferenceGeometry.scale.z = worldSize;
        };

        // TODO: Check for rolled camera and re-orient to up before setting up HUD.
        this.start = function(lookAtPoint, ringSize)
        {
            this.updateHUD(lookAtPoint, ringSize);
            viewerImpl.addOverlay("roll", myReferenceGeometry);
        };

        this.updateHUD = function(lookAtPoint, ringSize)
        {
            myLookAtPoint = lookAtPoint;

            if( ringSize < kRingSizeMin )
                ringSize = kRingSizeMin;
            else if( ringSize > kRingSizeMax )
                ringSize = kRingSizeMax;

            myRingSize  = ringSize;
            myRingScale = kRingSizeMax / ringSize;

            var viewVec = myVec1.copy(lookAtPoint).sub(mySceneCamera.position);
            myDistance = viewVec.length();

            var worldHeight = myDistance * kHudWorldScale;
            var worldWidth  = worldHeight * mySceneCamera.aspect;
            var worldSize   = ((mySceneCamera.aspect < 1.0) ? worldWidth : worldHeight) * ringSize;

            this.updateRollCamera(worldSize, myDistance);

            var worldUp  = _navapi.getWorldUpVector();
            var cameraUp = _navapi.getCameraUpVector();
            getReferenceGeometry(worldSize, lookAtPoint, viewVec, worldUp, cameraUp);
            myRollAngle = 0.0;
            mySnappedRoll = 0.0;

            var wDotC = worldUp.dot(cameraUp);
            myAnglesFlipped = (wDotC < 0.0);

            myCurrentlySnapped = updateIndicators(worldUp, cameraUp);
        };

        this.handleRoll = function( dx, dy, p2 )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            if( dx !== 0.0 || dy !== 0.0 )
            {
                // 2D vectors from the center of the screen (0.5, 0.5)
                var v1x = p2.x - dx - 0.5;
                var v1y = p2.y - dy - 0.5;
                var v2x = p2.x - 0.5;
                var v2y = p2.y - 0.5;

                // Angle between those to vectors is the rotation of the mouse
                // around the center of the screen:
                return handleRollByAngle(Math.atan2(v2y, v2x) - Math.atan2(v1y, v1x));
            }
            return false;
        };

        this.handleRollTouch = function ( angle )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            var delta = angle - myRollAngle;
            return (Math.abs(delta) > 0.001) ? handleRollByAngle(delta) : false;
        };

        function handleRollByAngle ( angle )
        {
            // Make sure it's in the right range for comparison with the
            // snap angles:
            myRollAngle += angle;
            if( myRollAngle > Math.PI )
                myRollAngle = myRollAngle - kTwo_PI;
            else if( myRollAngle <= -Math.PI )
                myRollAngle = kTwo_PI + myRollAngle;

            var snappedUp = justNowSnapped();
            if( snappedUp )
            {
                mySnappedRoll = myRollAngle;
                setWorldUp(snappedUp);
            }
            else if( justNowUnsnapped() )
            {
                // Because the snap points are "sticky" the roll amount
                // in this case is the distance from the snap point:
                var deltaRoll = myRollAngle - mySnappedRoll;
                applyRoll(deltaRoll);
                mySnappedRoll = 0.0;
            }
            else if( !myCurrentlySnapped )
            {
                applyRoll(angle);
            }
            else
                return false;

            return true;
        }

        this.end = function()
        {
            viewerImpl.removeOverlay("roll", myReferenceGeometry);
        };
    }

    var kTwo_PI  = 2.0 * Math.PI; // 360 degrees.
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;

    var _isDragging = false;
    var _needNextRefresh = false;
    var _started = false;

    var _rollInteraction = new RollInteraction(viewerImpl, _camera);
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    var _touchAngle = 0.0;
    var _touchCenter = { x: 0.5, y: 0.5 };
    var _touchDistance = 1.0;

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        _started = false;
    };

    this.deactivate = function(name)
    {
        _rollInteraction.end();
        viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        this.utilities.restorePivot();
        _touchType = null;

        _isDragging = false;
        _started = false;
    };

    this.getCursor = function()
    {
        return "auto";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function()
    {
        _startXYZ.copy(_moveXYZ);
    };

    this.update = function()
    {
        if( !_started )
        {
            // Stash the current COI and while the interaction is active
            // use the center of the view as the pivot for rolling.
            //
            // Position the temporary COI half way between the near and far
            // clipping planes to avoid clipping problems:
            //
            var viewVec = _navapi.getEyeVector();
            var distance = (_camera.near + _camera.far) * 0.5;
            viewVec.normalize().multiplyScalar(distance);
            var target = viewVec.add(_camera.position);

            this.utilities.savePivot();
            this.utilities.setPivotPoint( target, true, true );
            this.utilities.pivotActive(true);

            // var ringSize = (_touchType === "roll") ? _touchDistance : kRingSizeDefault;
            var ringSize = kRingSizeDefault;
            _rollInteraction.start( target, ringSize );
            _started = true;
        }

        var moved = _needNextRefresh;

        this.getMotionDelta(_motionDelta);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( _needNextRefresh || _touchType === "roll" || _isDragging && (deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0) )
        {
            if( _touchType === "roll" )
                _needNextRefresh = _rollInteraction.handleRollTouch(_touchAngle);
            else
                _needNextRefresh = _rollInteraction.handleRoll(deltaX, deltaY, _moveXYZ);
        }
        this.stepMotionDelta();

        if( _camera.dirty )
            moved = true;

        return moved;
    };

    this.handleResize = function()
    {
        _rollInteraction.resize();
        _needNextRefresh = true;
    };

    function fingerSeparation(event)
    {
        var dx = event.pointers[1].clientX - event.pointers[0].clientX;
        var dy = event.pointers[1].clientY - event.pointers[0].clientY;
        var dist = Math.sqrt(dx * dx + dy * dy);

        // Normalize:
        var vp = _navapi.getScreenViewport();
        return dist / Math.min(vp.width, vp.height);
    }

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            // Single touch, fake the mouse for now...
            case "dragstart":
                _touchType = "drag";
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                _touchType = null;
                return this.handleButtonUp(event, 0);


            // Rotate gesture detected:
            case "rotatestart":
                viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
                _touchType = "roll";
                _touchAngle = THREE.Math.degToRad(event.rotation);
                _touchCenter = {
                    x: (event.normalizedX + 1.0) * 0.5,
                    y: 1.0 - (event.normalizedY + 1.0) * 0.5
                };
                _touchDistance = fingerSeparation(event);
                return true;

            case "rotatemove":
                _touchAngle = THREE.Math.degToRad(event.rotation);
                return (_touchType === "roll");

            case "rotateend":
                viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
                _touchAngle = THREE.Math.degToRad(event.rotation);
                _touchType = null;

                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };

    this.handleWheelInput = function(delta)
    {
        // Disable wheel while roll active:
        return true;
    };

    this.handleCameraChange = function()
    {
        var viewVec = _navapi.getEyeVector();
        var distance = (_camera.near + _camera.far) * 0.5;
        viewVec.normalize().multiplyScalar(distance);
        var target = viewVec.add(_camera.position);

        // Setting the pivot causes an infinite loop of camera changed events. Is it necessary to set it?
        //this.utilities.savePivot();
        //this.utilities.setPivotPoint( target, true, true );
        //this.utilities.pivotActive(true);

        _rollInteraction.updateHUD( target, kRingSizeDefault );
    };

    this.handleButtonDown = function( event, button )
    {
        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _moveXYZ.copy(_startXYZ);

        _isDragging = true;
        _touchType = null;

        this.controller.setIsLocked(true);

        viewerApi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.handleCameraChange);

        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _isDragging = false;
        _needNextRefresh = true;    // To accept final motion.

        this.controller.setIsLocked(false);

        viewerApi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.handleCameraChange);

        return true;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return true;
    };

    this.handleBlur = function(event)
    {
        _isDragging = false;
        _touchType = null;
        return false;
    };

};

AutodeskNamespace('Autodesk.Viewing');

/**
 * Base class for new interaction tools.
 *
 * Can also be used simply as a template for creating a new tool.
 * @constructor
 * @see Autodesk.Viewing.ToolController
 * @category Core
 */
Autodesk.Viewing.ToolInterface = function()
{
    this.names = [ "unnamed" ];

    /**
     * This method should return an array containing the names of all tools implemented by this class.
     * Often this would be a single name but it is possible to support multiple interactions with a single tool.
     * When this tool is registered with the ToolController each name gets registered as an available tool.
     * @returns {array} Array of strings. Should not be empty.
     */
    this.getNames = function() {
        return this.names;
    };

    /**
     * This is an optional convenience method to obtain the first name of this tool.
     * @returns {string} The tools default name.
     */
    this.getName = function() {
        return this.names[0];
    };

    /**
     * This method is called by {@link Autodesk.Viewing.ToolController#registerTool}.
     * Use this for initialization.
     */
    this.register = function() {
    };

    /**
     * This method is called by {@link Autodesk.Viewing.ToolController#deregisterTool}.
     * Use this to clean up your tool.
     */
    this.deregister = function() {
    };

    /**
     * The activate method is called by the ToolController when it adds this tool to the list of those
     * to receive event handling calls. Once activated, a tool's "handle*" methods may be called
     * if no other higher priority tool handles the given event. Each active tool's "update" method also gets
     * called once during each redraw loop.
     * @param {string} name - The name under which the tool has been activated.
     * @param {Autodesk.Viewing.Viewer3D} viewerApi - Viewer instance.
     */
    this.activate = function(name, viewerApi) {
    };

    /**
     * The deactivate method is called by the ToolController when it removes this tool from the list of those
     * to receive event handling calls. Once deactivated, a tool's "handle*" methods and "update" method
     * will no longer be called.
     * @param {string} name - The name under which the tool has been deactivated.
     */
    this.deactivate = function(name) {
    };

    /**
     * The update method is called by the ToolController once per frame and provides each tool
     * with the oportunity to make modifications to the scene or the view.
     * @param {number} highResTimestamp - The process timestamp passed to requestAnimationFrame by the web browser.
     * @returns {boolean} A state value indicating whether the tool has modified the view or the scene
     * and a full refresh is required.
     */
    this.update = function(highResTimestamp) {
        return false;
    };

    /**
     * This method is called when a single mouse button click occurs.
     * @param {MouseEvent} event - The event object that triggered this call.
     * @param {number} button - The button number that was clicked (0, 1, 2 for Left, Middle, Right respectively).
     * Note that the button parameter value may be different that the button value indicated in the event
     * object due to button re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass
     * the event to lower priority active tools.
     */
    this.handleSingleClick = function( event, button ) {
        return false;
    };

    /**
     * This method is called when a double mouse button click occurs.
     * @param {MouseEvent} event - The event object that triggered this call.
     * @param {number} button - The button number that was clicked (0, 1, 2 for Left, Middle, Right respectively).
     * Note that the button parameter value may be different that the button value indicated in the event
     * object due to button re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleDoubleClick = function( event, button ) {
        return false;
    };

    /**
     * This method is called when a single tap on a touch device occurs.
     * @param {Event} event - The triggering event. For tap events the canvasX, canvasY properties contain
     * the canvas relative device coordinates of the tap and the normalizedX, normalizedY properties contain
     * the tap coordinates in the normalized [-1, 1] range. The event.pointers array will contain
     * either one or two touch events depending on whether the tap used one or two fingers.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleSingleTap = function( event ) {
        return false;
    };

    /**
     * This method is called when a double tap on a touch device occurs.
     * @param {Event} event - The triggering event. For tap events the canvasX, canvasY properties contain
     * the canvas relative device coordinates of the tap and the normalizedX, normalizedY properties contain
     * the tap coordinates in the normalized [-1, 1] range. The event.pointers array will contain
     * either one or two touch events depending on whether the tap used one or two fingers.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleDoubleTap = function( event ) {
        return false;
    };

    /**
     * This method is called when a keyboard button is depressed.
     * @param {KeyboardEvent} event - The event object that triggered this call.
     * @param {number} keyCode - The numerical key code identifying the key that was depressed.
     * Note that the keyCode parameter value may be different that the value indicated in the event object
     * due to key re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleKeyDown = function( event, keyCode ) {
        return false;
    };

    /**
     * This method is called when a keyboard button is released.
     * @param {KeyboardEvent} event - The event object that triggered this call.
     * @param {number} keyCode - The numerical key code identifying the key that was released.
     * Note that the keyCode parameter value may be different that the value indicated in the event object
     * due to key re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleKeyUp = function( event, keyCode ) {
        return false;
    };

    /**
     * This method is called when a mouse wheel event occurs.
     * @param {number} delta - A numerical value indicating the amount of wheel motion applied.
     * Note that this value may be modified from the orignal event values so as to provide consistent results
     * across browser families.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleWheelInput = function(delta) {
        return false;
    };

    /**
     * This method is called when a mouse button is depressed.
     * @param {MouseEvent} event - The event object that triggered this call.
     * @param {Number} button - The button number that was depressed (0, 1, 2 for Left, Middle, Right respectively).
     * Note that the button parameter value may be different that the button value indicated in the event object
     * due to button re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleButtonDown = function(event, button) {
        return false;
    };

    /**
     * This method is called when a mouse button is released.
     * @param {MouseEvent} event - The event object that triggered this call.
     * @param {number} button - The button number that was released (0, 1, 2 for Left, Middle, Right respectively).
     * Note that the button parameter value may be different that the button value indicated in the event object
     * due to button re-mapping preferences that may be applied. This value should be respected
     * over the value in the event object.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleButtonUp = function(event, button) {
        return false;
    };

    /**
     * This method is called when a mouse motion event occurs.
     * @param {MouseEvent} event - The event object that triggered this call.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleMouseMove = function(event) {
        return false;
    };

    /**
     * This method is called when a touch gesture event occurs.
     * @param {Event} event - The event object that triggered this call. The event.type attribute will indicate
     * the gesture event type. This will be one of: dragstart, dragmove, dragend, panstart, panmove, panend,
     * pinchstart, pinchmove, pinchend, rotatestart, rotatemove, rotateend, drag3start, drag3move, drag3end.
     * The event.canvas[XY] attributes will contain the coresponding touch position.
     * The event.scale and event.rotation attributes contain pinch scaling and two finger rotation quantities
     * respectively. The deltaX and deltaY attributes will contain drag offsets.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleGesture = function(event) {
        return false;
    };

    /**
     * This method is called when the canvas area loses focus.
     * @param {FocusEvent} event - The event object that triggered this call.
     * @returns {boolean} True if this tool wishes to consume the event and false to continue to pass the event
     * to lower priority active tools.
     */
    this.handleBlur = function(event) {
        return false;
    };

    /**
     * This method is called on every active tool whenever the screen area changes.
     * The new canvas area can be obtained from the Navigation interface via the getScreenViewport method.
     * @see Autodesk.Viewing.Navigation
     */
    this.handleResize = function() {
    };
};



(function() {

/**
 * Mobile callbacks wrapper, consolidating all calls to iOS and Android platforms
 */
AutodeskNamespace('Autodesk.Viewing');

function MobileCallbacks () {
    this.ios = window.webkit;
    this.android = window.JSINTERFACE;

    this.iosSend = function (commandName, args){
        return window.webkit.messageHandlers.callbackHandler.postMessage({'command': commandName, 'data': args});
    };

    this.androidSend = window.JSINTERFACE;
}

var proto = MobileCallbacks.prototype;

proto.animationReady = function () {
    if (this.ios)
        this.iosSend('animationReady');
    else if (this.android)
        this.androidSend.animationReady();
};

proto.onSelectionChanged = function (dbId) {
    if (this.ios)
        this.iosSend('selectionChanged', dbId);
    else if (this.android)
        this.androidSend.onSelectionChanged(dbId);
};

proto.onLongTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onLongTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onLongTap(clientX, clientY);
};

proto.onSingleTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onSingleTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onSingleTap(clientX, clientY);
};

proto.onDoubleTap = function (clientX, clientY) {
    if (this.ios)
        this.iosSend('onDoubleTap', [clientX, clientY]);
    else if (this.android)
        this.androidSend.onDoubleTap(clientX, clientY);
};

proto.setRTCSession = function (id){
    if (this.ios)
        this.iosSend('setRTCSession', {'id':id});
    else if (this.android)
        this.androidSend.setRTCSessionID(id);
};

proto.putProperties = function (name, value){
    if (this.ios)
        this.iosSend('putProperties', {'name':name, 'value':value});
    else if (this.android)
        this.androidSend.putProperties(name, value);
};

proto.onPropertyRetrievedSuccess = function (){
    if (this.ios)
        this.iosSend('onPropertyRetrievedSuccess');
    else if (this.android)
        this.androidSend.onPropertyRetrievedSuccess();
};

proto.onPropertyRetrievedFailOrEmptyProperties = function (){
    if (this.ios)
        this.iosSend('onPropertyRetrievedFailOrEmptyProperties');
    else if (this.android)
        this.androidSend.onPropertyRetrievedFailOrEmptyProperties();
};

proto.resetAnimationStatus = function (){
    if (this.ios)
        this.iosSend('resetAnimationStatus');
    else if (this.android)
        this.androidSend.resetAnimationStatus();
};

proto.setPauseUI = function (){
    if (this.ios)
        this.iosSend('setPauseUI');
    else if (this.android)
        this.androidSend.setToPaused();
};

proto.getDeviceAvailableMemory = function () {
    // Returns a JSON in the format of:
    // {"platform": "Android", "device": "hammerhead", "model": "Nexus 5", "os": "6.0", "totalmem": 1945100288, "availbytes": 907812864}
    if (this.ios)
        return this.iosSend('getDeviceAvailableMemory');
    else if (this.android)
        return this.androidSend.getDeviceAvailableMemory();
}

proto.onDeviceMemoryInsufficient = function () {
    if (this.ios)
        return this.iosSend('onDeviceMemoryInsufficient');
    else if (this.android)
        return this.androidSend.onDeviceMemoryInsufficient();
}

proto.updateAnimationTime = function (time){
    if (this.ios)
        this.iosSend('updateAnimationTime', time);
    else if (this.android)
        this.androidSend.updateAnimationTime(time);
};


proto.setLoadingProgress = function (state, progress){
    if (this.ios)
        this.iosSend('setLoadingProgress', {'state':state, 'progress':progress});
    else if (this.android)
        this.androidSend.setLoadingProgress(state, progress);
};

proto.objectTreeCreated = function (){
    if (this.ios)
        this.iosSend('objectTreeCreated');
    else if (this.android)
        this.androidSend.objectTreeCreated();
};

proto.geometryLoaded = function (){
    if (this.ios)
        this.iosSend('geometryLoaded');
    else if (this.android)
        this.androidSend.geometryLoaded();
};

proto.putSheets = function (geomName, geomGuid){
    if (this.ios)
        this.iosSend('putSheets', [geomName, geomGuid]);
    else if (this.android)
        this.androidSend.putSheets(geomName, geomGuid);
};

proto.putAllSheets = function (sheets) {
    if (this.ios)
        this.iosSend('putAllSheets', sheets);
    else if (this.android)
        this.androidSend.putAllSheets(sheets);
};

proto.hideLoadingView = function (){
    if (this.android)
        this.androidSend.hideLoadingView();
};

proto.instanceTree = function (treeJson){
    if(this.ios)
        this.iosSend('instanceTree', treeJson);
    else if (this.android)
        this.androidSend.instanceTree(treeJson);
};

proto.loadSheetFailed = function (){
    if(this.ios)
        this.iosSend('loadSheetFailed');
    else if(this.android)
        this.androidSend.loadSheetFailed();
};

proto.sheetSelected = function (sheet) {
    if(this.ios)
        this.iosSend('sheetSelected', sheet);
    else if (this.android)
        this.androidSend.sheetSelected(sheet);
}

Autodesk.Viewing.MobileCallbacks = MobileCallbacks;
window.MobileCallbacks = MobileCallbacks; // Backwards compatibility. Consider removing.

})();

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Formats a value with units
 * @param {number} value
 * @param {string} units - GNU units format
 * @param {number} type - For example: 1=boolean, 2=integer, 3=double, 20=string, 24=Position
 * @param {number} precision - required precision.
 * see https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h
 * @returns {string} formatted value
 */
Autodesk.Viewing.Private.formatValueWithUnits = function (value, units, type, precision) {

    function modf(x) {
        var intPart = (0 <= x) ? Math.floor(x) : Math.ceil(x),
            fracPart = x - intPart;
        return {intPart: intPart, fracPart: fracPart};
    }

    function formatNumber(x, precision, needMinusSign) {
        var result = '';

//        // Change -0.0 to 0.0
//        if (x === 0.0) {
//            x = 0.0;
//        }

        if (needMinusSign && x === 0) {
            result += '-';
        }

        //According to Shawn's request, do not truncate trailing .0's
        //if (modf(x).fracPart === 0) {
        //
        //    // No fractional part.
        //    //
        //    result += x;
        //
        //} else if (0 < precision) {
        if (0 < precision) {

            // Truncate any trailing .0's.
            //
            //var s = x.toFixed(precision);
            //var re = /^\-?([0-9]+)\.0+$/;
            //var m = re.exec(s);
            //if (m !== null) {
            //    result += m[1];
            //} else {
            //    result += s;
            //}

            result += x.toFixed(precision);

        } else {
            result += x.toFixed(0);
        }

        return result;
    }

    function formatFeet(value, precision, inchesOnly) {

        // Borrowed from AdCoreUnits PrimeDoublePrimeSymbol2::Format

        var result = '',
            radix = 12.0,
            denominator = 1.0,
            isNegative = (value < 0);

        for (var i = 0; i < precision; ++i) {
            denominator *= 2.0;
        }

        // round to the nearest 1/denominator
        if (value > 0) {
            value += 0.5/denominator;
        } else {
            value -= 0.5/denominator;
        }

        var primeValue, doublePrimeValue;

        if (!inchesOnly) {
            primeValue = modf(value/radix).intPart;
            result += formatNumber(primeValue, 0, isNegative) + '\' ';
            doublePrimeValue = value - (primeValue * radix);
            if (doublePrimeValue < 0) {
                doublePrimeValue = -doublePrimeValue;
            }

        } else {
            doublePrimeValue = value;
        }

        var intPart = modf(doublePrimeValue).intPart;
        var numerator = modf((doublePrimeValue - intPart) * denominator).intPart;

        if (numerator === 0 || intPart !== 0) {
            result += formatNumber(intPart, 0);
        }

        if (numerator !== 0) {
            if (intPart < 0 && numerator < 0) {
                numerator = -numerator;
            }
            while (numerator % 2 === 0) {
                numerator /= 2;
                denominator /= 2;
            }
            if (intPart !== 0) {
                result += '-';
            }
            result += formatNumber(numerator, 0) + '/' + formatNumber(denominator, 0);
        }

        result += '\"';
        return result;
    }

    function formatMeterAndCentimeter(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            mValue = modfValue.intPart,
            cmValue = modfValue.fracPart * 100.0;

        return sign + formatNumber(mValue, 0) + ' m ' + formatNumber(cmValue, precision) + ' cm';
    }

    function formatFeetAndDecimalInches(value, precision) {
        var sign = '';
        if (value < 0) {
            sign = '-';
            value = Math.abs(value);
        }
        var modfValue = modf(value),
            ftValue = modfValue.intPart,
            inValue = modfValue.fracPart * 12.0;

        return sign + formatNumber(ftValue, 0) + '\' ' + formatNumber(inValue, precision) + '\"';
    }

    var result;

    if (precision === null || precision === undefined) {
        precision = 3;
    }

    // TODO(go) - 20150504: Ideally this would be handled better: according to the git file at the top property types can be 0,1,2,3,10,11,20,21,22,23,24
    // TODO(go) - 20150504: The code below only handle Boolean (1) Integer (2) and double (3). Not sure how well the property types are assigned so using
    // TODO(go) - 20150504: try catch for now.
    try {

        if (type === 1) { // Boolean
            result = Autodesk.Viewing.i18n.translate(value ? 'Yes' : 'No');

        } else if (type === 24) { // Position
            var position = value.split(' ');
            result = [];

            for(var i = 0; i < position.length; ++i) {
                result.push(Autodesk.Viewing.Private.formatValueWithUnits(parseFloat(position[i]), units, 3, precision));
            }

            result = result.join(', ');

        } else if ((type === 2 || type === 3) && isNaN(value)) {
            result = 'NaN';

        } else if (units === 'ft-and-fractional-in') {
            result = formatFeet(value * 12.0, precision);

        } else if (units === 'ft-and-fractional-in^2') {
            result = formatFeet(value * 12.0, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'ft-and-decimal-in') {
            result = formatFeetAndDecimalInches(value, precision);

        } else if (units === 'ft-and-decimal-in^2') {
            result = formatFeetAndDecimalInches(value, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'decimal-in' || units === 'in' || units === 'inch') {
            result = formatNumber(value, precision) + '\"';

        } else if (units === 'decimal-in^2' || units === 'in^2' || units === 'inch^2') {
            result = formatNumber(value, precision) + '\"' + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'decimal-ft' || units === 'ft' || units === 'feet' || units === 'foot') {
            result = formatNumber(value, precision) + '\'';

        } else if (units === 'decimal-ft^2' || units === 'ft^2' || units === 'feet^2' || units === 'foot^2') {
            result = formatNumber(value, precision) + '\'' + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'fractional-in') {
            result = formatFeet(value, precision, /*inchesOnly=*/true);

        } else if (units === 'fractional-in^2') {
            result = formatFeet(value, precision, /*inchesOnly=*/true) + ' ' + String.fromCharCode(0xb2);

        } else if (units === 'm-and-cm') {
            result = formatMeterAndCentimeter(value, precision);

        } else if (units === 'm-and-cm^2') {
            result = formatMeterAndCentimeter(value, precision) + ' ' + String.fromCharCode(0xb2);

        } else if (type === 3 && units) { // Double, with units
            units = units.replace("^2", String.fromCharCode(0xb2));
            units = units.replace("^3", String.fromCharCode(0xb3));
            result = formatNumber(value, precision) + ' ' + units;

        } else if (units) {
            result = value + ' ' + units;

        } else if (type === 3) { // Double, no units
            result = formatNumber(value, precision);

        } else {
            result = value;
        }

    } catch (e) {

        if (units) {
            result = value + ' ' + units;
        } else {
            result = value;
        }
    }

    return result;
};

/**
 * Convert distance from unit to unit.
 * @param {string} fromUnits - GNU units format - units to convert from
 * @param {string} toUnits - GNU units format - units to convert to
 * @param {number} calibrationFactor - Calibration Factor of the model
 * @param {number} d - distance to convert
 * @param {string} type - default for distance, "square" for area
 * @returns {number} - distance after conversion.
 */
Autodesk.Viewing.Private.convertUnits = function (fromUnits, toUnits, calibrationFactor, d, type) {

    calibrationFactor = calibrationFactor ? calibrationFactor : 1;

    if (fromUnits === toUnits && calibrationFactor == 1)
        return d;

    var toFactor = 1;
    switch (toUnits) {
        case "mm": toFactor = 1000; break;
        case "cm": toFactor = 100; break;
        case "m" : toFactor = 1; break;
        case "in": toFactor = 39.37007874; break;
        case "ft": toFactor = 3.280839895; break;
        case "ft-and-fractional-in": toFactor = 3.280839895; break;
        case "ft-and-decimal-in": toFactor = 3.280839895; break;
        case "decimal-in": toFactor = 39.37007874; break;
        case "decimal-ft": toFactor = 3.280839895; break;
        case "fractional-in": toFactor = 39.37007874; break;
        case "m-and-cm": toFactor = 1; break;
    }

    var fromFactor = 1;
    switch (fromUnits) {
        case "mm": fromFactor = 0.001; break;
        case "cm": fromFactor = 0.01; break;
        case "m" : fromFactor = 1; break;
        case "in": fromFactor = 0.0254; break;
        case "ft": fromFactor = 0.3048; break;
        case "ft-and-fractional-in": fromFactor = 0.3048; break;
        case "ft-and-decimal-in": fromFactor = 0.3048; break;
        case "decimal-in": fromFactor = 0.0254; break;
        case "decimal-ft": fromFactor = 0.3048; break;
        case "fractional-in": fromFactor = 0.0254; break;
        case "m-and-cm": fromFactor = 1; break;
    }

    if (type === "square") {

        return (d * Math.pow(toFactor * fromFactor * calibrationFactor, 2));
    }
    return (d * toFactor * fromFactor * calibrationFactor);
};

/**
 * Count the number of digits after the floating point of a given number.
 * @param {string | number} number.
 * @returns {number} - number of digits after the floating point of the given number.
 */

Autodesk.Viewing.Private.calculatePrecision = function (number) {

    if (!number)
        return 0;

    var digits = number.toString().split(".")[1];
    return (digits && digits.length) || 0; 
};

/**
 * Class for creating and restoring viewer states.
 *
 * Main interactions come from methods
 * - {@link Autodesk.Viewing.Private.ViewerState#getState}
 * - {@link Autodesk.Viewing.Private.ViewerState#restoreState}
 * @tutorial viewer_state
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance used to operate on.
 * @constructor
 * @category Core
 */
Autodesk.Viewing.Private.ViewerState = function( viewer )
{
    var avp = Autodesk.Viewing.Private;

    /**
     * All-inclusive filter constant used when no filter is provided.
     * @type {boolean}
     * @private
     */
    var FILTER_ALL = true;


    /**
     * Returns a viewer state Object for the current viewer instance.
     *
     * @param {object} [filter] - Object with a structure similar to the output where
     * values are replaced with Booleans true/false indicating whether they should be stored or not.
     * @returns {object} Plain object describing the state of the viewer.
     * @tutorial viewer_state
     */
    this.getState = function( filter ) {

        var nav = viewer.navigation;
        var viewerState = {};

        // Adding level-0 properties
        viewerState["seedURN"] = this.getSeedUrn();


        // Object set, contains selection, isolation and explode value.
        var objectSet = viewerState["objectSet"];
        if (!Array.isArray(objectSet)) {
            viewerState["objectSet"] = objectSet = [];
        }
        // Spec call for these elements to grouped in an Object at an Array's index 0.
        // 3d models attributes
        if(viewer.model && !viewer.model.is2d()) {
            objectSet[0] = {
                id: this.getSelectedNodes(),
                isolated: viewer.getIsolatedNodes(),
                hidden: viewer.getHiddenNodes(),
                explodeScale: viewer.getExplodeScale(),
                idType: 'lmv'
            };
        }
        // 2d models attributes
        if(viewer.model && viewer.model.is2d()) {
            objectSet[0] = {
                id: this.getSelectedNodes(), // Works for 2d and 3d
                isolated: this.getVisibleLayers2d(),
                allLayers: this.areAllLayersVisible(),
                hidden: [], // There's no hide feature for 2d.
                idType: 'lmv'
            };
        }

        // Viewport
        var viewport = viewerState["viewport"];
        if (!viewport) {
            viewport = viewerState["viewport"] = {};
        }
        
        var bPerspectiveCam = nav.getCamera().isPerspective;
        viewport["name"] = ""; // TODO: Populate accordingly; Requested by the mobile team.
        viewport["eye"] = nav.getPosition().toArray();
        viewport["target"] = nav.getTarget().toArray();
        viewport["up"] = nav.getCamera().up.toArray();
        viewport["worldUpVector"] = nav.getWorldUpVector().toArray();
        viewport["pivotPoint"] = nav.getPivotPoint().toArray();
        viewport["distanceToOrbit"] = nav.getPivotPlaneDistance();
        viewport["aspectRatio"] = this.getAspectRatio();
        viewport["projection"] = bPerspectiveCam ? "perspective" : "orthographic";
        viewport["isOrthographic"] = !bPerspectiveCam;
        if (bPerspectiveCam) {
            viewport["fieldOfView"] = nav.getVerticalFov();
        } else {
            viewport["orthographicHeight"] = this.getOrthographicHeight();
        }


        // Render Options
        var renderOptions = viewerState["renderOptions"];
        if (!renderOptions) {
            renderOptions = viewerState["renderOptions"] = {};
        }
        renderOptions["environment"] = avp.LightPresets[viewer.impl.currentLightPreset()].name;
        renderOptions["ambientOcclusion"] = {
            enabled: viewer.impl.renderer().getAOEnabled(),
            radius: viewer.impl.renderer().getAORadius(),
            intensity: viewer.impl.renderer().getAOIntensity()
        };
        renderOptions["toneMap"] = {
            method: viewer.impl.renderer().getToneMapMethod(),
            exposure: viewer.impl.renderer().getExposureBias(),
            lightMultiplier: this.getToneMapIntensity()
        };
        renderOptions["appearance"] = {
            ghostHidden: viewer.impl.showGhosting,
            ambientShadow: viewer.prefs.ambientShadows,
            antiAliasing: viewer.impl.renderer().settings.antialias,
            progressiveDisplay: viewer.prefs.progressiveRendering,
            swapBlackAndWhite: viewer.prefs.swapBlackAndWhite,
            displayLines: viewer.prefs.lineRendering,
            displayPoints: viewer.prefs.pointRendering
        };

        // Cutplanes (aka: Sectioning) are a 3d-only feature.
        if (viewer.model && !viewer.model.is2d()) {
            var cutplanes = viewerState["cutplanes"] = [];
            var planes = viewer.getCutPlanes();
            for (var i=0; i<planes.length; i++) {
                cutplanes.push(planes[i].toArray());
            }
        }

        // Allow extensions to inject their state data
        for (var extensionName in viewer.loadedExtensions) {
            var extension = viewer.loadedExtensions[extensionName];
            extension.getState && extension.getState(viewerState);
        }

        // Filter out values the user doesn't want to consume before returning.
        if (filter && filter !== FILTER_ALL) {
            this.applyFilter(viewerState, filter);
        }
        return viewerState;
    };


    /**
     * Restores the associated viewer instance with the provided viewerState object.
     *
     * @param {object} viewerState
     * @param {object} [filter] - Similar in structure to viewerState used to filter out values
     * that should not be restored.
     * @param {boolean} [immediate] - Whether the state should be apply with (false)
     * or without (true) a smooth transition.
     * @returns {boolean} True if the operation was successful.
     * @tutorial viewer_state
     */
    this.restoreState = function( viewerState, filter, immediate ) {

        if (!viewerState) {
            avp.logger.warn("restoreState has no viewer state to restore from.");
            return false;
        }

        if (!viewer || !viewer.model) {
            avp.logger.warn("restoreState has no viewer or model to restore.");
            return false;
        }

        if (filter && filter !== FILTER_ALL) {
            // To avoid modifying viewerState passed in, we create a clone of it
            viewerState = JSON.parse(JSON.stringify(viewerState));
            this.applyFilter(viewerState, filter);
        }

        var nav = viewer.navigation;
        var isModel2d = viewer.model.is2d();
        var isModel3d = !isModel2d;

        // Objectset
        if (Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];

            // Selection (2d and 3d)
            var selectionIds = objectSet.id;
            if (selectionIds) {
                selectionIds = this.toIntArray(selectionIds);
                viewer.select(selectionIds);
            }

            // Isolation / Hidden depends on whether it is 2d or 3d
            if (isModel2d) {

                // 2d Isolation is Layer visibility
                var visibleLayers = objectSet.isolated;
                if (Array.isArray(visibleLayers) && visibleLayers.length > 0) {
                    // Only certain layers are visible
                    viewer.setLayerVisible(null, false); // start by hiding all
                    viewer.impl.setLayerVisible(visibleLayers, true);
                } else {
                    // All layers are visible
                    viewer.setLayerVisible(null, true);
                }
            } else {
                // 3d Isolation
                var isolatedIds = objectSet.isolated || [];
                isolatedIds = this.toIntArray(isolatedIds);
                viewer.isolate(isolatedIds);

                // 3d Hidden nodes (only when there's no isolation) (3d only)
                if (isolatedIds.length === 0 ) {
                    var hiddenIds = objectSet.hidden || null;
                    if (hiddenIds && hiddenIds.length > 0) {
                        hiddenIds = this.toIntArray(hiddenIds);
                        viewer.hide(hiddenIds);
                    }
                }
            }

            // Explode scale (3d)
            if ("explodeScale" in objectSet) {
                var explodeScale = parseFloat(objectSet.explodeScale);
                if(viewer.explode) {
                    viewer.explode(explodeScale);
                }
            }
        }

        var viewport = viewerState.viewport;
        if (viewport) {

            var eye = this.getVector3FromArray(viewport.eye, nav.getPosition());
            var up = this.getVector3FromArray(viewport.up, nav.getCamera().up);
            var target = this.getVector3FromArray(viewport.target, nav.getTarget());
            var fov = ("fieldOfView" in viewport) ? parseFloat(viewport.fieldOfView) : nav.getVerticalFov();
            var worldUp = this.getVector3FromArray(viewport.worldUpVector, null);
            if (!worldUp) {
                var upVectorArray = viewer.model ? viewer.model.getUpVector() : null;
                if (upVectorArray) {
                    worldUp = new THREE.Vector3().fromArray(upVectorArray);
                } else {
                    worldUp = new THREE.Vector3(0,1,0); // TODO: Can we do better? Is it worth it?
                }
            }
            var pivot = this.getVector3FromArray(viewport.pivotPoint, nav.getPivotPoint());

            // Retain current values if not available in restore object
            var isPerspective = nav.getCamera().isPerspective;
            if ('isOrthographic' in viewport) {
                isPerspective = !viewport.isOrthographic;
            }
            var orthoScale = this.getOrthographicHeight();
            if ('orthographicHeight' in viewport) {
                orthoScale = Number(viewport.orthographicHeight);
            }

            var camera = {
                position: eye,
                target: target,
                up: up,
                worldup: worldUp,
                aspect: viewer.impl.camera.aspect,
                fov: fov,
                orthoScale: orthoScale,
                isPerspective: isPerspective,
                pivot: pivot
            };

            this.restoreCameraState(camera, immediate);
        }


        // Render option state
        var renderOptions = viewerState.renderOptions;
        if (renderOptions) {

            // current values
            var renderer = viewer.impl.renderer();
            var prefs = viewer.prefs;
            var saoEnabled = prefs.ambientShadows;
            var antiAliasing = prefs.antialiasing;

            var sao = renderOptions.ambientOcclusion;
            if (sao) {
                if ("enabled" in sao) {
                    saoEnabled = sao.enabled;
                }
                var saoRadius = ("radius" in sao) ? sao.radius : null;
                var saoIntensity = ("intensity" in sao) ? sao.intensity : null;
                if (saoRadius !== null && saoIntensity !== null) {
                    if (saoRadius !== renderer.getAORadius() ||
                        saoIntensity !== renderer.getAOIntensity()) {
                        renderer.setAOOptions(saoRadius, saoIntensity);
                        renderer.composeFinalFrame();
                    }
                }
            }

            if ("environment" in renderOptions) {
                var lightPresetIndex = this.getLightPresetIndex(renderOptions.environment);
                if (lightPresetIndex !== -1 && lightPresetIndex !== prefs.get('lightPreset') && isModel3d) {
                    viewer.setLightPreset(lightPresetIndex);
                }
            }

            // ToneMap values are overrides to the environment settings.
            var toneMap = renderOptions.toneMap;
            if (toneMap) {
                var invalidate = false;
                var exposure = "exposure" in toneMap ? toneMap.exposure : null;
                var toneMapIntensity = "lightMultiplier" in toneMap ?  toneMap.lightMultiplier : null;

                if (exposure !== null && exposure !== renderer.getExposureBias()) {
                    renderer.setTonemapExposureBias(exposure);
                    invalidate = true;
                }

                if (toneMapIntensity !== null && viewer.impl.dir_light1 && toneMapIntensity !== this.getToneMapIntensity()) {
                    viewer.impl.dir_light1.intensity = Math.pow(2.0, toneMapIntensity);
                    invalidate = true;
                }

                if (invalidate) {
                    viewer.impl.invalidate(true);
                }
            }

            var appearance = renderOptions.appearance;
            if (appearance) {
                if ("antiAliasing" in appearance) {
                    antiAliasing = appearance.antiAliasing;
                }
                if ("progressiveDisplay" in appearance && appearance.progressiveDisplay !== prefs.get('progressiveRendering')) {
                    viewer.setProgressiveRendering(appearance.progressiveDisplay);
                }
                if ("swapBlackAndWhite" in appearance && appearance.swapBlackAndWhite !== prefs.get('swapBlackAndWhite')) {
                    viewer.setSwapBlackAndWhite(appearance.swapBlackAndWhite);
                }
                if (("ghostHidden" in appearance) && appearance.ghostHidden !== prefs.get('ghosting')) {
                    isModel3d && viewer.setGhosting(appearance.ghostHidden);
                }
                if ("displayLines" in appearance && appearance.displayLines !== prefs.get('lineRendering')) {
                    viewer.hideLines(!appearance.displayLines);
                }
                if ("displayPoints" in appearance && appearance.displayPoints !== prefs.get('pointRendering')) {
                    viewer.hidePoints(!appearance.displayPoints);
                }
            }

            // SAO and AA at the end.
            if (isModel3d && saoEnabled !== prefs.ambientShadows && antiAliasing !== prefs.antialiasing) {
                viewer.setQualityLevel(saoEnabled, antiAliasing);
            }
        }

        // Restore cutplanes (aka: Sectioning) data only for 3d models.
        if (Array.isArray(viewerState.cutplanes) && viewer.model && isModel3d) {
            var cutplanes = [];
            for (var i=0; i<viewerState.cutplanes.length; i++) {
                var plane = viewerState.cutplanes[i];
                if (Array.isArray(plane) && plane.length >= 4) {
                    cutplanes.push(new THREE.Vector4(plane[0], plane[1], plane[2], plane[3]));
                }
            }
            viewer.setCutPlanes(cutplanes);
        }

        // Allow extensions to restore their data
        for (var extensionName in viewer.loadedExtensions) {
            var extension = viewer.loadedExtensions[extensionName];
            extension.restoreState && extension.restoreState(viewerState, immediate);
        }

        return true;
    };

    /**
     * Restores camera states values back into the viewer.
     * We avoid using methods such as setViewFromCamera() because those make some
     * assumptions about the current state of the viewer. We need no such things.
     *
     * Note: Implementation based on Viewer3DImpl.setViewFromCamera()
     *
     * @param {object} camera
     * @param {boolean} immediate
     * @private
     */
    this.restoreCameraState = function(camera, immediate) {

        viewer.impl.adjustOrthoCamera(camera);
        var navapi = viewer.navigation;

        if (!immediate) {
            // With animation
            viewer.impl.camera.isPerspective = camera.isPerspective;
            navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, camera.up, camera.worldup, camera.pivot);
        } else {
            // Instantaneous, no animation
            if (camera.isPerspective) {
                navapi.toPerspective();
            } else {
                navapi.toOrthographic();
            }
            navapi.setCameraUpVector(camera.up);
            navapi.setWorldUpVector(camera.worldup);
            navapi.setView(camera.position, camera.target);
            navapi.setPivotPoint(camera.pivot);
            navapi.setVerticalFov(camera.fov, false);

            viewer.impl.syncCamera(true);
        }
    };

    /**
     * Return true if two viewer states are equal, it's possible to compare only a subset of the objects providing a filter
     * as parameter.

     * @param {object} viewerStateA
     * @param {object} viewerStateB
     * @param {object} [filter] - Similar in structure to viewerState used to filter out values to check.
     * @returns {boolean} True if the states are equal.
     * @tutorial viewer_state
     */
    this.areEqual = function(viewerStateA, viewerStateB, filter) {

        function areArraysEqual(arrayA, arrayB) {

            arrayA = arrayA || [];
            arrayB = arrayB || [];

            if (arrayA.length !== arrayB.length) {
                return false;
            }

            for (var i = 0; i < arrayA.length; ++i) {
                if (arrayA[i] !== arrayB[i]) {
                    return false;
                }
            }

            return true;
        }

        function areVectorsEqual(vectorA, vectorB, epsilon) {

            vectorA = vectorA || [];
            vectorB = vectorB || [];

            if (vectorA.length !== vectorB.length) {
                return false;
            }

            if (vectorA.length === 0) {
                return false;
            }

            return (
                areNumbersEqual(vectorA[0], vectorB[0], epsilon) ||
                areNumbersEqual(vectorA[1], vectorB[1], epsilon) ||
                areNumbersEqual(vectorA[2], vectorB[2], epsilon));

        }

        function areNumbersEqual(numberA, numberB, epsilon) {

            var parcedA = numberA ? parseFloat(numberA) : null;
            var parcedB = numberA ? parseFloat(numberB) : null;

            var typeOfA = typeof(parcedA);
            var typeOfB = typeof(parcedB);

            if (typeOfA === 'number' && typeOfB === 'number') {
                return (Math.abs(numberA - numberB) < epsilon);
            }

            numberA = numberA ? numberA : null;
            numberB = numberB ? numberB : null;

            return numberA === numberB;
        }

        var stateA = viewerStateA;
        var stateB = viewerStateB;
        var epsilon = 0.000000001;

        if (filter && filter !== true) {
            stateA = this.applyFilter(stateA, filter);
            stateB = this.applyFilter(stateB, filter);
        }

        if (stateA["seedURN"] !== stateB["seedURN"]) {
            return false;
        }

        // Check object set (only check first element, the one written by ViewerState).
        var objectSetA = stateA["objectSet"] || [];
        var objectSetB = stateB["objectSet"] || [];

        if (objectSetA.length !== objectSetB.length) {
            return false;
        }

        var objectA = objectSetA[0] || {};
        var objectB = objectSetB[0] || {};

        if (
            objectA.idType !== objectB.idType ||
           !areNumbersEqual(objectA.explodeScale, objectB.explodeScale, epsilon) ||
           !areArraysEqual(objectA.id,  objectB.id) ||
           !areArraysEqual(objectA.isolated, objectB.isolated) ||
           !areArraysEqual(objectA.hidden, objectB.hidden)) {
            return false;
        }

        // Check Viewport.
        var viewportA = stateA["viewport"] || {};
        var viewportB = stateB["viewport"] || {};

        if (viewportA["name"] !== viewportB["name"] ||
            viewportA["projection"] !== viewportB["projection"] ||
            viewportA["isOrthographic"] !== viewportB["isOrthographic"] ||
           !areNumbersEqual(viewportA["distanceToOrbit"], viewportB["distanceToOrbit"], epsilon) ||
        // !areNumbersEqual(viewportA["aspectRatio"], viewportB["aspectRatio"], epsilon) ||
           !areNumbersEqual(viewportA["fieldOfView"], viewportB["fieldOfView"], epsilon) ||
           !areNumbersEqual(viewportA["orthographicHeight"], viewportB["orthographicHeight"], epsilon) ||
           !areVectorsEqual(viewportA["eye"], viewportB["eye"], epsilon) ||
           !areVectorsEqual(viewportA["target"], viewportB["target"], epsilon) ||
           !areVectorsEqual(viewportA["up"], viewportB["up"], epsilon) ||
           !areVectorsEqual(viewportA["worldUpVector"], viewportB["worldUpVector"], epsilon) ||
           !areVectorsEqual(viewportA["pivotPoint"], viewportB["pivotPoint"], epsilon)) {
            return false;
        }

        // Skip render options, cut planes and extension data.
        return true;
    };

    /**
     * Helper method with the intent to change the type of an array with ids from String to ints.
     * We need this method because we need to make sure that ids that get fed into the ViewerState
     * are in the correct type.
     *
     * @param {Array} array - For example, `["45", "33", "1"]`.
     * @returns {Array} For example, `[45, 33, 1]`.
     * @private
     */
    this.toIntArray = function( array ) {
        var ret = [];
        if (Array.isArray(array)) {
            for (var i= 0, len=array.length; i<len; ++i) {
                ret.push( parseInt(array[i]) );
            }
        }
        return ret;
    };

    /**
     * Helper function that given a viewer state, extracts the selected nodes.
     *
     * @param {object} viewerState - For example, the result of this.getState().
     * @returns {array} Array containing Number-typed ids of the selected nodes. Empty array when no 'selected'
     *                 objectSet value is defined.
     * @private
     * @deprecated
     */
    this.extractSelectedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            return this.toIntArray(objectSet.id);
        }
        return [];
    };

    /**
     * Helper function that given a viewer state, extracts the isolated nodes.
     *
     * @param {object} viewerState - For example, the result of this.getState().
     * @return {array} Array containing Number-typed ids of the isolated nodes. Empty array when no 'isolated'
     * objectSet value is defined.
     * @private
     * @deprecated
     */
    this.extractIsolatedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            return this.toIntArray(objectSet.isolated);
        }
        return [];
    };

    /**
     * Helper method that constructs a Vector3 from a given Array.
     * If Array is not well-formed, then the failValue is return instead.
     *
     * @param {array} array - An array with 3 values.
     * @param {THREE.Vector3} failValue - If array param is invalid, failValue will be returned instead.
     * @returns {THREE.Vector3} Either a new Vector with values coming from 'array' or failValue.
     * @private
     */
    this.getVector3FromArray = function(array, failValue) {

        if (array instanceof Array && array.length > 2) {

            // Some array values are exported as string-of-numbers. Fix that here.
            array[0] = parseFloat(array[0]);
            array[1] = parseFloat(array[1]);
            array[2] = parseFloat(array[2]);
            return new THREE.Vector3().fromArray(array);
        }
        return failValue;
    };

    /**
     * Helper function that returns selected node ids in an array.
     * @returns {array}
     * @private
     */
    this.getSelectedNodes = function() {

        return viewer.impl && viewer.impl.selector ? viewer.impl.selector.getSelection() : [];

    };

    /**
     * Helper function that returns the index values of the isolated (visible) layers.
     * Applies only to 2d models/blueprints
     * @private
     */
    this.getVisibleLayers2d = function() {
        var ret = [];
        var materialManager = viewer.impl.matman();
        var layersMap = materialManager._layersMap; // TODO: don't access internal members of matman
        for (var layerIndex in layersMap) {
            if (layersMap.hasOwnProperty(layerIndex)) {
                if (materialManager.isLayerVisible(layerIndex)){
                    ret.push(layerIndex);
                }
            }
        }
        return ret;
    };

    /**
     * Helper function that returns true if all layers are visible.
     * Applies only to 2d models/blueprints
     * @private
     */
    this.areAllLayersVisible = function() {
        var materialManager = viewer.impl.matman();
        var layersMap = materialManager._layersMap; // TODO: don't access internal members of matman
        for (var layerIndex in layersMap) {
            if (layersMap.hasOwnProperty(layerIndex)) {
                if (!materialManager.isLayerVisible(layerIndex)){
                   return false;
                }
            }
        }
        return true;
    };

    /**
     * Gets the aspect ratio.
     * @returns {number} Aspect ratio.
     * @private
     */
    this.getAspectRatio = function() {
        var viewport = viewer.navigation.getScreenViewport();
        var aspect = viewport.width / viewport.height;
        return aspect;
    };

    /**
     * Returns world height when in orthographic camera mode.
     * @returns {number} Orthographic height.
     * @private
     */
    this.getOrthographicHeight = function() {
        var cam = viewer.navigation.getCamera();
        if (cam.isPerspective) return 0;
        return Math.abs(2 * cam.orthographicCamera.top);
    };

    /**
     * Returns the URN of the document model.
     * @returns {string} Model URN.
     */
    this.getSeedUrn = function() {
        if (viewer.model && viewer.model.loader) {
            return viewer.model.loader.svfUrn || "";
        }
        return "";
    };

    /**
     * Returns the slider value for the viewer's current light intensity.
     * @returns {number}
     * @private
     */
    this.getToneMapIntensity = function () {

        // Original code from RenderOptionsPanel.js
        // Should probably live elsewhere in the api.
        var intensity = 0.0;
        if (viewer.impl.dir_light1) {
            if (viewer.impl.dir_light1.intensity != 0)
                intensity = Math.log(viewer.impl.dir_light1.intensity)/Math.log(2.0);
            else
                intensity = -1e-20;
        }
        return intensity;
    };

    /**
     * Returns the index of the LightPreset with a matching name value.
     * @param environmentName
     * @returns {number} Index of LightPreset, or -1 if not found.
     * @private
     */
    this.getLightPresetIndex = function ( environmentName ) {

        for (var i=0; i<avp.LightPresets.length; i++) {
            if (avp.LightPresets[i].name === environmentName) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Filters out key/value pairs from the viewerState.
     *
     * To get all of the values available use FILTER_ALL. If no filter is provided FILTER_ALL will be used.
     * It is encourage for consumers to define their specialized filters.
     *
     * @param {object} viewerState - Object to be filtered.
     * @param {object} filter - Object with a similar structure to viewerState, where values are Booleans signaling which
     * elements should be included (true) and which ones should not (false).
     * If a viewerState key is not found in the filter, we assume that it is non-wanted.
     * @private
     */
    this.applyFilter = function( viewerState, filter ) {

        // Check the 'ALL' filter
        if (filter === true) return;

        // Filtering only 1 level depth keys
        // Additional levels are checked recursively.
        for (var key in viewerState) {

            if (!viewerState.hasOwnProperty(key)) {
                continue;
            }

            // Try to find the key in the filter object
            var filterValue = filter[key];

            if (filterValue === undefined) {

                // key not enabled in filter, remove key/value pair from viewerState.
                delete viewerState[key];
                avp.logger.log("[applyFilter] C - skipping key [" + key + "] from viewerState; unspecified in filter.");
            }
            else if (typeof(filterValue) === 'boolean') {

                if (filterValue === false) {
                    // key explicitly flagged for removal, remove key/value pair from viewerState.
                    delete viewerState[key];
                    avp.logger.log("[applyFilter] D - skipping key [" + key + "] from viewerState; explicit filtering.");
                }
            }
            else if (filterValue instanceof Object) {

                if (viewerState[key] instanceof Object) {
                    // Both are Objects, recursive call on them.
                    this.applyFilter(viewerState[key], filter[key]);
                } else {
                    // This case signals a miss-match between filter and value.
                    // Since it's an undefined case, we'll be inclusive for the time being.
                    // *** Keep the value in viewerState ***
                    avp.logger.warn("[applyFilter] A - Invalid filter Object for key [" + key + "]");
                }
            }
            else {

                // Note: Every other value for filter is invalid.
                // For now, we'll keep the key/value in viewerState.
                avp.logger.warn("[applyFilter] B - Invalid filter value for key [" + key + "]");
            }

        }
    };

};

Autodesk.Viewing.Private.ViewerState.prototype.constructor = Autodesk.Viewing.Private.ViewerState;


/**
 * Application preferences.
 *
 * Optionally uses web storage.
 *
 * Each preference value can have tags associated to them. Developer supported tags are:
 * - 'ignore-producer'
 * - 'no-storage'
 * - '2d'
 * - '3d'
 *
 * Use tag 'ignore-producer' in extensions to avoid having developer-defined
 * render settings overridden by the loaded file.
 *
 * Use tag 'no-storage' in extensions to avoid having User Preferences (from Settings Panel) override
 * default or developer-defined preferences. Useful for render settings.
 *
 * Preferences may apply to all model types, only 2D models (with tag '2d') or 3D models only (with tag '3d').
 *
 * @constructor
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
 * @param {object} options - Contains configuration parameters used to do initializations.
 * @param {boolean} [options.localStorage] - Whether values get stored and loaded back
 * from localStorage. Defaults to `true`.
 * @param {string} [options.prefix] - A string to prefix preference names in web storage.
 * Defaults to `'Autodesk.Viewing.Preferences.'`.
 * @category Core
 */
Autodesk.Viewing.Private.Preferences = function (viewer, options) {

    // Backwards compatibility for when the 2nd argument was 'prefix' string
    if (typeof options === 'string') {
        options = {
            prefix: options
        }
    }
    if (!options) {
        options = {};
    }

    if (!options.prefix) {
        options.prefix = 'Autodesk.Viewing.Preferences.';
    }
    if (!options.hasOwnProperty('localStorage')) {
        options.localStorage = true;
    }

    var av = Autodesk.Viewing;
    var avp = Autodesk.Viewing.Private;

    // from stackoverflow:
    // http://stackoverflow.com/questions/14555347/html5-localstorage-error-with-safari-quota-exceeded-err-dom-exception-22-an
    //
    function isLocalStorageSupported() {
        var testKey = options.prefix + 'test';
        try {
            var storage = window.localStorage; // This may assert if browsers disallow sites from setting data.
            storage.setItem(testKey, '1');
            storage.removeItem(testKey);
            return true;

        } catch (error) {
            return false;
        }
    }

    var defaults = {}, // Default values
        callbacks = {}, // Changed and Reset listeners
        tags = {},
        useLocalStorage = options.localStorage && isLocalStorageSupported(),
        that = this;

    // TODO: callbacks should be array, not single
    // Would need to deal with issue of registering same callback twice
    //
    viewer.addEventListener(av.PREF_CHANGED_EVENT, function (event) {
        var callbacksForName = callbacks[event.name];
        if (callbacksForName) {
            var callback = callbacksForName.changed;
            if (callback) {
                callback(event.value);
            }
        }
    });

    viewer.addEventListener(av.PREF_RESET_EVENT, function (event) {
        var callbacksForName = callbacks[event.name];
        if (callbacksForName) {
            var callback = callbacksForName.reset;
            if (callback) {
                callback(event.value);
            }
        }
    });

    viewer.addEventListener(av.RESTORE_DEFAULT_SETTINGS_EVENT, function (event) {
        var tag = viewer.model.is2d() ? '2d' : '3d';
        that.reset(tag);
    });

    /**
     * Get/set preference value in web storage.
     * No-Op if tag 'no-storage' is associated to the name.
     * @param {string} name - Preference name.
     * @param {*} [value] - Preference value.
     * @returns {*} Preference value or undefined if not available.
     * @private
     */
    function webStorage(name, value) {
        if (useLocalStorage) {

            // Avoid storage for 'no-storage' tags
            if (that.hasTag(name, 'no-storage')) {
                return undefined;
            }

            // Prefix our names, so we don't pollute the localStorage of the embedding application
            var prefixedName = options.prefix + name;

            if (typeof(value) !== "undefined") {
                // If value is specified, we set this value in localStorage
                localStorage[prefixedName] = value;

            } else {
                // If no value is specified we return the value from localStorage
                value = localStorage[prefixedName];
            }
            return value;
        }
        return undefined;
    }

    /**
     * Adds a preference name + default value, tries to load value from web storage.
     * @param {string} name
     * @param {*} defaultValue
     * @private
     */
    function addPref(name, defaultValue) {
        if (typeof name !== 'string' || typeof that[name] === 'function') {
            avp.logger.log('Preferences: invalid name=' + name);
            return;
        }

        // Use default if nothing in web storage.
        //
        var value = webStorage(name);
        var ok = false;

        if (value !== undefined) {
            try {
                value = JSON.parse(value);
                ok = true;
            } catch (e) {
            }
        }
        that[name] = ok ? value : defaultValue;
        tags[name] = {};
    }

    /**
     * Load preference values from web storage/defaults.
     * @param {object} defaultValues - Preference names and their default values.
     */
    this.load = function (defaultValues) {
        defaults = defaultValues;
        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                addPref(name, defaults[name]);
            }
        }
    };

    /**
     * Adds a tag to the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {string[]|string} [names] - Preference names, default all preferences.
     */
    this.tag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = true;
            }
        }
    };

    /**
     * Removes a tag from the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {string[]|string} [names] - Preference names, default all preferences.
     */
    this.untag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = false;
            }
        }
    };

    /**
     * Checks whether a tag is associated to a name
     * @param {string} name - Preference name
     * @param {string} tag - The tag to check for
     */
    this.hasTag = function(name, tag) {
        var nameKey = tags[name];
        if (nameKey) {
            return nameKey[tag] === true;
        }
        return false;
    };

    /**
     * Adds a new preference name + default value.
     * This preference was not previously loaded via load().
     * @param {string} name - Preference name.
     * @param {*} defaultValue - Preference default value.
     * @param {string[]|string} [tags] - Optional tags.
     * @returns {boolean} True if the preference was added.
     */
    this.add = function (name, defaultValue, tags) {
        if (defaults.hasOwnProperty(name)) {
            avp.logger.log("Preferences: " + name + " already exists");

        } else {
            defaults[name] = defaultValue;
            addPref(name, defaultValue);

            if (tags) {
                if (!Array.isArray(tags)) {
                    tags = [tags];
                }
                for (var i = 0; i < tags.length; ++i) {
                    this.tag(tags[i], name);
                }
            }
            return true;
        }
        return false;
    };

    /**
     * Removes an existing preference.
     * @param {string} name - Preference name.
     * @param {boolean} [removeFromWebStorage=false] - True to clear the web storage entry for this preference.
     * @returns {boolean} True if the preference was removed.
     */
    this.remove = function (name, removeFromWebStorage) {
        if (defaults.hasOwnProperty(name)) {
            delete defaults[name];
            delete tags[name];
            delete this[name];

            if (removeFromWebStorage) {
                deleteFromWebStorage(name);
            }

            return true;
        }
        return false;
    };

    function deleteFromWebStorage(name) {
        if (useLocalStorage) {
            name = options.prefix + name;
            delete localStorage[name];
        }
    }

    /**
     * Reset preferences to default values.
     * If a tag is specified, then only certain preferences are reset.
     * @param {string} [tag] Optional tag.
     * @param {boolean} [include=true] True to reset only preferences with matching tags.
     */
    this.reset = function (tag, include) {
        if (tag && include === undefined) {
            include = true;
        }

        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                if (tag) {
                    var tagged = !!tags[name][tag];
                    if ((include && !tagged) || (!include && tagged)) {
                        continue;
                    }
                }

                if (this.set(name, defaults[name], false)) {
                    viewer.dispatchEvent({
                        type: av.PREF_RESET_EVENT,
                        name: name,
                        value: this[name]
                    });
                }

                deleteFromWebStorage(name);
            }
        }
    };

    /**
     * Get named preference value.
     * Shortcut: prefs[name]
     * @returns {*} Preference value.
     */
    this.get = function (name) {
        return this[name];
    };

    /**
     * Set named preference value.
     * Value is not persisted if tag 'no-storage' is set.
     * Do not use shortcut prefs[name] = value.
     * @param {string} name - Preference name.
     * @param {*} value - Preference value.
     * @param {boolean} [notify=true] - If true then av.PREF_CHANGED_EVENT is fired.
     * @returns {boolean} True if the value changed, false otherwise.
     */
    this.set = function (name, value, notify) {
        // Updates the cached value as well as the value in the web storage
        if (this[name] !== value) {
            this[name] = value;
            webStorage(name, value);

            if (notify === undefined || notify) {
                viewer.dispatchEvent({
                    type: av.PREF_CHANGED_EVENT,
                    name: name,
                    value: value
                });
            }

            return true;
        }
        return false;
    };

    /**
     * Listen for preference changed and reset events.
     * @param {string} name - Preferences name.
     * @param {function} onChangedCallback - Function called when preferences are changed.
     * @param {function} onResetCallback - Function called when preferences are reset.
     */
    this.addListeners = function (name, onChangedCallback, onResetCallback) {
        callbacks[name] = {changed: onChangedCallback, reset: onResetCallback};
    };

    /**
     * Remove listeners for preference changed and reset events.
     * @param {string} name - Preferences name.
     */
    this.removeListeners = function(name) {
        if(callbacks[name] !== undefined) {
            delete callbacks[name];
        }
    };
};


(function() {

"use strict";

/**
 * Base class for extending the functionality of the viewer.
 *
 * Derive from this class and implement the load and optionally the unload methods.
 *
 * Register this extension by calling:
 * `Autodesk.Viewing.theExtensionManager.registerExtension('your_extension_id', Autodesk.Viewing.Extensions.<your_extension_class>); `
 *
 * Extensions are registered and loaded automatically by adding the Extension ID to the
 * config object passed to the viewer constructor.
 *
 * An example Extension is available at derivativeservice/v2/viewers/SampleExtension/, and includes
 * these files:
 * * SampleExtension.js
 * * SampleLayersPanel.js
 * * SampleModelStructurePanel.js
 * * SamplePropertyPanel.js
 * * SampleLayersPanel.css
 * * SampleModelStructurePanel.css
 * * SamplePropertyPanel.css
 *
 * @constructor
 * @alias Autodesk.Viewing.Extension
 * @param {Autodesk.Viewing.Viewer3D} viewer - The viewer to be extended.
 * @param {object} options - An optional dictionary of options for this extension.
 * @category Core
 */
var Extension = function (viewer, options) {
    this.viewer = viewer;
    this.options = options;
    this.id = ''; // Populated by theExtensionManager
};

/**
 * Override the load method to add functionality to the viewer.
 * Use the Viewer's APIs to add/modify/replace/delete UI, register event listeners, etc.
 * @returns {boolean} True if the load was successful.
 */
Extension.prototype.load = function () {
    return true;
};

/**
 * Override the unload method to perform some cleanup of operations that were done in load.
 * @returns {boolean} True if the unload was successful.
 */
Extension.prototype.unload = function () {
    return true;
};

/**
 * Gets the extension state as a plain object. Intended to be called when viewer state is requested.
 * @param {object} viewerState - Object to inject extension values.
 * @virtual
 */
Extension.prototype.getState = function( viewerState ) {
};

/**
 * Restores the extension state from a given object.
 * @param {object} viewerState - Viewer state.
 * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).
 * @returns {boolean} True if restore operation was successful.
 * @virtual
 */
Extension.prototype.restoreState = function (viewerState, immediate) {
    return true;
};

/**
 * Override the set of localized strings
 * @param {object} locales The set of localized strings keyed by language
 * @returns {boolean} True if localization was successfully updated
 */
Extension.prototype.extendLocalization = function (locales) {
    return Autodesk.Viewing.Private.extendLocalization(locales);
};


/**
 * Returns an object that persists throughout an extension's unload->load
 * operation sequence. Cache object is kept at ViewingApplication level.
 * Cache object lives only in RAM, there is no localStorage persistence.
 * @returns {object} The cache object for a given extension.
 */
Extension.prototype.getCache = function() {
    if (!this.viewer.extensionCache) {
        // Create one at runtime. It won't be useful, but it
        // will make the object easier to use.
        this.viewer.extensionCache = {};
        Autodesk.Viewing.Private.logger.warn('Extension cache runtime creation; missing ViewingApplication context.');
    }
    var cache = this.viewer.extensionCache[this.id];
    if (!cache) {
        cache = this.viewer.extensionCache[this.id] = {};
    }
    return cache;
};

Autodesk.Viewing.Extension = Extension;

})();


(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;


/**
 * The ExtensionManager manages a set of extensions available to the viewer.
 * Register, retrieve, and unregister your extension using the singleton theExtensionManager.
 *
 * You can load/unload your registered extension into a Viewer by calling
 * {@link Autodesk.Viewing.Viewer#loadExtension|viewer.loadExtension(id, options)} and
 * {@link Autodesk.Viewing.Viewer#unloadExtension|viewer.unloadExtension(id)}, respectively.
 * @constructor
 */
var ExtensionManager = function () {
    var extensions = {};        // Registered extenesions available in-memory
    var extensionsAsync = {};   // Extensions that need to get downloaded

    /**
     * Registers a new extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Extension} extension - The Extension-derived class representing the extension.
     * @returns {boolean} - True if the extension was successfully registered.
     */
    function registerExtension(extensionId, extension) {
        if (extensions[extensionId]) {
            return false;
        }
        extensions[extensionId] = extension;
        return true;
    }

    /**
     * Returns the class representing the extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {!Extension} - The Extension-derived class if one was registered; null otherwise.
     */
    function getExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            return extensions[extensionId];
        }
        return null;
    }

    /**
     * Unregisters an existing extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {boolean} - True if the extension was successfully unregistered.
     */
    function unregisterExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            delete extensions[extensionId];
            return true;
        }
        return false;
    }

    /**
     * Registers an extension that needs to be downloaded before using it.
     * The Viewer ships with some extensions that are not bundled, but can be runtime-fetched.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {string} urlPath - The url from where it needs to be pulled from. Can be a relative or an absolute path.
     * @returns {boolean} - True if the extension was successfully registered.
     */
    function registerExternalExtension(extensionId, urlPath) {
        if (extensionsAsync[extensionId]) {
            return false;
        }
        extensionsAsync[extensionId] = urlPath;
        return true;
    }

    /**
     * Returns the url path from where to download the extension; null if not registered through registerExternalExtension().
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {url|null} - The url from where to download the extension; null if not download is needed.
     */
    function getExternalPath(extensionId) {
        if (extensionsAsync.hasOwnProperty(extensionId)) {
            return extensionsAsync[extensionId];
        }
        return null;
    }

    function unregisterExternalExtension(extensionId) {
        if (extensionsAsync.hasOwnProperty(extensionId)) {
            delete extensionsAsync[extensionId];
            return true;
        }
        return false;
    }

    /**
     * Gets a list of all the extensions that are available for usage.
     * Some are already available in memory, while others may require
     * an additional file to be downloaded prior to its usage.
     */
    function getRegisteredExtensions() {
        var extensionId;
        var ret = [];
        // in-memory extensions (might have been downloaded)
        for (extensionId in extensions) {
            if (extensions.hasOwnProperty(extensionId)) {
                ret.push({
                    id: extensionId,
                    inMemory: true,
                    isAsync: (extensionId in extensionsAsync)
                });
            }
        }
        // Async extensions (some may already be in memory)
        for (extensionId in extensionsAsync) {
            if (extensionsAsync.hasOwnProperty(extensionId) && !(extensionId in extensions)) {
                ret.push({
                    id: extensionId,
                    inMemory: false,
                    isAsync: true
                });
            }
        }
        return ret;
    }

    /**
     * Iterates over each registered Extension class and invokes
     * static method 'populateDefaultOptions' if available.
     * 
     * The objective is to gather all supported configuration options
     * across all extensions.
     */
    function popuplateOptions(options) {
        for (var ext in extensions) {
            if (extensions.hasOwnProperty(ext) && extensions[ext].hasOwnProperty('populateDefaultOptions')){
                extensions[ext].populateDefaultOptions(options);
            }
        }
    }

    return {
        registerExtension: registerExtension,
        getExtension: getExtension,
        unregisterExtension: unregisterExtension,
        registerExternalExtension: registerExternalExtension,
        getExternalPath: getExternalPath,
        unregisterExternalExtension: unregisterExternalExtension,
        getRegisteredExtensions: getRegisteredExtensions,
        popuplateOptions: popuplateOptions
    };
};

var theExtensionManager =  new ExtensionManager();

/***
 * Augments a class by extension load/unload functionality.
 */
var ExtensionMixin = function() {};

ExtensionMixin.prototype = {

    /**
     * Loads the extension with the given id and options.
     * For internal use only.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Object} options - An optional dictionary of options.
     *
     * @returns {Promise} - Since 2.15, resolves with the extension requested. Before it would return true if the extension gets loaded.
     */
    loadExtension : function (extensionId, options) {

        if (!this.loadedExtensions)
            this.loadedExtensions = {};

        // is it already loaded?
        var extension = this.getExtension(extensionId);
        if (extension) {
            return Promise.resolve(extension);
        }

        // Is the extension registered?
        var EXTENSION_CLASS = theExtensionManager.getExtension(extensionId);
        if (!EXTENSION_CLASS) {

            // Is it an extension that needs to be downloaded?
            var urlPath = theExtensionManager.getExternalPath(extensionId);
            if (urlPath) {
                return this.loadExtensionAsync(extensionId, urlPath, options);
            }

            // else...
            return Promise.reject('Extension not found: ' + extensionId + '. Has it been registered(1)?');
        }

        // Extension has been registered locally.
        return this.loadExtensionLocal(extensionId, options);
    },

    /**
     * Returns the loaded extension.
     * @param {string} extensionId - The string id of the extension.
     * @returns {?Object} - Extension.
     */
    getExtension : function (extensionId) {
        return (this.loadedExtensions && extensionId in this.loadedExtensions) ? this.loadedExtensions[extensionId] : null;
    },

    /**
     * Unloads the extension with the given id.
     * For internal use only.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {boolean} - True if the extension was successfully unloaded.
     */
    unloadExtension : function (extensionId) {
        var success = false;
        var ext = this.getExtension(extensionId);
        if (ext) {
            success = ext.unload();
            avp.logger.info('Extension unloaded: ' + extensionId);
            delete this.loadedExtensions[extensionId];
            this.dispatchEvent({ type: av.EXTENSION_UNLOADED_EVENT, extensionId: extensionId });
        } else {
            avp.logger.warn('Extension not found: ' + extensionId);
        }
        return success;
    },


    /**
     * Loads the extension with the given id and options.
     * For internal use only.
     * 
     * Available from version 2.15
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Object} options - An optional dictionary of options.
     *
     * @returns {Promise} - Resolves with the extension requested.
     */
    loadExtensionLocal : function (extensionId, options) {

        var EXTENSION_CLASS = theExtensionManager.getExtension(extensionId);
        if (!EXTENSION_CLASS) {
            return Promise.reject('Extension not found: ' + extensionId + '. Has it been registered(2)?');
        }

        var extension = new EXTENSION_CLASS(this, options);
        extension.id = extensionId;
        var success = extension.load();
        if (success) {
            this.loadedExtensions[extensionId] = extension;
            avp.logger.info('Extension loaded: ' + extensionId);
            this.dispatchEvent({ type: av.EXTENSION_LOADED_EVENT, extensionId: extensionId });
            return Promise.resolve(extension);
        }

        // else
        return Promise.reject('Extension failed to .load() : ' + extensionId);
    },

    /**
     * Loads an extension JavaScript file from a URL. It will download the file, parse it and
     * then invoke loadExtension().  Calling this function a second time will not download the
     * file again.
     * 
     * Available from version 2.15
     * 
     * @example
     *      viewer.loadExtensionAsync(
     *          'MyExtensionId', 
     *          'http://my.site.com/path/MyExtension.js', 
     *          {}
     *      ).then(function(ext){
     *          ext.doSomething();
     *      }).catch(function(error){
     *          console.error(error);
     *      });
     * 
     * @param {string} extensionId - The string id of the extension.
     * @param {string} url - The url where the extension's JavaScript file is hosted. Can be a relative or absolute path.
     * @param {Object} options - An optional dictionary of options, same as in loadExtension().
     * 
     * @returns {promise} - That resolves with the extension object.
     */
    loadExtensionAsync : function(extensionName, url, options) {
        var that = this;
        return new Promise(function(resolve, reject){
            avp.loadDependency(extensionName, url, 
                function() { // onSuccess
                    that.loadExtension(extensionName, options);
                    var ext = that.getExtension(extensionName);
                    if (ext) {
                        resolve(ext);
                    } else {
                        reject('Failed to getExtension(' + extensionName + ')');
                    }
                },
                function () { // onError
                    reject('Failed to loadExtensionAsync: (' + extensionName + ') from: (' + url + ')');
                }
            )
        });
    },


    apply : function(object) {

        var me = ExtensionMixin.prototype;

        object.loadExtension = me.loadExtension;
        object.getExtension = me.getExtension;
        object.unloadExtension = me.unloadExtension;
        object.loadExtensionLocal = me.loadExtensionLocal;
        object.loadExtensionAsync = me.loadExtensionAsync;
    }

};


Autodesk.Viewing.theExtensionManager = theExtensionManager;
Autodesk.Viewing.ExtensionMixin = ExtensionMixin;

})();

(function(){ 'use strict';

/**
 * These are extensions that get built into their own bundles, 
 * which are not part of the main viewer3D.js bundle.
 */

Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.Wireframes',   'extensions/Wireframes/Wireframes.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.RaaS',                 'extensions/RaaS/RaaS.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.MarkupsCore',  'extensions/Markups/Markups.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.MarkupsGui',   'extensions/Markups/MarkupsGui.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Billboard',            'extensions/Billboard/Billboard.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.BillboardGui',         'extensions/Billboard/Billboard.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.Comments',     'extensions/Comments/Comments.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.InViewerSearch',       'extensions/InViewerSearch/InViewerSearch.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.WebVR',        'extensions/WebVR/WebVR.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.MemoryManager','extensions/MemoryManager/MemoryManager.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Viewing.MemoryManager','extensions/MemoryManager/MemoryManager.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Beeline',              'extensions/Beeline/Beeline.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.FirstPerson',          'extensions/FirstPerson/FirstPerson.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.BimWalk',              'extensions/BimWalk/BimWalk.js');
Autodesk.Viewing.theExtensionManager.registerExternalExtension('Autodesk.Debug',                'extensions/Debug/Debug.js');
//
// When adding a file here, you'll have to update the following files.
//
// If the extension is JS only, then look only at the files that say JS.
// Similar treatment if the extension has a CSS file that get downloaded with `avp.injectCSS()`
//
// concat.js    ------------------- JS and CSS
// uglify.json -------------------- only JS 
// cssmin.json -------------------- only CSS
// javascript.js ------------------ only JS
// Gruntfile.js ------------------- JS and CSS
// string-replace.json ------------ JS and CSS
//
//

})();


(function() {

"use strict";

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;

/**
 * Core model data class for all items and collections.
 *
 * It allows the client to load the model data from the cloud, it
 * gives access to the root and provides a method for finding elements
 * by id.
 *
 * Typically, you load the document from the Viewing Service, parse it for
 * the required content (for example, 3d geometries), then pass this on to
 * the viewer to display.  You can also get some information about the document,
 * such as the number of views it contains and its thumbnail image.
 *
 * You can view the JSON structure of a {@link Autodesk.Viewing.Document} object
 * by requesting it from the Model Derivative endpoints.
 *
 * @constructor
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.Document
 * @param {object} dataJSON - JSON data representing the document.
 * @param {string} path - Path to the document.
 * @param {string} acmsession - ACM session ID.
 * @category Core
 */
var Document = function( dataJSON, path, acmsession )
{
    this.myPath = path;
    this.myData = dataJSON;

    if (dataJSON)
        this.docRoot = new av.BubbleNode(dataJSON);

    this.myViewGeometry = {};
    this.myNumViews = {};
    this.myPropertyDb = null;
    this.acmSessionId = acmsession;

    // Search bubble for type="view" role="3d" children of type="geometry" role="3d" items.
    // Add count of view-3d items to parent geometry-3d items.
    // Collect geometry items of camera view items referenced by guid.
    //
    var self = this;

    function annotateViews(item) {
        if (!item) {
            return;
        }

        var children = item.children || item.derivatives;
        var childCount = children ? children.length : 0;
		var i;

        if (item.type === "geometry" && childCount) {
            var viewCount = 0;
            for (i = 0; i < childCount; i++) {
                var child = children[i];
                if (child && child.type === "view") {
                    self.myViewGeometry[child.guid] = item;
                    viewCount++;
                }
            }

            self.myNumViews[item.guid] = viewCount;

        } else if (item.mime == "application/autodesk-db" && item.urn) {
            //If there is a shared property database, remember its location

            //Of course, OSS is a storage system that mangles paths because why not,
            //so it needs special handling to extract the property database path
            if (item.urn.indexOf(avp.ViewingService.OSS_PREFIX) === 0)
                self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("%2F")+3);
            else
                self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("/")+1);

        } else if (0 < childCount) {
            for (i = 0; i < childCount; i++) {
                annotateViews(children[i]);
            }
        }
    }
    annotateViews(dataJSON);

    // Traverse the document and populate the parent pointers (for each node, store its parent).
    //
    function traverse( item ) {
        if (!item)
            return;

        var children = item.children || item.derivatives;
        var len = children ? children.length : 0;
        for(var i=0; i < len; i++)
        {
            children[i].parent = item;
            traverse(children[i]);
        }
    }
    traverse(this.myData);
};

Document.prototype.constructor = Document;

/**
 * Static method to load the model data from the cloud.
 *
 * @example
 *  // Load the model from the cloud
 *  var urn = 'dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOnRyYW5zbGF0aW9uXzI1X3Rlc3RpbmcvRFdGL0Nhci5kd2Y=';
 *  var seedFile  = "https://viewing-dev.api.autodesk.com/derivativeservice/v2/" + urn;
 *  var jsonData = "";
 *  Autodesk.Document.load( seedFile, function( doc ) { jsonData=doc }, function( ) { } );
 *  var model = new Autodesk.Document(jsonData, 'path');
 *  var root  = model.getRootItem(); // top item of the hierarchy of the model data
 *  var item  = model.getItemById( "XXX02UUEs");
 *  var path = model.getFullPath(); // should be 'path'
 *
 * @param {string} documentId - The cloud URN of the file.
 * @param {function(object)} onSuccessCallback - A function that is called when load succeeds.
 * @param {function(int, string)} onErrorCallback - A function that is called when load fails.
 * @param {object} accessControlProperties - An optional list of key value pairs as access control properties,
 * which includes a list of access control header name and values, and an OAuth 2.0 access token.
 */
Document.load = function( documentId, onSuccessCallback, onErrorCallback, accessControlProperties )
{

    // The function signature was changed and we removed the need for the Auth parameter
    // Check what the second parameter is if its a non function assign the others correctly
    // this will also work in the case of missing arguments
    if (typeof(arguments[1]) !== 'function') {
        avp.logger.warn("Document.load called with deprecated (auth) parameter");
        if (typeof(arguments[2]) === 'function') {
            onSuccessCallback = arguments[2];
        }
        if (typeof(arguments[3]) === 'function') {
            onErrorCallback = arguments[3];
        }
     }

    function getViewableCount(modelDocument) {
        var viewableItems = Document.getViewableItems(modelDocument);
        var root = viewableItems[0];
        var geometryItems = Document.getSubItemsWithProperties(root, {'type':'geometry'}, true);
        return geometryItems.length;
    }

    function getGlobalMessages(data, nestedKey) {

      var collectedmessages = [];
      var translateFailedCount = 0;
      var translateProgressCount = 0;
      nestedKey = nestedKey || "children";

      var traverse = function (obj) {
        var children = obj[nestedKey] || [];
        var messages = obj.messages || [];

        var errorMessages = messages.filter(function(msg) {
          return msg.type === 'error';
        });

        if(errorMessages.length > 0) {
          translateFailedCount += 1;
        }

        if(obj.status === 'inprogress') {
          translateProgressCount += 1;
        }

        Array.prototype.push.apply(collectedmessages, messages.slice(0));
        for(var i = children.length; i--; traverse(children[i]));
      };

      traverse(data);

      var progress = 'translated';

      progress = translateFailedCount > 0 ? "failed" : progress;
      progress = translateProgressCount > 0 ? 'processing' : progress;

      for(var i = collectedmessages.length; i--; collectedmessages[i].$translation = progress);

      return collectedmessages;

    }

    function doLoad(acmsession) {

        var documentPath = Document.getDocumentPath(documentId);
        var messages;

        function onSuccess(data) {
            var regex = /<[^>]*script/;
            if (regex.test(data)) {
                if (onErrorCallback)
                    onErrorCallback(av.ErrorCodes.BAD_DATA, "Malicious document content detected Abort loading");
                return;
            }

            var items = typeof(data) === 'string' ? JSON.parse(data) : data;
            var lmvDocument = new Document(items, documentPath, acmsession);
            var viewableCount = getViewableCount(lmvDocument);

            // Check if there are any viewables.
            if (viewableCount > 0) {
                messages = getGlobalMessages( lmvDocument.getRootItem() );
                if (onSuccessCallback) {
                    onSuccessCallback(lmvDocument, messages);
                }
            }
            else {
                // If there are no viewables, report an error.
                //
                if (onErrorCallback) {
                    messages = getGlobalMessages( lmvDocument.getRootItem() );
                    var errorCode =  av.ErrorCodes.BAD_DATA_NO_VIEWABLE_CONTENT;
                    var errorMsg  = "No viewable content";
                    onErrorCallback(errorCode, errorMsg, messages);
                }
            }
        }

        function onFailure(statusCode, statusText, data) {

            var messages = getGlobalMessages(data);
            if (onErrorCallback) {
                var errorMsg = "Error: " + statusCode + " (" + statusText + ")";
                var errorCode = av.Private.ErrorHandler.getErrorCode(statusCode);
                onErrorCallback(errorCode, errorMsg, statusCode, statusText, messages);
            }        
        }

        var msg = {
            queryParams: acmsession ? "acmsession=" + acmsession : ""
        };

        avp.ViewingService.getManifest(avp.initLoadContext(msg), documentPath, onSuccess, onFailure);
    }

    if (accessControlProperties) {
        avp.ViewingService.getACMSession(av.endpoint.getApiEndpoint(), accessControlProperties, doLoad, onErrorCallback);
    } else {
        doLoad();
    }
};

/**
 * Available from 2.15
 * 
 * @private
 */
Document.getDocumentPath = function(documentId)
{
    // Handle local paths explicitly.
    //
    if(documentId.indexOf('urn:') === -1) {

        //Absolute URL
        if (documentId.indexOf("://") !== -1)
            return documentId;

        var relativePath = documentId;

        if (typeof window !== "undefined") {
            if(relativePath.indexOf('/') !== 0)
                relativePath = '/' + relativePath;
            return window.location.protocol + "//" + window.location.host + relativePath;
        } else {
            return relativePath;
        }
    }
    return documentId;
}

/**
 * This function is only used when Authorization is through Bearer token; aka when cookies are disabled.
 * @param {string} data - See {@link Autodesk.Viewing.Document#getThumbnailOptions}.
 * @param {function} onComplete - Node style callback function `callback(err, response)`.
 */
Document.requestThumbnailWithSecurity = function(data, onComplete) {

    var onSuccess = function(response){
        onComplete(null, response);
    };
    var onFailure = function(){
        onComplete('error', null);
    };

    var options = {
        responseType: 'blob',
        skipAssetCallback: true,
        size: data.width, //Ignore the height, they are the same.
        guid: data.guid
    };

    var urlpath = "urn:" + data.urn; //HACK: Adding urn: makes the ViewingServiceXhr accept this as a viewing service request.
    avp.ViewingService.getThumbnail(avp.initLoadContext(), urlpath, onSuccess, onFailure, options);
};

/**
 * Returns the full path to the given URN.
 * @param {string} urn - URN of the document.
 * @returns {string}
 */
Document.prototype.getFullPath = function(urn)
{

    if (!urn)
        return urn;

	var fullPath = urn;

    if (avp.offline) {
      // If offline resource prefix is already added to path, then no need to add again.
      if (fullPath.indexOf(av.Private.offlineResourcePrefix) == -1) {

          var ossIndex = fullPath.indexOf(av.Private.ViewingService.OSS_PREFIX);
          if (ossIndex !== - 1) {
              var ossObject = fullPath.substr(fullPath.indexOf("/") + 1);
              var decodeObject = decodeURIComponent(ossObject);
              var object = decodeObject.substr(decodeObject.indexOf("/"));
              fullPath = decodeURIComponent(av.Private.offlineResourcePrefix) + object;
          }
          else {
              fullPath = decodeURIComponent(av.Private.offlineResourcePrefix) + fullPath.substr(fullPath.indexOf('/'));
          }
      }
    } else if(urn.indexOf('urn') === 0)
    {
        // Use viewing service.
        fullPath = av.endpoint.getItemApi(null, urn);
    }
    // Handle local bubble files.
    //
    else if(urn.indexOf('$file$') === 0) {
        fullPath = this.myPath.replace('/bubble.json', '') + urn.replace('$file$', '');
    }
    return fullPath;
};

/**
 * Returns a plain object with properties used to fetch a thumbnail image.
 * @param {object} item
 * @param {number} width
 * @param {number} height
 * @returns {object} `{urn: string, width: number, height: number, guid: string, acmsession: (string)}`
 */
Document.prototype.getThumbnailOptions = function(item, width, height) {
    var requestedWidth = width ? width : 200;
    var requestedHeight = height ? height : 200;
    return {
        urn: this.myData.urn,
        width: requestedWidth,
        height: requestedHeight,
        guid: item.guid,
        acmsession: this.acmSessionId
    }
};

/**
 * Returns the path to the thumbnail of the item with the given ID.
 * @param {string} item - Document item.
 * @param {int} width - The requested thumbnail width.
 * @param {int} height - The requested thumbnail height.
 * @returns {string}
 */
Document.prototype.getThumbnailPath = function(item, width, height)
{
    var data = this.getThumbnailOptions(item, width, height);
    var ret = av.endpoint.getThumbnailApi(null, data.urn) +
        "?guid=" + data.guid +
        "&width=" + data.width +
        "&height=" + data.height;

    if (data.acmsession) {
        ret += "&acmsession=" + data.acmsession;
    }
    return ret;
};

/**
 * Extracts leaflet loader params from an item (if any).
 * @param {object} outLoadOptions - Extracted params are stored in this object.
 * @param {object} geomItem - Geometry item with role '2d' that contains
 * the leaflet resource item.
 * @param {string} leafletItem - The resource item with role 'leaflet' that
 * contains the tile url pattern and some other params.
 */
function getLeafletParams(outLoadOptions, geomItem, leafletItem) {

    outLoadOptions.urlPattern  = leafletItem.urn;
    outLoadOptions.tileSize    = leafletItem.tileSize ?  leafletItem.tileSize : 512; // currently, bubbles use a fixed tile size of 512.
    outLoadOptions.texWidth    = leafletItem.resolution[0];
    outLoadOptions.texHeight   = leafletItem.resolution[1];
    outLoadOptions.paperWidth  = leafletItem.paperWidth;
    outLoadOptions.paperHeight = leafletItem.paperHeight;
    outLoadOptions.paperUnits  = leafletItem.paperUnits;

    // hierarchies produced by cloud translation service start with a 1x1 miplevel at the root.
    // therefore, we have to skip some levels.
    outLoadOptions.levelOffset = avp.LeafletLoader.computeLevelOffset(outLoadOptions.tileSize);

    // By default, the number of hierarchy levels is computed automatically from texWidth/texHeight.
    // (see computeMaxLevel() in ModelIteratorTexQuad.js). However, the leaflet item also
    // contains a maxLevel value, which is usually smaller than the computed one. The purpose
    // of this value is to specify the (reduced) number of levels that we use when viewing
    // the leaflet in offline mode on mobile devices. Otherwise, we let maxLevel undefined, so
    // that the full resolution is used.
    if (avp.offline && av.isMobileDevice()) {
        // maxLevel is stored in another resource item that references a zip-file with the tile-images.
        // the max_level value includes several levels with just one tile (1x1, 2x2, ...) which we skip.
        var items = Document.getSubItemsWithProperties(geomItem, { 'role': 'leaflet-zip' }, false);
        if (items.length > 0) {
            outLoadOptions.maxLevel = items[0].max_level - outLoadOptions.levelOffset;
        }
    }
};

/**
 * Returns the path to the viewable of the given item.
 * @param {object} item - The item whose viewable is requested.
 * @param {object} outLoadOptions - Output param: used to store some additional loader options.
 * Needed to extract leaflet params from a bubble item.
 * @returns {string}
 */
Document.prototype.getViewablePath = function(item, outLoadOptions)
{
    if(item.type === 'geometry') {
        var items = [];
        if(item.role === '3d') {
            items = Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-svf'
            }, false);
        }
        else if(item.role === '2d') {

            // check for a leaflet resource
            items = Document.getSubItemsWithProperties(item, {
                'role': 'leaflet'
            }, false);

            // found one? => extract its params
            if (items.length > 0 && outLoadOptions) {
                getLeafletParams(outLoadOptions, item, items[0]);
            };

            // if there is no leaflet...
            // check for single image source
            if (items.length === 0) {
                items = Document.getSubItemsWithProperties(item, {
                    'role': 'image'
                }, false);
            }

            if (items.length === 0) {
                // check for vector and if does not exist for tiles.
                items = Document.getSubItemsWithProperties(item, {
                    'mime': 'application/autodesk-f2d'
                }, false);
            }
                // old file does not have f2d yet - so load tile viewer
            if (items.length === 0) {
                items = Document.getSubItemsWithProperties(item, {
                    'role': 'tileRoot'
                }, true);
            }
        }
        if(items.length > 0)
        {
            return this.getFullPath(items[0].urn);
        }
    }
    else if(item.type === 'view') {
        var geometryItem = this.getViewGeometry(item);
        if (geometryItem) {
            return this.getViewablePath(geometryItem);
        }
    }

    return '';
};

/**
 * Returns the root path to a shared (across all sheets/views) property database's JSON files.
 * @returns {string}
 */
Document.prototype.getPropertyDbPath = function()
{
    return this.getFullPath(this.myPropertyDb);
};

/**
 *  Returns the root of the model data hierarchy.
 *  @returns {object}
 */
Document.prototype.getRootItem = function()
{
    return this.myData;
};

/**
 * Returns a BubbleNode instance, encapsulating the current document manifest JSON
 * @returns {Autodesk.Viewing.BubbleNode}
 */
Document.prototype.getRoot = function() {
    return this.docRoot;
};

/**
 *  Returns the id of this document.
 *  @returns {string}
 */
Document.prototype.getPath = function()
{
    return this.myPath;
};

/**
 * Returns an item from the model data hierarchy with the given id.
 * If the item is not found, null object is returned.
 * @param {string} id - ID of the item to be found.
 * @returns {object} Item with a given ID.
 */
Document.prototype.getItemById = function(id)
{
    function traverse( data ) {
        if (!data)
            return null;

        for (var key in data) {
            var val = data[key];
            if ( key === 'guid' && val === id )
                return data;

            if (val !== null && typeof(val) === "object" && key !== "parent") {
                //going on step down in the object tree!!
                var item = traverse( val );
                if (item)
                    return item;
            }
        }
        return null;
    }
    return traverse( this.myData );
};

/**
 * Static method that returns an array of all items with given properties.
 * @param {object} item - The document node to begin searching from.
 * @param {object} properties - map/list of the properties to search for.
 * @param {boolean} recursive - If true, searches recursively.
 * @returns {object} List of items that have given properties.
 * @example
 *  // search the document starting from the root element for all 2d geometry items
 *  geometryItems = Document.getSubItemsWithProperties(adocument.getRootItem(), {
 *      'type' : 'geometry',
 *      'role' : '2d'
 *  }, true);
 */
Document.getSubItemsWithProperties = function(item, properties, recursive)
{
  var subItems = [];
  if(!item) return [];

  function hasProperties(item, properties)
  {
    for(var p in properties)
    {
      if (!(p in item) || (properties[p] !== item[p]))
        return false;
    }
    return true;
  }

  var children = item.children || item.derivatives;
  var len = children ? children.length : 0;
  for(var i=0; i < len; i++)
  {
    // Check if this child has this key and value.
    //
    var child = children[i];
    if(hasProperties(child, properties))
    {
      subItems.push(child);
    }

    // Search the descendants if requested.
    //
    if(recursive)
    {
      subItems.push.apply(subItems, Document.getSubItemsWithProperties(child, properties, recursive));
    }
  }
  return subItems;
};

/**
 *
 * @param document
 */
Document.getViewableItems = function(document) {

    return (
        Document.getSubItemsWithProperties(document.getRootItem(), {'type':'folder','role':'viewable'}, true).concat(
        Document.getSubItemsWithProperties(document.getRootItem(), {'outputType': 'svf'}, true)));
};

/**
 * Returns the parent geometry item for a given view item.
 * @param {object} item - View item.
 * @returns {object} The parent geometry item.
 */
Document.prototype.getViewGeometry = function (item) {
    return this.myViewGeometry[item.guid];
};

/**
 * Returns the number of view items underneath a geometry item.
 * @param {object} item - Geometry item.
 * @returns {number} The number of view items underneath the geometry item.
 */
Document.prototype.getNumViews = function (item) {
    return this.myNumViews[item.guid] || 0;
};

/**
 * @deprecated Simply use item.parent instead.
 * Returns parent ID of the given document node ID.
 * @param {string} item - The node ID.
 * @returns {string}
 */
Document.prototype.getParentId = function (itemId) {
    var item = this.getItemById(itemId);
    if (!item)
        return null;
    var parent = item.parent;
    return parent ? parent.guid : null;
};


/**
 * Returns messages (error and warning messages) associated with a given item.
 * It includes item's messages as well as messages of all its parents.
 * @param {string} itemId - GUID of the item.
 * @param {boolean} - If true, the top messages that apply to the whole file are excluded.
 * @returns {object} Returns an array of messages.
 */
Document.prototype.getMessages = function( item, excludeGlobal ) {

    var messages = [];
    if (!item)
        return messages;

    var root = null;
    if (excludeGlobal)
        root = this.getRootItem();

    var current = item;
    while (current) {

        if (excludeGlobal && parent===root)
            break;

        if (current.messages) {
            for (var i=0; i<current.messages.length; i++){
                messages.push( current.messages[i] );
            }
        }
        current = current.parent;
    }
    return messages;
};

av.Document = Document;


})();


(function() {

"use strict";

var av = Autodesk.Viewing,
    avp = av.Private;

var fsNames = ['fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'];

function addListener(listener) {
    for (var i=0; i<fsNames.length; ++i)
        document.addEventListener(fsNames[i], listener, false);
}

function removeListener(listener) {
    for (var i=0; i<fsNames.length; ++i)
        document.removeEventListener(fsNames[i], listener, false);
}


/**
 * List of available screen modes: normal, full browser, and full screen.
 * @readonly
 * @memberof Autodesk.Viewing
 * @enum {number}
 */
av.ScreenMode = {kNormal: 0, kFullBrowser: 1, kFullScreen: 2};


/**
 * Virtual base class for screen mode manipulation.
 *
 * Derive from this class and use it to allow viewer to go full screen.
 * @constructor
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.ScreenModeDelegate
 * @category Core
 */
function ScreenModeDelegate(viewer) {
    this.viewer = viewer;
    this.bindFullscreenEventListener = this.fullscreenEventListener.bind(this);

    if (this.getMode() === av.ScreenMode.kFullScreen) {
        addListener(this.bindFullscreenEventListener);
    }
}

av.ScreenModeDelegate = ScreenModeDelegate;

/**
 * Perform any cleanup required for a {@link Autodesk.Viewing.ScreenModeDelegate} instance.
 */
ScreenModeDelegate.prototype.uninitialize = function () {

    removeListener(this.bindFullscreenEventListener);
    this.viewer = null;
};

/**
 * Is screen mode supported?
 * Returning false for normal mode means no screen mode changes are supported.
 * @param {Autodesk.Viewing.ScreenMode} mode - Desired screen mode.
 * @returns {boolean} True if screen mode is supported.
 */
ScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return true;
};

/**
 * Set new screen mode.
 * @param {Autodesk.Viewing.ScreenMode} mode - New screen mode.
 * @returns {boolean} True if screen mode was changed.
 */
ScreenModeDelegate.prototype.setMode = function (mode) {
    var currentMode = this.getMode();
    if ((mode !== currentMode) && this.isModeSupported(mode)) {
        this.doScreenModeChange(currentMode, mode);
        this.onScreenModeChanged(currentMode, mode);
        return true;
    }
    return false;
};

/**
 * Override this method to get the current screen mode.
 * @returns {Autodesk.Viewing.ScreenMode} Current screen mode.
 */
ScreenModeDelegate.prototype.getMode = function () {
    throw 'Implement getMode() in derived class';
};

/**
 * Return next screen mode in sequence.
 * Depending on what modes are supported, this may be a toggle or a 3-state.
 * @returns {Autodesk.Viewing.ScreenMode|undefined} Next screen mode in sequence or undefined if no change.
 */
ScreenModeDelegate.prototype.getNextMode = function () {
    var currentMode = this.getMode(),
        newMode;

    var SM = av.ScreenMode;

    if (currentMode === SM.kNormal &&
        this.isModeSupported(SM.kFullBrowser)) {

        newMode = SM.kFullBrowser;

    } else if (currentMode === SM.kNormal &&
        this.isModeSupported(SM.kFullScreen)) {

        newMode = SM.kFullScreen;

    } else if (currentMode === SM.kFullBrowser &&
        this.isModeSupported(SM.kFullScreen)) {

        newMode = SM.kFullScreen;

    } else if (currentMode === SM.kFullBrowser &&
        this.isModeSupported(SM.kNormal)) {

        newMode = SM.kNormal;

    } else if (currentMode === SM.kFullScreen &&
        this.isModeSupported(SM.kNormal)) {

        newMode = SM.kNormal;

    } else if (currentMode === SM.kFullScreen &&
        this.isModeSupported(SM.kFullBrowser)) {

        newMode = SM.kFullBrowser;
    }
    return newMode;
};

/**
 * Return new screen mode on escape.
 * @returns {Autodesk.Viewing.ScreenMode|undefined} New screen mode or undefined if no change.
 */
ScreenModeDelegate.prototype.getEscapeMode = function () {
    return (this.getMode() !== av.ScreenMode.kNormal) ?
        av.ScreenMode.kNormal : undefined;
};

/**
 * Full screen event listener.
 */
ScreenModeDelegate.prototype.fullscreenEventListener = function () {
    if (av.inFullscreen()) {
        this.viewer.resize();
    } else {
        var ScreenMode = av.ScreenMode;
        this.doScreenModeChange(ScreenMode.kFullScreen, ScreenMode.kNormal);
        this.onScreenModeChanged(ScreenMode.kFullScreen, ScreenMode.kNormal);
    }
};

/**
 * Override this method to make the screen mode change occur.
 * @param {Autodesk.Viewing.ScreenMode} oldMode - Old screen mode.
 * @param {Autodesk.Viewing.ScreenMode} newMode - New screen mode.
 */
ScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    throw 'Implement doScreenModeChange() in derived class';
};

/**
 * Called after the screen mode changes.
 * @param {Autodesk.Viewing.ScreenMode} oldMode - Old screen mode.
 * @param {Autodesk.Viewing.ScreenMode} newMode - New screen mode.
 */
ScreenModeDelegate.prototype.onScreenModeChanged = function (oldMode, newMode) {
    if (oldMode === av.ScreenMode.kFullScreen) {
        removeListener(this.bindFullscreenEventListener);
    } else if (newMode === av.ScreenMode.kFullScreen) {
        addListener(this.bindFullscreenEventListener);
    }

    this.viewer.resize();
    this.viewer.dispatchEvent({type: av.FULLSCREEN_MODE_EVENT, mode: newMode});
};





/**
 * Screen mode delegate allowing the viewer to go full screen.
 *
 * Unlike ViewerScreenModeDelegate class, this delegate
 * doesn't use the full browser state, and it takes the entire page full screen, not just
 * the viewer.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.AppScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
 * @category Core
 */
av.AppScreenModeDelegate = function (viewer) {
    av.ScreenModeDelegate.call(this, viewer);
};

av.AppScreenModeDelegate.prototype = Object.create(av.ScreenModeDelegate.prototype);
av.AppScreenModeDelegate.prototype.constructor = av.AppScreenModeDelegate;

av.AppScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return mode !== av.ScreenMode.kFullBrowser;
};

av.AppScreenModeDelegate.prototype.getMode = function () {
    return av.inFullscreen() ?
        av.ScreenMode.kFullScreen :
        av.ScreenMode.kNormal;
};

av.AppScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    var container = this.viewer.container;
    if (newMode === av.ScreenMode.kNormal) {
        container.classList.remove('viewer-fill-browser');
        av.exitFullscreen();
    } else if (newMode === av.ScreenMode.kFullScreen) {
        container.classList.add('viewer-fill-browser');
        av.launchFullscreen(container);
    }
};

// Keep the old class name for backwards compatibility
av.ApplicationScreenModeDelegate = av.AppScreenModeDelegate;


/**
 * Screen mode delegate with no full screen functionality.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @memberof Autodesk.Viewing
 * @alias Autodesk.Viewing.NullScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance.
 * @category Core
 */
av.NullScreenModeDelegate = function (viewer) {
    av.ScreenModeDelegate.call(this, viewer);
};

av.NullScreenModeDelegate.prototype = Object.create(av.ScreenModeDelegate.prototype);
av.NullScreenModeDelegate.prototype.constructor = av.ScreenModeDelegate;


av.NullScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return false; // No screen modes supported
};

av.NullScreenModeDelegate.prototype.getMode = function () {
    return av.ScreenMode.kNormal;
};





av.ScreenModeMixin = function() {
};


av.ScreenModeMixin.prototype = {

    /**
     * Set new screen mode delegate.
     * @param {Autodesk.Viewing.ScreenModeDelegate} delegate - New screen mode delegate class.
     */
    setScreenModeDelegate : function (delegate) {
        if (this.screenModeDelegate) {
            this.screenModeDelegate.uninitialize();
            this.screenModeDelegate = null;
        }

        // null -> Fullscreen not available
        // undefined -> Use default AppScreenModeDelegate
        //
        if (delegate) {
            this.screenModeDelegateClass = delegate;
        } else if (delegate === null) {
            this.screenModeDelegateClass = av.NullScreenModeDelegate;
        } else { // undefined
            this.screenModeDelegateClass = av.AppScreenModeDelegate;
        }
    },

    /**
     * Get current screen mode delegate.
     * If no screen mode delegate has been set, then use {@link Autodesk.Viewing.ViewerScreenModeDelegate}.
     * @returns {Autodesk.Viewing.ScreenModeDelegate} Current screen mode delegate.
     */
    getScreenModeDelegate : function () {
        if (!this.screenModeDelegate) {
            this.screenModeDelegate = new this.screenModeDelegateClass(this);
        }
        return this.screenModeDelegate;
    },


    /**
     * Is specified screen mode supported?
     * @param {Autodesk.Viewing.ScreenMode} mode - Desired screen mode.
     * @returns {boolean} True if screen mode is supported.
     */
    isScreenModeSupported : function (mode) {
        return this.getScreenModeDelegate().isModeSupported(mode);
    },

    /**
     * Is changing screen modes supported?
     * @returns {boolean} True if viewer supports changing screen modes.
     */
    canChangeScreenMode :  function () {
        return this.isScreenModeSupported(Autodesk.Viewing.ScreenMode.kNormal);
    },

    /**
     * Set new screen mode.
     * @param {Autodesk.Viewing.ScreenMode} mode - New screen mode.
     * @returns {boolean} True if screen mode was changed.
     */
    setScreenMode : function (mode) {
        var msg = {
            category: "screen_mode",
            value: mode
        };
        avp.logger.track(msg);

        return this.getScreenModeDelegate().setMode(mode);
    },

    /**
     * Get current screen mode.
     * @returns {Autodesk.Viewing.ScreenMode} Current screen mode.
     */
    getScreenMode : function () {
        return this.getScreenModeDelegate().getMode();
    },

    /**
     * Set screen mode to next in sequence.
     * @returns {boolean} True if screen mode was changed.
     */
    nextScreenMode : function () {
        var mode = this.getScreenModeDelegate().getNextMode();
        return (mode !== undefined) ? this.setScreenMode(mode) : false;
    },

    /**
     * Screen mode escape key handler.
     * @returns {boolean} True if screen mode was changed.
     */
    escapeScreenMode : function () {
        var mode = this.getScreenModeDelegate().getEscapeMode();
        return (mode !== undefined) ? this.setScreenMode(mode) : false;
    },


    apply : function(object) {

        var p = av.ScreenModeMixin.prototype;
        object.setScreenModeDelegate = p.setScreenModeDelegate;
        object.getScreenModeDelegate = p.getScreenModeDelegate;
        object.isScreenModeSupported = p.isScreenModeSupported;
        object.canChangeScreenMode = p.canChangeScreenMode;
        object.setScreenMode = p.setScreenMode;
        object.getScreenMode = p.getScreenMode;
        object.nextScreenMode = p.nextScreenMode;
        object.escapeScreenMode = p.escapeScreenMode;
    }

};



})();


// Viewer3D offers public methods for developers to use.
// Viewer3DImpl is the implementation file for Viewer3D and is only used by Viewer3D.js
// 
// Viewer3D does things like parameter validation.
// Viewer3DImpl does the actual work, by interfacing with other internal components, such as the MaterialManager.

(function() {

    "use strict";

    var av = Autodesk.Viewing,
        avp = av.Private;

    // Event types supported by this class.

    /**
     * Fired when the ESC key is pressed.
     * @event Autodesk.Viewing.Viewer3D#ESCAPE_EVENT
     */
    av.ESCAPE_EVENT                   = 'escape';
    /**
     * Fired repeatedly throughout the process of opening a model/drawing.
     * @event Autodesk.Viewing.Viewer3D#PROGRESS_UPDATE_EVENT
     * @property {number} percent - Estimated progress.
     * @property {number} state - Value from Autodesk.Viewing.ProgressState, providing details on the progress state.
     */
    av.PROGRESS_UPDATE_EVENT          = 'progress';
    /**
     * Fired when the screen mode changes.
     * @event Autodesk.Viewing.Viewer3D#FULLSCREEN_MODE_EVENT
     * @property {Autodesk.Viewing.ScreenMode} mode - New screen mode.
     */
    av.FULLSCREEN_MODE_EVENT          = 'fullScreenMode';
    /**
     * Fired then the navigation tool changes.
     * @event Autodesk.Viewing.Viewer3D#NAVIGATION_MODE_CHANGED_EVENT
     * @property {string} id - Tool identifier.
     */
    av.NAVIGATION_MODE_CHANGED_EVENT  = 'navmode';
    /**
     * Fired when the viewer state is restored.
     * @event Autodesk.Viewing.Viewer3D#VIEWER_STATE_RESTORED_EVENT
     * @property {bool} value - Success of the state restoration.
     */
    av.VIEWER_STATE_RESTORED_EVENT    = 'viewerStateRestored';
    /**
     * Fired when the viewer size changes.
     * @event Autodesk.Viewing.Viewer3D#VIEWER_RESIZE_EVENT
     * @property {number} width - New width of the viewer.
     * @property {number} height - New height of the viewer.
     */
    av.VIEWER_RESIZE_EVENT            = 'viewerResize';
    /**
     * Fired when the viewer is fully initialized.
     * @event Autodesk.Viewing.Viewer3D#VIEWER_INITIALIZED
     */
    av.VIEWER_INITIALIZED             = 'viewerInitialized';
    /**
     * Fired when the viewer is fully uninitialized.
     * @event Autodesk.Viewing.Viewer3D#VIEWER_UNINITIALIZED
     */
    av.VIEWER_UNINITIALIZED           = 'viewerUninitialized';

    /**
     * Fired when the model/drawing finishes loading.
     * @event Autodesk.Viewing.Viewer3D#GEOMETRY_LOADED_EVENT
     * @property {object} model - Model data.
     */
    av.GEOMETRY_LOADED_EVENT          = 'geometryLoaded';
    /**
     * Fired when a model is removed from the viewer.
     * @event Autodesk.Viewing.Viewer3D#MODEL_UNLOADED_EVENT
     * @property {object} model - Model data.
     */
    av.MODEL_UNLOADED_EVENT           = 'modelUnloaded';
    /**
     * Fired when a viewer extension is successfully loaded.
     * @event Autodesk.Viewing.Viewer3D#EXTENSION_LOADED_EVENT
     * @property {string} extensionId - Extension identifier.
     */
    av.EXTENSION_LOADED_EVENT         = 'extensionLoaded';
    /**
     * Fired when a viewer extension is successfully unloaded.
     * @event Autodesk.Viewing.Viewer3D#EXTENSION_UNLOADED_EVENT
     * @property {string} extensionId - Extension identifier.
     */
    av.EXTENSION_UNLOADED_EVENT       = 'extensionUnloaded';

    /**
     * Fired when the list of selected objects changes.
     * @event Autodesk.Viewing.Viewer3D#SELECTION_CHANGED_EVENT
     * @property {number[]} fragIdsArray - Fragment IDs of selected objects.
     * @property {number[]} dbIdArray - dbIDs of selected objects.
     * @property {number[]} nodeArray - Same as dbIdArray.
     * @property {object} model - Model data.
     */
    av.SELECTION_CHANGED_EVENT     = 'selection';
    /**
     * Fired when the list of selected objects changes in a multi-model context.
     * @event Autodesk.Viewing.Viewer3D#AGGREGATE_SELECTION_CHANGED_EVENT
     * @property {object[]} selections - List of objects containing the typical selection properties
     *   of {@link Autodesk.Viewing.Viewer3D#SELECTION_CHANGED_EVENT} for each model.
     */
    av.AGGREGATE_SELECTION_CHANGED_EVENT = 'aggregateSelection';
    /**
     * Fired when the viewer isolates a set of objects (i.e., makes everything else invisible or ghosted).
     * @event Autodesk.Viewing.Viewer3D#ISOLATE_EVENT
     * @property {number[]} nodeIdArray - List of isolated node IDs.
     * @property {object} model - Model data.
     */
    av.ISOLATE_EVENT               = 'isolate';
    /**
     * Fired when the viewer hides a set of objects.
     * @event Autodesk.Viewing.Viewer3D#HIDE_EVENT
     * @property {number[]} nodeIdArray - List of hidden node IDs.
     * @property {object} model - Model data.
     */
    av.HIDE_EVENT                  = 'hide';
    /**
     * Fired when the viewer shows a set of objects.
     * @event Autodesk.Viewing.Viewer3D#SHOW_EVENT
     * @property {number[]} nodeIdArray - List of shown node IDs.
     * @property {object} model - Model data.
     */
    av.SHOW_EVENT                  = 'show';

    /**
     * Fired when a camera changes.
     * @event Autodesk.Viewing.Viewer3D#CAMERA_CHANGE_EVENT
     * @property {object} camera - Affected camera.
     */
    av.CAMERA_CHANGE_EVENT         = 'cameraChanged';
    /**
     * Fired whenever the Explode tool is used.
     * @event Autodesk.Viewing.Viewer3D#EXPLODE_CHANGE_EVENT
     * @property {number} scale - Scale of the current exploded state.
     */
    av.EXPLODE_CHANGE_EVENT        = 'explodeChanged';
    /**
     * Fired when a ``fitToView`` operation is applied.
     * @event Autodesk.Viewing.Viewer3D#FIT_TO_VIEW_EVENT
     * @property {boolean} immediate - True if the change was immediate.
     * @property {number[]} nodeIdArray - List of node IDs fitted. Array is empty when fitting to the whole model. 
     * @property {object} model - Model data.
     */
    av.FIT_TO_VIEW_EVENT           = 'fitToView';
    /**
     * Fired when the cutting planes change.
     * @event Autodesk.Viewing.Viewer3D#CUTPLANES_CHANGE_EVENT
     * @property {object[]} planes - List of cutplanes.
     */
    av.CUTPLANES_CHANGE_EVENT      = 'cutplanesChanged';
    /**
     * Fired when a tool is activated or deactivated.
     * @event Autodesk.Viewing.Viewer3D#TOOL_CHANGE_EVENT
     * @property {string} toolName - Name of a specific mode of a tool.
     * @property {object} tool - Tool object.
     * @property {bool} active - Current status of the tool.
     */
    av.TOOL_CHANGE_EVENT           = 'toolChanged';
    /**
     * Fired when rendering options change.
     * @event Autodesk.Viewing.Viewer3D#RENDER_OPTION_CHANGED_EVENT
     */
    av.RENDER_OPTION_CHANGED_EVENT = 'renderOptionChanged';
    /**
     * Fired when the render frame shown by the Viewer is final or complete (it has
     * no more pending geometry or post processing effects which delay incoming frames),
     * or when the Viewer stops showing final frames.
     * @event Autodesk.Viewing.Viewer3D#FINAL_FRAME_RENDERED_CHANGED_EVENT
     * @property {object[]} planes - List of cut planes.
     */
    av.FINAL_FRAME_RENDERED_CHANGED_EVENT = 'finalFrameRenderedChanged';
    /**
     * Fired when the render has presented to the screen.
     * @event Autodesk.Viewing.Viewer3D#RENDER_PRESENTED_EVENT
     */
    av.RENDER_PRESENTED_EVENT = 'renderPresented';
    /**
     * Fired when visibility of a 2D layer changes.
     * @event Autodesk.Viewing.Viewer3D#LAYER_VISIBILITY_CHANGED_EVENT
     */
    av.LAYER_VISIBILITY_CHANGED_EVENT  = 'layerVisibility';
    /**
     * Fired when a model is reset to its initial configuration.
     * @deprecated
     * @event Autodesk.Viewing.Viewer3D#RESET_EVENT
     */
    av.RESET_EVENT                    = 'reset';

    /**
     * Fired when a user preference property changes.
     * @event Autodesk.Viewing.Viewer3D#PREF_CHANGED_EVENT
     * @property {string} name - Property name.
     * @property {object} value - New property value.
     */
    av.PREF_CHANGED_EVENT = 'PrefChanged';
    /**
     * Fired when a single user preference property is reset.
     * @event Autodesk.Viewing.Viewer3D#PREF_RESET_EVENT
     * @property {string} name - Property name.
     * @property {object} value - New property value.
     */
    av.PREF_RESET_EVENT = 'PrefReset';

    /**
     * Fired when the user clicks on the UI for restoring default settings.
     * Will get fired after all other Autodesk.Viewing.PREF_CHANGED_EVENT get fired.
     * @event Autodesk.Viewing.Viewer3D#RESTORE_DEFAULT_SETTINGS_EVENT
     */
    av.RESTORE_DEFAULT_SETTINGS_EVENT = 'restoreDefaultSettings';

    /**
     * Fired when animations are successfully initialized.
     * @event Autodesk.Viewing.Viewer3D#ANIMATION_READY_EVENT
     */
    av.ANIMATION_READY_EVENT = 'animationReady';

    /**
     * Fired when user clicks on a hyperlink embedded in the model.
     * @event Autodesk.Viewing.Viewer3D#HYPERLINK_EVENT
     * @property {object} data - Hyperlink data.
     */
    av.HYPERLINK_EVENT = 'hyperlink';

    av.LOAD_GEOMETRY_EVENT = 'load_geometry';

    /**
     * Navigation mode constants.
     *
     * These constants are used to define the Navigation mode.
     *
     * @enum {number}
     * @readonly
     * @deprecated
     */
    av.NAVIGATION_MODE = {
        ORBIT:  0,
        PAN:    1,
        DOLLY:  2,
        ROLL:   3,
        FOV:    4,
        TOUCH_PAN_DOLLY: 5,
        TOUCH_ROLL:      6,
        OTHER:           7
    };


    var isMobile = av.isMobileDevice();

    var nextViewerId = 0;

    av.DefaultSettings = {
        "ambientShadows": true,
        "antialiasing": !isMobile,
        "groundShadow": true,
        "groundReflection": false,
        "progressiveRendering": true,
        "renderCache": false,
        "swapBlackAndWhite": false,
        "openPropertiesOnSelect": false,
        "ghosting": true,
        "viewCube": !isMobile,
        "lineRendering": true,
        "pointRendering": true,
        "edgeRendering": false,
        "lightPreset": avp.DefaultLightPreset,
        "backgroundColorPreset": null,
        "reverseMouseZoomDir": false,
        "reverseHorizontalLookDirection": false,
        "reverseVerticalLookDirection": false,
        "alwaysUsePivot": false,
        "zoomTowardsPivot": false,
        "orbitPastWorldPoles": true,
        "leftHandedMouseSetup": false,
        "clickToSetCOI": false,
        "optimizeNavigation": isMobile,
        "fusionOrbit": true,
        "fusionOrbitConstrained": true,
        "envMapBackground" : false,
        "useFirstPersonPrototype": false,
        "firstPersonToolPopup" : true,
        "bimWalkToolPopup" : true
    };



    /**
     * Base class for all viewer implementations.
     *
     * It contains everything that is needed to connect to the Autodesk viewing service and display 3D models.
     * It also includes basic navigation support, and context menu and extension APIs.
     * @constructor
     * @param {HTMLElement} container - The viewer container.
     * @param {object} config - The initial settings object.
     * @param {boolean} [config.startOnInitialize=true] - Set this to false if you want to defer the run to a later time
     * by calling run() explicitly.
     * @property {Autodesk.Viewing.Navigation} navigation - The navigation api object.
     * @property {Autodesk.Viewing.ToolController} toolController - The tool controller object.
     * @property {Autodesk.Viewing.ViewingUtilities} utilities - The viewing utilities object.
	 * @alias Autodesk.Viewing.Viewer3D
     * @category Core
     */
    var Viewer3D = function(container, config)
    {
        if (typeof THREE === 'undefined') {
            avp.logger.warn('Initializing LMV without the THREE.js dependency is not supported.',
                'Call Autodesk.Viewing.Initializer() first or preload the dependencies manually.');
        }

        if (container) {
            this.clientContainer = container;
            this.container = document.createElement("div");
            this.container.className = "adsk-viewing-viewer";
            this.container.style.height = "100%";
            this.container.style.width = "100%";
            this.container.style.overflow = "hidden";

            this.container.classList.add( av.isTouchDevice() ? "touch" : "notouch");
            this.clientContainer.appendChild(this.container);

            this.config = config || av.createViewerConfig();
            this.contextMenu = null;
            this.contextMenuCallbacks = {};
            this.__firefoxLMBfix = false;
            this.started = false;


            // Create the canvas if it doesn't already exist
            if ( this.container.nodeName === "CANVAS") {
                throw 'Viewer must be initialized on a div [temporary]';
            }
            else
            {
                this.canvasWrap = document.createElement("div");
                this.canvasWrap.classList.add("canvas-wrap");

                this.canvas = document.createElement("canvas");
                this.canvas.tabIndex = 0;
                this.canvas.setAttribute('data-viewer-canvas', 'true');

                this.canvasWrap.appendChild(this.canvas);
                this.container.appendChild(this.canvasWrap);
            }

            this.canvas.viewer = this; //store a pointer to the viewer in the canvas

            var prefOptions = {
                // Preferences. Prefix is a bit odd, but a legacy result after refactoring.
                prefix: 'Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.',
                localStorage: true
            };
            this.prefs = new avp.Preferences(this, prefOptions);

        }

        this.extensionCache = null; // Reference passed from ViewingApplication
        this.running = false;
        this._pushedTool = '';
        this._defaultNavigationTool = '';
        this.id = nextViewerId++;
        this.impl = new avp.Viewer3DImpl(this.canvas, this);
        this.onResetEvent = this.onResetEvent.bind(this);
        //ADP
        this.trackADPTimer;
    };

    Viewer3D.populateConfigOptions = function(/*config*/) {
    };

    Viewer3D.prototype.constructor = Viewer3D;

    av.EventDispatcher.prototype.apply( Viewer3D.prototype );
    av.ScreenModeMixin.prototype.apply( Viewer3D.prototype );
    av.ExtensionMixin.prototype.apply( Viewer3D.prototype );


    /**
     * @deprecated
     * Use {@link Autodesk.Viewing.ScreenMode} instead.
     */
    Viewer3D.ScreenMode = av.ScreenMode;

    /**
     * Need to keep track of viewers in document so we know when it is safe
     * to call WGS.clearPropertyWorkerCache()
     */
    Viewer3D.ViewerCount = 0;

    /**
     * Default (and supported) values for how the viewer canvas will respond to click interaction.
     * If also provides a location to disable certain canvas features, such as:
     * "disableSpinner", "disableMouseWheel" and "disableTwoFingerSwipe".
     *
     * Refer to setCanvasClickBehavior() for additional info.
     */
    Viewer3D.kDefaultCanvasConfig = {
        "click": {
            "onObject": ["selectOnly"],
            "offObject": ["deselectAll"]
        },
        "clickAlt": {
            "onObject": ["setCOI"],
            "offObject": ["setCOI"]
        },
        "clickCtrl": {
            "onObject": ["selectToggle"]
            // don't deselect if user has control key down https://jira.autodesk.com/browse/LMV-1852
            //"offObject": ["deselectAll"]
        },
        "clickShift": {
            "onObject": ["selectToggle"]
            // don't deselect if user has shift key down https://jira.autodesk.com/browse/LMV-1852
            //"offObject": ["deselectAll"]
        },

        // Features that support disabling
        "disableSpinner": false,
        "disableMouseWheel": false,
        "disableTwoFingerSwipe": false
    };


    /**
     * Initializes the viewer and loads any extensions specified in the constructor's
     * config parameter. If the optional parameters are specified, the start() function will
     * use an optimized initialization sequence that results in faster model load.
     * The parameters are the same as the ones for Viewer3D.loadModel and you do not need to call loadModel
     * subsequently if the model is loaded via the call to start().
     *
     * @param {string} [url] - Optional URN or filepath to load on start.
     * @param {string} [options] - Optional path to shared property database.
     * @param {function} [onSuccessCallback] - Method that gets called when initial loading is done
     * and streaming starts.
     * @param {function} [onErrorCallback] - Method that gets called when initial loading ends with an error.
     * @returns {number} 0 if the viewer has started, an error code (same as that returned by initialize()) otherwise.
     */
    Viewer3D.prototype.start = function (url, options, onSuccessCallback, onErrorCallback) {
        if (this.started) {
            return 0;
        }
        this.started = true;

        var viewer = this;

        // Initialize the renderer and related stuff
        var result = viewer.initialize();
        if (result !== 0) {
            if (onErrorCallback) {
                setTimeout(function(){ onErrorCallback(result); }, 1);
            }
            return result;
        }

        //load extensions and set navigation overrides, etc.
        //Delayed so that it runs a frame after the long initialize() call.
        setTimeout(function() {viewer.setUp(viewer.config);}, 1);

        //If a model URL was given, kick off loading first, then initialize, otherwise just continue
        //with initialization immediately.
        if (url)
            this.loadModel(url, options, onSuccessCallback, onErrorCallback);

        return 0;
    };


    Viewer3D.prototype.registerUniversalHotkeys = function()
    {
        var self = this;

        var onPress;
        var onRelease;
        var previousTool;
        var keys = av.theHotkeyManager.KEYCODES;

/* // useful for debugging, when you want to force a redraw, hit "u" -
   // search on ""Autodesk.ForceUpdate" and uncomment that other popHotkeys line, too.
        // Add force update hotkey
        onPress = function() {
            self.impl.invalidate(true,true,true);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.ForceUpdate", [
            {
                keycodes: [keys.u],
                onPress: onPress
            }
        ]);
*/

        // Add Fit to view hotkey
        onPress = function() {
            self.navigation.setRequestFitToView(true);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.FitToView", [
            {
                keycodes: [keys.f],
                onPress: onPress
            }
        ]);

        // Add home hotkey
        onPress = function() {
            self.navigation.setRequestHomeView(true);
            return true;
        };
        av.theHotkeyManager.pushHotkeys("Autodesk.Home", [
            {
                keycodes: [keys.h],
                onPress: onPress
            },
            {
                keycodes: [keys.HOME],
                onPress: onPress
            }
        ]);

        // Escape
        onRelease = function() {
            // handle internal GUI components before firing the event to the client
            if (self.objectContextMenu && self.objectContextMenu.hide()) {
                return true;
            }

            // TODO: Could this all be unified somehow? If event listeners had priorities,
            //       we could intersperse listeners from the client and the viewer, which
            //       I think will eventually be required.

            self.dispatchEvent({ type: av.ESCAPE_EVENT });
            return true;
        };

        av.theHotkeyManager.pushHotkeys("Autodesk.Escape", [
            {
                keycodes: [keys.ESCAPE],
                onRelease: onRelease
            }
        ]);

        // Pan
        onPress = function() {
            previousTool = self.getActiveNavigationTool();
            return self.setActiveNavigationTool("pan");
        };
        onRelease = function() {
            return self.setActiveNavigationTool(previousTool);
        };
        var hotkeys = [
            {
                keycodes: [keys.SHIFT],
                onPress: onPress,
                onRelease: onRelease
            },
            {
                keycodes: [keys.SPACE],
                onPress: onPress,
                onRelease: onRelease
            }];
        av.theHotkeyManager.pushHotkeys("Autodesk.Pan", hotkeys, {tryUntilSuccess: true});
    };

    Viewer3D.prototype.createControls = function( ) {
        var self = this;
        var impl = self.impl;

        self.navigation = new av.Navigation(impl.camera);
        self.__initAutoCam(impl);

        self.utilities = new av.ViewingUtilities(impl, self.autocam, self.navigation);
        self.clickHandler = new av.DefaultHandler(impl, self.navigation, self.utilities);
        self.toolController = new av.ToolController(impl, self, self.autocam, self.utilities, self.clickHandler);
        self.toolController.registerTool( new av.GestureHandler(self) );

        self.toolController.registerTool( av.theHotkeyManager );
        self.toolController.activateTool( av.theHotkeyManager.getName() );

        self.registerUniversalHotkeys();

        self.toolController.registerTool( new av.OrbitDollyPanTool(impl, self) );

        return self.toolController;
    };



    /**
     * Create any DOM and canvas elements, and setup WebGL.
     *
     * @returns {number} 0 if initialization was successful, {@link Autodesk.Viewing.ErrorCode} otherwise.
     */
    Viewer3D.prototype.initialize = function()
    {

        //Set up the private viewer implementation
        this.setScreenModeDelegate(this.config ? this.config.screenModeDelegate : undefined);

        var dimensions = this.getDimensions();
        this.canvas.width = dimensions.width;
        this.canvas.height = dimensions.height;

        // For Safari and WKWebView and UIWebView on ios device with retina display,
        // needs to manually rescale our canvas to get the right scaling. viewport metatag
        // alone would not work.
        if (av.isIOSDevice() && window.devicePixelRatio) {
            this.canvas.width /= window.devicePixelRatio;
            this.canvas.height /= window.devicePixelRatio;
        }

        //Call this after setting canvas size above...
        this.impl.initialize();

        //Only run the WebGL failure logic if the renderer failed to initialize (otherwise
        //we don't have to spend time creating a GL context here, since we know it worked already
        if (!this.impl.glrenderer()) {
            var webGL = av.detectWebGL();
            if (webGL <= 0) {  // WebGL error.
                return webGL === -1 ? av.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED : av.ErrorCodes.BROWSER_WEBGL_DISABLED;
            }
        }

        var self = this;

        // Add a callback for the panels to resize when the viewer resizes.
        // For some reason, Safari iOS updates the DOM dimensions *after* the resize event,
        // so in that case we handle the resizing asynchronously.
        if (av.isIOSDevice()) {
            var _resizeTimer;
            this.onResizeCallback = function(e) {
                clearTimeout(_resizeTimer);
                _resizeTimer = setTimeout(self.resize.bind(self), 500);
            };
        } else {
            this.onResizeCallback = function(e) {
                self.resize();
            };
        }
        window.addEventListener('resize', this.onResizeCallback, false);

        this.initContextMenu();

        // Localize the viewer.
        this.localize();


        this.impl.controls = this.createControls();
        this.setDefaultNavigationTool( "orbit" );
        this.model = null;

        if( this.impl.controls )
            this.impl.controls.setAutocam(this.autocam);

        var canvasConfig = (this.config && this.config.canvasConfig) ? this.config.canvasConfig : Viewer3D.kDefaultCanvasConfig;
        this.setCanvasClickBehavior(canvasConfig);


        // Allow clients not load the spinner. This is needed for embedding viewer in a WebView on mobile,
        // where the spinner makes the UI looks less 'native'.
        if (!canvasConfig.disableSpinner) {

            // Create a div containing an image: this will be a
            // spinner (aka activity indicator) that tells the user
            // that the file is loading.
            //
            this.loadSpinner = document.createElement("div");
            this.loadSpinner.className = "spinner";
            this.container.appendChild(this.loadSpinner);

            // Generate circles for spinner
            for (var i=1; i<=3; i++) {
                var spinnerContainer = document.createElement("div");
                spinnerContainer.className = "bounce" + i;
                this.loadSpinner.appendChild(spinnerContainer);
            }
        }

        // Setup of AO, Ghosting, Env Lighting etc.
        this.initSettings();

        // Auxiliary class to get / restore the viewer state.
        this.viewerState = new avp.ViewerState( this );

        // The default behavior is to run the main loop immediately, unless startOnInitialize
        // is provided and is false.
        //
        if (!this.config || !this.config.hasOwnProperty("startOnInitialize") || this.config.startOnInitialize)
        {
            this.run();
        }

        window.NOP_VIEWER = this;

        this.addEventListener(av.RESTORE_DEFAULT_SETTINGS_EVENT, this.onResetEvent);
        this.dispatchEvent(av.VIEWER_INITIALIZED);

        this.trackADPSettingsOptions();

        Viewer3D.ViewerCount++;
        return 0;   // No Error initializing.
    };

    Viewer3D.prototype.setUp = function (config) {

        this.config = config;

        // Load the extensions specified in the config.
        //
        if (this.config && this.config.hasOwnProperty('extensions')) {
            var extensions = this.config.extensions;
            for (var i = 0; i < extensions.length; ++i) {
                this.loadExtension(extensions[i], this.config);
            }
        }

        //load debug ext by query param
        var debugConfig = avp.getParameterByName("lmv_viewer_debug");
        if (debugConfig == "true") {
            this.loadExtension("Autodesk.Debug", this.config);
        } 

        var canvasConfig = (this.config && this.config.canvasConfig) ? this.config.canvasConfig : Viewer3D.kDefaultCanvasConfig;
        this.setCanvasClickBehavior(canvasConfig);
    };

    Viewer3D.prototype.tearDown = function () {
        this.clearSelection();

        if (this.loadedExtensions) {
            for (var extensionId in this.loadedExtensions) {
                try {
                    // Extensions that fail to unload will end up terminating
                    // the viewer tearDown process.  Thus we protect from it
                    // here and log it (if available).
                    this.unloadExtension(extensionId);
                } catch (err) {
                    avp.logger.error("Failed to unload extension: " + extensionId, err, av.errorCodeString(av.ErrorCodes.VIEWER_INTERNAL_ERROR));
                    avp.logger.track(
                        {
                            category:"error_unload_extension",
                            extensionId: extensionId,
                            error_message: err.message,
                            call_stack: err.stack
                        });
                }
            }
            this.loadedExtensions = null;
        }

        // Deactivate mouse events and touch gestures. If a new model will be loaded, it will be enabled again (activateDefaultNavigationTools).
        if (this.toolController) {
            this.toolController.enableMouseButtons(false);
            this.toolController.deactivateTool("gestures");
        }

        avp.logger.reportRuntimeStats(true);

        if (this.loadSpinner)
            this.loadSpinner.style.display = "block";
        this.model = null;

        if (this.liveReviewClient) {
            this.liveReviewClient.destroy();
            this.liveReviewClient = null;
        }

        //Stop ADP tracking
        clearTimeout(this.trackADPTimer);

        this.impl.unloadCurrentModel();
    };

    Viewer3D.prototype.run = function()
    {
        if( !this.running ) {
            this.resize();
            this.running = true;
            this.impl.run();
        }
    };


    /**
     * Localize the viewer. This method can be overwritten so that the subclasses
     * can localize any additional elements.
     */
    Viewer3D.prototype.localize = function()
    {
        av.i18n.localize();
    };

    Viewer3D.prototype.__initAutoCam = function(impl)
    {
        var self = this;

        var ourCamera = impl.camera;

        if( !ourCamera.pivot )
            ourCamera.pivot = new THREE.Vector3(0, 0, 0);

        if( !ourCamera.target )
            ourCamera.target = new THREE.Vector3(0, 0, 0);

        if( !ourCamera.worldup )
            ourCamera.worldup = ourCamera.up.clone();

        function autocamChange(upChanged)
        {
            if( self.autocamCamera.isPerspective !== ourCamera.isPerspective )
            {
                if( self.autocamCamera.isPerspective )
                    self.navigation.toPerspective();
                else
                    self.navigation.toOrthographic();
            }
            self.navigation.setVerticalFov(self.autocamCamera.fov, false);
            self.navigation.setView(self.autocamCamera.position, self.autocamCamera.target);
            self.navigation.setPivotPoint(self.autocamCamera.pivot);
            self.navigation.setCameraUpVector(self.autocamCamera.up);
            if( upChanged )
                self.navigation.setWorldUpVector(self.autocamCamera.worldup);

            self.impl.syncCamera(upChanged);
        }

        function pivotDisplay(state)
        {
            if( self.utilities )
                self.utilities.pivotActive(state, false);
            else
                self.impl.controls.pivotActive(state, false);
        }

        self.autocamCamera = ourCamera.clone();
        self.autocamCamera.target = ourCamera.target.clone();
        self.autocamCamera.pivot  = ourCamera.pivot.clone();
        self.autocamCamera.worldup = ourCamera.worldup.clone();

        self.autocam  = new avp.Autocam(self.autocamCamera, self.navigation);
        self.autocam.cameraChangedCallback = autocamChange;
        self.autocam.pivotDisplayCallback = pivotDisplay;
        self.autocam.canvas = self.canvas;

        self.addEventListener("cameraChanged", function(evt)
        {
            var ourCamera = evt.camera;
            self.autocam.sync(ourCamera);
        });

        self.autocam.sync(ourCamera);
    };


    /**
     * Removes all created DOM elements and performs any GL uninitialization that is needed.
     */
    Viewer3D.prototype.uninitialize = function()
    {

        window.removeEventListener('resize', this.onResizeCallback, false);
        this.onResizeCallback = null;


        this.canvas.parentNode.removeChild(this.canvas);
        this.canvas.viewer = null;
        this.canvas = null;
        this.canvasWrap = null;

        this.viewerState = null;

        avp.logger.reportRuntimeStats();
        avp.logger.track({category:"viewer_destroy"}, true);

        if( this.toolController ) {
            this.toolController.uninitialize();
            this.toolController = null;
            this.clickHandler = null;
            this.utilities = null;
        }

        if (this.navigation) {
            this.navigation.uninitialize();
            this.navigation = null;
        }

        if (this.impl){
            this.impl.dtor();
            this.impl = null;
        }

        this.loadSpinner = null;
        this.model = null;
        this.prefs = null;

        this.autocam.dtor();
        this.autocam = null;
        this.autocamCamera = null;

        //av.theHotkeyManager.popHotkeys("Autodesk.ForceUpdate");
        av.theHotkeyManager.popHotkeys("Autodesk.FitToView");
        av.theHotkeyManager.popHotkeys("Autodesk.Home");
        av.theHotkeyManager.popHotkeys("Autodesk.Escape");
        av.theHotkeyManager.popHotkeys("Autodesk.Pan");
        av.theHotkeyManager.popHotkeys("Autodesk.Orbit");

        Viewer3D.ViewerCount--;
        if (Viewer3D.ViewerCount === 0) {
            WGS.clearPropertyWorkerCache();
        }

        if (this.onDefaultContextMenu) {
            this.container.removeEventListener('contextmenu', this.onDefaultContextMenu, false);
            this.onDefaultContextMenu = null;
        }

        if (this.screenModeDelegate) {
            this.screenModeDelegate.uninitialize();
            this.screenModeDelegate = null;
        }

        this.extensionCache = null;
        this.clientContainer = null;
        this.config = null;
        this.listeners = {};
        this.contextMenu = null;
        this.contextMenuCallbacks = null;

        if (this.viewCubeUi) {
            this.viewCubeUi.uninitialize();
            this.viewCubeUi = null;
        }

        if (this.container && this.container.parentNode)
            this.container.parentNode.removeChild(this.container);
        this.container = null;

        this.dispatchEvent(av.VIEWER_UNINITIALIZED);

        //forget all event listeners
        this.listeners = {};

        avp.logger.log("viewer destroy");
    };


    /**
     * Unloads any loaded extensions and then uninitializes the viewer.
     */
    Viewer3D.prototype.finish = function() {
        this.tearDown();
        this.uninitialize();
    };


    /**
     * @deprecated Use {@link Autodesk.Viewing.Viewer3D#loadModel} instead.
     * Load the file from the cloud or locally.
     * Asynchronously loads the document given its svfURN.
     * - on success: calls onDocumentLoadedCallback.
     * - on error: displays an error AlertBox.
     * @param {string} svfURN - The URN or filepath to load.
     * @param {string} [sharedPropertyDbPath] - Optional path to shared property database.
     * @param {function} [onSuccessCallback] - Method that gets called when initial loading is done
     * and streaming starts.
     * @param {function} [onErrorCallback] - Method that gets called when initial loading ends with an error.
     * @param {object} [loadOptions] - Optional load options passed to the model loader.
     */
    Viewer3D.prototype.load = function(svfURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback, acmSessionId, loadOptions)
    {
        avp.logger.warn('viewer.load() is deprecated. Please use viewer.loadModel() instead.');
        var options = {
            ids: null,
            sharedPropertyDbPath: sharedPropertyDbPath,
            acmSessionId: acmSessionId,
            loadOptions: loadOptions
        };
        return this.loadModel(svfURN, options, onSuccessCallback, onErrorCallback);
    };


    Viewer3D.prototype.setLoadHeuristics = function(options) {

        //Check for source file extension -- Revit and Navisworks are AEC/BIM models
        var bubbleNode = options.bubbleNode;
        if (bubbleNode && !options.hasOwnProperty("isAEC")) {
            var viewable = bubbleNode.findViewableParent();
            if (viewable) {
                var fileName = viewable.name();
                var fileExt = fileName.slice(fileName.length - 3).toLowerCase();
                if (fileExt === "rvt" || fileExt === "nwd" || fileExt === "nwc") {
                    options.isAEC = true;
                }
            }
        }

        //If it's an AEC model, use mesh conslidation unless explicitly turned off
        if (options.isAEC) {
            if (typeof options.useConsolidation === "undefined") {
                options.useConsolidation = !av.isMobileDevice();
            }
            if (typeof options.createWireframe === "undefined") {
                options.createWireframe = !av.isMobileDevice();
            }
        }

        //Make it possible to use multithreaded consolidation
        if (options.useConsolidation) {
            WGS.ConsolidationUtils.registerWorkerSupport(avp.createWorkerWithIntercept);
        }

        // When using consolidation, a too fine-grained bvh would eliminate the performance gain.
        // To avoid that, we use larger default settings when activating consolidation.
        //
        // Doing this for consolidation only is done to minimize the scope of potential side effects whenever consolidation is not used.
        // It might generally be useful to increase these values, but this requires more investigation of potential performance impact first.
        if (options.useConsolidation && !options.bvhOptions) {
            options.bvhOptions = {
                frags_per_leaf_node : 256,
                max_polys_per_node: 50000
            };
        }

    };

    /**
     * ADP
     */

    Viewer3D.prototype.trackADPSettingsOptions = function () {
        var self = this;
        this.trackADPTimer = setTimeout(function () {
            var settingOptionsStatus = {
                category : "settingOptionsStatus",
                switchSheetColorWhiteToBlack: self.prefs.swapBlackAndWhite,
                newFirstPersonToolPrototype: self.prefs.useFirstPersonPrototype,
                leftHandedMouseSetup: self.prefs.leftHandedMouseSetup,
                openPropertiesOnSelect: self.prefs.openPropertiesOnSelect,
                orbitPastWorldPoles: self.prefs.orbitPastWorldPoles,
                reverseMouseZoomDirection: self.prefs.reverseMouseZoomDir,
                fusionStyleOrbit: self.prefs.fusionOrbit,
                setPivotWithLeftMouseButton: self.prefs.clickToSetCOI,
                zoomTowardPivot: self.prefs.zoomTowardsPivot,
                viewCubeActsOnPivot : self.prefs.alwaysUsePivot,
                showViewCube: self.prefs.viewCube,
                environmentImageVisible: self.prefs.envMapBackground,
                displayEdges: self.prefs.edgeRendering,
                displayPoints: self.prefs.pointRendering,
                displayLines: self.prefs.lineRendering,
                ghostHiddenObjects: self.prefs.ghosting,
                groundReflection: self.prefs.groundReflection,
                groundShadow: self.prefs.groundShadow,
                ambientShadows: self.prefs.ambientShadows,
                antiAliasing: self.prefs.antialiasing,
                progressiveModelDisplay: self.prefs.progressiveRendering,
                smoothNavigation: self.prefs.optimizeNavigation
            };
            avp.logger.track(settingOptionsStatus);
        },30000);

    }

    /**
     * Loads a model into the viewer.
     * @param {string} url - The url to the model.
     * @param {object} [options] - An optional dictionary of options.
     * @param {Autodesk.Viewing.FileLoader} [options.fileLoader] - The file loader to use for this url.
     * @param {object} [options.loadOptions] - May contain params that are specific for certain loaders/filetypes.
     * @param {string} [options.sharedPropertyDbPath] - Optional path to shared property database.
     * @param {string} [options.ids] - A list of object IDs to load.
     * @param {function} [onSuccessCallback] - A method that gets called when initial loading is done
     * and streaming starts.
     * @param {function} [onErrorCallback] - A method that gets called when loading fails.
     */
    Viewer3D.prototype.loadModel = function(url, options, onSuccessCallback, onErrorCallback, onWorkerStart)
    {
        var self = this;
        
        options = options || {};

        function registerDimensionSpecificHotkeys() {
            if (!av.theHotkeyManager)
                return;

            if (self.model.is2d()) {
                // Remove 3D specific hotkeys
                av.theHotkeyManager.popHotkeys("Autodesk.Orbit");
            } else {
                // Add 3D specific hotkeys
                // Orbit
                var previousTool;
                var onPress = function() {
                    previousTool = self.getActiveNavigationTool();
                    return self.setActiveNavigationTool("orbit");
                };
                var onRelease = function() {
                    return self.setActiveNavigationTool(previousTool);
                };
                var hotkeys = [
                    {
                        keycodes: [av.theHotkeyManager.KEYCODES.ALT],
                        onPress: onPress,
                        onRelease: onRelease
                    }];
                av.theHotkeyManager.pushHotkeys("Autodesk.Orbit", hotkeys, {tryUntilSuccess: true});
            }
        }

        function activateDefaultNavigationTools() {
            if (av.isNodeJS)
                return;
            var defaultNavTool = (self.model.is2d()) ? "pan" : "orbit";
            self.setActiveNavigationTool(defaultNavTool);
            self.setDefaultNavigationTool(defaultNavTool);

            if (self.toolController) {
                self.toolController.enableMouseButtons(true);
                self.toolController.activateTool("gestures");
            }
        }

        var loaderInstance;
        function onDone( error, model ) {
            self.impl._removeLoadingFile(loaderInstance);
            if (error) {
                onError( error.code, error.msg, error.args );
                return;
            }

            var isFirstModel = false;
            if (!self.model) {
                self.model = model;
                isFirstModel = true;
            }
            self.impl.addModel(model);

            if (self.loadSpinner)
                self.loadSpinner.style.display = "None";

            if (isFirstModel) {
                if (model.is2d()) {
                    self.activateLayerState("Initial");
                }
                registerDimensionSpecificHotkeys();
                activateDefaultNavigationTools();
            }

            if (onSuccessCallback) {
                onSuccessCallback(model);
            }
        }

        function onError( errorCode, errorMessage, errorArgs ) {
            if (self.loadSpinner)
                self.loadSpinner.style.display = "None";
            if (onErrorCallback)
                onErrorCallback( errorCode, errorMessage, errorArgs );
        }

        // Force a repaint when a file is fully done loading
        function forceRepaint() {
            self.impl.needsRender = true;
            self.removeEventListener(av.GEOMETRY_LOADED_EVENT, forceRepaint);
        }
        this.addEventListener(av.GEOMETRY_LOADED_EVENT, forceRepaint);

        var match = url.toLowerCase().match(/\.([a-z0-9]+)(\?|$)/),
            fileExtension = match ? match[1] : null;

        var loader;
        if (options && options.fileLoader) {
            loader = options.fileLoader;
        } else {
            loader = av.FileLoaderManager.getFileLoaderForExtension(fileExtension);
        }

        // if there's no loader, don't try to create it and cause an error.
        if (!loader) {

            avp.logger.error("File extension not supported:" + fileExtension, av.errorCodeString(av.ErrorCodes.UNSUPORTED_FILE_EXTENSION));
            onError(av.ErrorCodes.UNSUPORTED_FILE_EXTENSION, "File extension not supported", 0, fileExtension);
            return false;
        }

        //Run some heuristics to adapt the viewing experience to the model we are about to display
        this.setLoadHeuristics(options);

        avp.processMemoryOptions(this.config);
        loaderInstance = new loader(this.impl._loaderDelegate, this.config);
        var returnValue = loaderInstance.loadFile(url, options, onDone, onWorkerStart );

        //If we know that the model is going to use a specific light preset, trigger the environment map
        //change as early as possible (i.e. not on addModel ) in order to avoid a flash from the old map to the new
        //one that happens if the change is delayed until addModel.
        if (options.isAEC && loaderInstance.is3d())
            this.impl.setLightPresetForAec();

        return returnValue;
    };


    /**
     * @returns {object} Client rectangle bounds.
     */
    Viewer3D.prototype.getDimensions = function() {
        if (this.container) {
            // NB: Getting dimensions of the client container instead of the container.
            //     At least in IE11, getting dimensions on the dynamically created
            //     child of the dynamically created parent returns a 0 height.
            var rect = {};
            if (this.getScreenMode() === av.ScreenMode.kFullScreen) {
                rect.width = screen.width;
                rect.height = screen.height;
            } else {
                rect = this.container.getBoundingClientRect();
            }

            return {
                width: rect.width,
                height: rect.height
            };
        }

        return null;
    };


    /**
     * Resizes the viewer.
     */
    Viewer3D.prototype.resize = function()
    {
        return this.impl.resize(this.container.clientWidth, this.container.clientHeight);
    };

    /**
     * Gets the camera so it can be modified by the client.
     * @returns {THREE.Camera} The active camera.
     */
    Viewer3D.prototype.getCamera = function()
    {
        return this.impl.camera;
    };

    /**
     * Gets the view state as a plain object.
     *
     * @param {object} [filter] - Specifies which viewer values to get.
     * @returns {object} Viewer state.
     */
    Viewer3D.prototype.getState = function( filter ) {
        return this.viewerState.getState(filter);
    };

    /**
     * Restores the viewer state from a given object.
     * @param {Object} viewerState
     * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
     * that should not be restored.
     * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false).
     * @returns {boolean} True if restore operation was successful.
     */
    Viewer3D.prototype.restoreState = function (viewerState, filter, immediate)  {
        var success = this.viewerState.restoreState(viewerState, filter, immediate);
        if (success) {
            this.dispatchEvent({ type: av.VIEWER_STATE_RESTORED_EVENT, value: success });
        }
        return success;
    };

    /**
     * Sets the view from an array of parameters.
     * @param {array} params - View parameters:
     * - position-x
     * - position-y
     * - position-z
     * - target-x
     * - target-y
     * - target-z
     * - up-x
     * - up-y
     * - up-z
     * - aspect
     * - fov (radians)
     * - orthoScale
     * - isPerspective (0=perspective, 1=ortho)
     */
    Viewer3D.prototype.setViewFromArray = function(params, name)
    {
        //TODO: It might be best to get rid of the setViewFromArray API as it's not
        //very descriptive, and move the params->camera conversion to the bubble-reading
        //logic in ViewingApplication.

        //Make sure to apply any internal translation offset to the input camera
        var off = this.model ? this.model.getData().globalOffset : { x:0, y:0, z:0 };
        var camera = {
            position: new THREE.Vector3(params[0] - off.x, params[1] - off.y, params[2] - off.z),
            target: new THREE.Vector3(params[3] - off.x, params[4] - off.y, params[5] - off.z),
            up: new THREE.Vector3(params[6], params[7], params[8]),
            aspect: params[9],
            fov: THREE.Math.radToDeg(params[10]),
            orthoScale: params[11],
            isPerspective: !params[12]
        };

        this.impl.setViewFromCamera(camera);
    };

    /**
     * Sets the view from an array representing a view box.
     *
     * Not applicable to 3D.
     *
     * @param {array} viewbox - View parameters:
     * - min-x
     * - min-y
     * - max-x
     * - max-y
     * @param {string} [name] - Optional named view name to also set the layer visibility state
     * associated with this view.
     */
    Viewer3D.prototype.setViewFromViewBox = function (viewbox, name)
    {
        var model = this.model;

        if( model && !model.is2d() )
        {
            avp.logger.warn("Viewer3D.setViewFromViewBox is not applicable to 3D");
            return;
        }

        //set the layer state if any
        //It's annoying to search the views and states as arrays,
        //but this is the only place we do this, so converting them
        //to hashmaps is not necessary (yet).
        if (name && name.length) {
            var metadata = model.getData().metadata;
            var views = metadata.views;

            var i;
            for (i=0; i<views.length; i++) {
                if (views[i].name == name)
                    break;
            }

            if (i < views.length) {
                var state_name = views[i].layer_state;
                if (state_name)
                    this.activateLayerState(state_name);
            }
        }

        //Finally set the camera
        this.impl.setViewFromViewBox(this.model, viewbox, name, false);
    };

    /**
     * Changes the active layer state.
     * Get a list of all available layerStates and their active status through
     * {@link Autodesk.Viewing.Viewer3D#getLayerStates}.
     *
     * @param {string} stateName - Name of the layer state to activate.
     */
    Viewer3D.prototype.activateLayerState = function(stateName)
    {
        if (stateName && stateName.length) {
            var metadata = this.model.getData().metadata;
            var states = (metadata ? metadata.layer_states : null);
            if (!states) {
                return;
            }

            var j;
            for (j=0; j<states.length; j++) {
                if (states[j].name == stateName)
                    break;
            }

            if (j < states.length) {
                var layer_state = states[j];
                var visible = layer_state.visible_layers;

                var visMap = {};
                if (visible && 0 < visible.length) {
                    for (var k=0; k<visible.length; k++)
                        visMap[visible[k]] = 1;
                }

                var onlayers = [];
                var offlayers = [];

                for (var l in metadata.layers) {
                    var lname = metadata.layers[l].name;
                    if (visMap[lname] === 1) {
                        onlayers.push(l);
                    } else {
                        offlayers.push(l);
                    }
                }

                this.impl.setLayerVisible(onlayers, true);
                this.impl.setLayerVisible(offlayers, false);

                this.dispatchEvent({type: av.LAYER_VISIBILITY_CHANGED_EVENT});
            }
        }
    };

    /**
     * Returns information for each layer state: name, description, active.
     * Activate a state through {@link Autodesk.Viewing.Viewer3D#activateLayerState}.
     * @returns {array}
     */
    Viewer3D.prototype.getLayerStates = function () {
        var model = this.model,
            metadata = model ? model.getData().metadata : null,
            layers = metadata ? metadata.layers : null,
            layer_states = metadata ? metadata.layer_states : null;

        // No layers or no layer states? Nothing to do.
        //
        if (!layers || !layer_states) {
            return null;
        }

        // Which layers are currently visible?
        //
        var layerName,
            layerNames = {},
            currentVisibleLayers = {};

        for (var layer in layers) {
            if (layers.hasOwnProperty(layer)) {
                var index = parseInt(layer),
                    defn = layers[layer];

                layerName = (typeof defn === 'string') ? defn : defn.name;
                layerNames[layerName] = true;

                if (this.impl.isLayerVisible(index)) {
                    currentVisibleLayers[layerName] = true;
                }
            }
        }

        // Shallow equal()
        //
        function equal(a, b) {
            var aProps = Object.getOwnPropertyNames(a),
                bProps = Object.getOwnPropertyNames(b);

            if (aProps.length !== bProps.length) {
                return false;
            }

            for (var i = 0; i < aProps.length; ++i) {
                var propName = aProps[i];
                if (a[propName] !== b[propName]) {
                    return false;
                }
            }

            return true;
        }

        var layerStates = [],
            i, j;

        for (i = 0; i < layer_states.length; ++i) {
            var layer_state = layer_states[i],
                visible_layers = layer_state.visible_layers,
                layerStateVisibleLayers = {};

            if (!layer_state.hidden) { // Ignore hidden layer states
                if (visible_layers && 0 < visible_layers.length) {
                    for (j = 0; j < visible_layers.length; ++j) {
                        layerName = visible_layers[j];
                        if (layerNames.hasOwnProperty(layerName)) { // Ignore layers we don't know about
                            layerStateVisibleLayers[layerName] = true;
                        }
                    }
                }

                layerStates.push({
                    name: layer_state.name,
                    description: layer_state.description,
                    active: equal(currentVisibleLayers, layerStateVisibleLayers)
                });
            }
        }
        return (0 < layerStates.length) ? layerStates : null;
    };

    /**
     * Sets the view using the default view in the source file.
     */
    Viewer3D.prototype.setViewFromFile = function()
    {
        this.setActiveNavigationTool();
        this.impl.setViewFromFile(this.model);
    };

    /**
     * Gets the properties for an ID. Once the properties are returned,
     * the method raises a onPropertiesReady event.
     * @param {number} dbid
     * @param {function} [onSuccessCallback] - Call this callback once the properties are found.
     * @param {function} [onErrorCallback] - Call this callback if the properties are not found,
     * or another error occurs.
     */
    Viewer3D.prototype.getProperties = function(dbid, onSuccessCallback, onErrorCallback)
    {
        avp.logger.track({ name: 'get_props_count', aggregate: 'count' });

        if (this.model) {
            this.model.getProperties(dbid, onSuccessCallback, onErrorCallback);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "Properties failed to load since model does not exist");
        }
    };

    /**
     * Gets the viewer model object tree. Once the tree is received it will invoke the specified callback function.
     *
     * You can use the model object tree to get information about items in the model.  The tree is made up
     * of nodes, which correspond to model components such as assemblies or parts.
     *
     * @param {function} [onSuccessCallback] - Call this callback once the object tree is loaded.
     * @param {function} [onErrorCallback] - Call this callback if the object tree is not found.
     */
    Viewer3D.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback)
    {
        if (this.model) {
            this.model.getObjectTree(onSuccessCallback, onErrorCallback);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "ObjectTree failed to load since model does not exist");
        }
    };

    /**
     * Sets the click behavior on the canvas to follow config.
     * This is used to change the behavior of events such as selection or COI changed.
     * @example
     *  {
     *       "click": {
     *           "onObject": [ACTIONS],
     *           "offObject": [ACTIONS]
     *       },
     *       "clickCtrl": {
     *           "onObject": [ACTIONS],
     *           "offObject": [ACTIONS]
     *       },
     *       "clickShift": {
     *           ...
     *       },
     *       "clickCtrlShift": {
     *           ...
     *       },
     *       "disableSpinner": BOOLEAN
     *       "disableMouseWheel": BOOLEAN,
     *       "disableTwoFingerSwipe": BOOLEAN
     *  }
     *
     * Actions can be any of the following:
     * - selectOnly
     * - selectToggle
     * - deselectAll
     * - isolate
     * - showAll
     * - setCOI
     * - focus
     * - hide
     * @param {object} config - Parameter object that meets the above layout.
     */
    Viewer3D.prototype.setCanvasClickBehavior = function(config)
    {
        if (this.impl.controls.hasOwnProperty("setClickBehavior"))
            this.impl.controls.setClickBehavior(config);

        if( this.clickHandler )
            this.clickHandler.setClickBehavior(config);

        if (config && config.disableMouseWheel) {
            this.toolController.setMouseWheelInputEnabled(false);
        }

        if (config && config.disableTwoFingerSwipe) {
            var gestureHandler = this.toolController.getTool("gestures");
            if (gestureHandler) {
                gestureHandler.disableTwoFingerSwipe();
            }
        }
    };

    /**
     * Searches the elements for the given text. When the search is complete,
     * the callback onResultsReturned(idArray) is invoked.
     * @param {string} text - The search term (not case sensitive).
     * @param {function} onSuccessCallback - The callback to invoke when search is complete.
     * @param {function} onErrorCallback - The callback to invoke when search is complete.
     * @param {string[]} [attributeNames] - Restricts search to specific attribute names.
     */
    Viewer3D.prototype.search = function(text, onSuccessCallback, onErrorCallback, attributeNames, completeInfo)
    {
        this.searchText = text;

        if (this.model) {
            this.model.search(text, onSuccessCallback, onErrorCallback, attributeNames, completeInfo);
        }
        else {
            if (onErrorCallback)
                onErrorCallback(av.ErrorCodes.BAD_DATA, "Search failed since model does not exist");
        }
    };

    /**
     * Returns an array of the IDs of the currently hidden nodes.
     * When isolation is in place, there are no hidden nodes returned because
     * all nodes that are not isolated are considered hidden.
     *
     * @returns {array} Array of nodes that are currently hidden, when no isolation is in place.
     */
    Viewer3D.prototype.getHiddenNodes = function () {
        return this.impl.visibilityManager.getHiddenNodes();
    };

    /**
     * Returns an array of the IDs of the currently isolated nodes.
     *
     * Not yet implemented for 2D.
     *
     * @returns {array} Array of nodes that are currently isolated.
     */
    Viewer3D.prototype.getIsolatedNodes = function () {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getIsolatedNodes is not yet implemented for 2D");
            return [];
        }

        return this.impl.visibilityManager.getIsolatedNodes();
    };

    /**
     * Isolates one of many sub-elements. You can pass in a node or an array of nodes to isolate.
     * Pass in null to reset isolation.
     *
     * @param {number[]|number} node - A node ID or array of node IDs from the model tree {@link BaseViewer#getObjectTree}.
     */
    Viewer3D.prototype.isolate = function(node)
    {
        if (!this.model) {
            // Silently abort //
            return;
        }

        var data = this.model.getData();
        if (data && data.is2d && data.loadDone && 'hasObjectProperties' in data) {
            // some 2d datasets have no instance-tree, but just a flat list of object properties.
            // Here, we can call isolate directly without requesting the instanceTree first.
            this.impl.visibilityManager.isolate(node);
        } else {
            // request instance tree first
            var self = this;
            this.model.getObjectTree(function () {
                self.impl.visibilityManager.isolate(node);
            });
        }
    };


    /**
     * @deprecated Isolates one of many sub-elements. You can pass in a dbid or an array of dbid to isolate.
     *
     * Not yet implemented for 2D.
     *
     * @param {array|number} dbids - Either an array or a single integer.
     */
    Viewer3D.prototype.isolateById = function(dbIds) {

        avp.logger.warn("isolateById() is deprecated. Use isolate() instead.");
        return this.isolate(dbIds);

    };

    /**
     * Sets the background color.
     * @param {number} red
     * @param {number} green
     * @param {number} blue
     * @param {number} red2
     * @param {number} green2
     * @param {number} blue2
     */
    Viewer3D.prototype.setBackgroundColor = function(red, green, blue, red2, green2, blue2)
    {
        this.impl.setClearColors(red, green, blue, red2, green2, blue2);
    };

    /**
     * Toggles the selection for a given dbid.
     * If it was unselected, it is selected.
     * If it was selected, it is unselected.
     * 
     * Currently three ways of node selection are supported:
     * - Autodesk.Viewing.SelectionMode.MIXED
     *   - Leaf nodes are selected using OVERLAYED and inner nodes are selected using REGULAR selection type.
     * - Autodesk.Viewing.SelectionMode.REGULAR
     *   - Nodes are tinted with the selection color.
     * - Autodesk.Viewing.SelectionMode.OVERLAYED
     *   - Nodes are tinted with the selection color and shown on top of the not selected geometry.
     * 
     * Not yet implemented for 2D.
     *
     * @param {number} dbid
     * @param {number} selectionType a member of Autodesk.Viewing.SelectionMode.
     */
    Viewer3D.prototype.toggleSelect = function(dbid, selectionType)
    {
        if( this.model && this.model.is2d() )
        {
            // Fails because Model.getNodeById is not supported.
            avp.logger.warn("Viewer3D.toggleSelect is not yet implemented for 2D");
            return;
        }

        this.impl.selector.toggleSelection(dbid, this.model, selectionType);
    };

    /**
     * Selects the array of ids. You can also just pass in a single id instead of an array.
     * 
     * Currently three ways of node selection are supported:
     * - Autodesk.Viewing.SelectionMode.MIXED
     *   - Leaf nodes are selected using OVERLAYED and inner nodes are selected using REGULAR selection type.
     * - Autodesk.Viewing.SelectionMode.REGULAR
     *   - Nodes are tinted with the selection color.
     * - Autodesk.Viewing.SelectionMode.OVERLAYED
     *   - Nodes are tinted with the selection color and shown on top of the not selected geometry.
     * 
     * @param {number[]|number} dbids
     * @param {number} selectionType a member of Autodesk.Viewing.SelectionMode.
     */
    Viewer3D.prototype.select = function(dbids, selectionType)
    {
        if (typeof dbids === "number") {
            dbids = [dbids];
        }

        this.impl.selector.setSelection(dbids, this.model, selectionType);
    };


    /**
     * Clears the selection.
     */
    Viewer3D.prototype.clearSelection = function()
    {
        this.impl.selector.clearSelection();
    };

    /**
     * Returns information about the visibility of the current selection.
     * @returns {object} `{hasVisible:boolean, hasHidden:boolean}`
     */
    Viewer3D.prototype.getSelectionVisibility = function () {
        return this.impl.selector.getSelectionVisibility();
    };

    /**
     * Returns the number of nodes in the current selection.
     * @returns {number}
     */
    Viewer3D.prototype.getSelectionCount = function () {
        return this.impl.selector.getSelectionLength();
    };

    /**
     * Sets selection granularity mode. Supported values are:
     * - Autodesk.Viewing.SelectionMode.LEAF_OBJECT
     *   - Always select the leaf objects in the hierarchy.
     * - Autodesk.Viewing.SelectionMode.FIRST_OBJECT
     *   - For a given node, selects the first non-composite (layer, collection, model)
     *   on the path from the root to the given node, and all children.
     * - Autodesk.Viewing.SelectionMode.LAST_OBJECT
     *   - For a given node, selects the nearest ancestor composite node and all children.
     *   Selects the input node itself in case there is no composite node in the path to the root node.
     */
    Viewer3D.prototype.setSelectionMode = function (mode) {
        this.impl.selector.setSelectionMode(mode);
    };


    /**
     * Returns the current selection.
     * @returns {number[]} Array of the IDs of the currently selected nodes.
     */
    Viewer3D.prototype.getSelection = function () {
        return this.impl.selector.getSelection();
    };

    /**
     * Returns the selected items from all loaded models.
     * @param {function} [callback] - Optional callback to receive enumerated pairs of model and dbId
     * for each selected object. If no callback is given, an array of objects is returned.
     * @returns {object[]} An array of objects with a model and selectionSet properties for each model
     * that has selected items in the scene.
     */
    Viewer3D.prototype.getAggregateSelection = function(callback) {
        var res = this.impl.selector.getAggregateSelection();

        if (callback) {
            for (var i=0; i<res.length; i++) {
                for (var j=0; j<res[i].selection.length; j++) {
                    callback(res[i].model, res[i].selection[j]);
                }
            }
        }

        return res;
    };

    /**
     * Ensures the passed in dbid / ids are hidden.
     *
     * @param {number[]|number} node
     */
    Viewer3D.prototype.hide = function(node)
    {
        avp.logger.track({ name: 'hide', aggregate: 'count' });

        this.impl.visibilityManager.hide(node);
    };

    /**
     * @deprecated Use {@link Autodesk.Viewing.Viewer3D#hide} instead.
     *
     * @param {number} nodeId
     */
    Viewer3D.prototype.hideById = function(nodeId)
    {
        this.hide(nodeId);
    };

    /**
     * Ensures the passed in dbid / ids are shown.
     *
     * @param {number[]|number} node
     */
    Viewer3D.prototype.show = function(node)
    {
        this.impl.visibilityManager.show(node);
    };

    /**
     * Ensures everything is visible. Clears all node isolation (3D) and turns on all layers (2D).
     */
    Viewer3D.prototype.showAll = function()
    {
        this.impl.visibilityManager.isolate();
        if (this.model.is2d()) {
            this.setLayerVisible(null, true);
        }
    };


    /**
     * Toggles the visibility of the given node.
     *
     * Not yet implemented for 2D.
     *
     * @param {number} node
     */
    Viewer3D.prototype.toggleVisibility = function(node)
    {
        this.impl.visibilityManager.toggleVisibility(node);
    };

    /**
     * Returns true if every node is visible.
     * @returns {boolean}
     */
    Viewer3D.prototype.areAllVisible = function() {
        return this.impl.isWholeModelVisible(this.model);
    };

    /**
     * Returns true if the specified node is visible.
     * The model argument is required only when in multi-model scenarios.
     *
     * @param {number} nodeId - Geometry node to check if visible.
     * @param {Autodesk.Viewing.Model} [model] - The model that contains the specified ``nodeId``.
     * 
     * @returns {boolean}
     */
    Viewer3D.prototype.isNodeVisible = function(nodeId, model) {
        model = model || this.model;
        return this.impl.isNodeVisible(nodeId, model);
    };

    /**
     * Explodes the model from the center of gravity.
     *
     * Not applicable to 2D.
     *
     * @param {number} scale - A value from 0.0-1.0 to indicate how much to explode.
     */
    Viewer3D.prototype.explode = function( scale)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.explode is not applicable to 2D");
            return;
        }

        avp.logger.track({ name: 'explode_count', aggregate: 'count' });

        this.impl.explode(scale);
    };

    /**
     * Returns the explode scale.
     *
     * Not applicable to 2D.
     *
     * @returns {number} - A value from 0.0-1.0 indicating how exploded the model is.
     */
    Viewer3D.prototype.getExplodeScale = function()
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getExplodeScale is not applicable to 2D");
            return 0;
        }

        return this.impl.getExplodeScale();
    };


    /**
     * Enables or disables the high quality rendering settings.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} useSAO - True or false to enable screen space ambient occlusion.
     * @param {boolean} useFXAA - True or false to enable fast approximate anti-aliasing.
     */
    Viewer3D.prototype.setQualityLevel = function(useSAO, useFXAA)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setQualityLevel is not applicable to 2D");
            return;
        }

        this.prefs.set('ambientShadows', useSAO);
        this.prefs.set('antialiasing', useFXAA);
        this.impl.togglePostProcess(useSAO, useFXAA);
    };


    /**
     * Toggles ghosting during search and isolate.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether ghosting is on or off.
     */
    Viewer3D.prototype.setGhosting = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGhosting is not applicable to 2D");
            return;
        }

        this.prefs.set('ghosting', value);
        this.impl.toggleGhosting(value);
    };

    /**
     * Toggles ground shadow.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether shadow is on or off.
     */
    Viewer3D.prototype.setGroundShadow = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundShadow is not applicable to 2D");
            return;
        } else if ( this.getMemoryInfo() ) {
            avp.logger.warn("Viewer3D.setGroundShadow is not available when memory is limited");
            return;
        }

        this.prefs.set('groundShadow', value);
        this.impl.toggleGroundShadow(value);
    };

    /**
     * Toggles ground reflection.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether reflection is on or off.
     */
    Viewer3D.prototype.setGroundReflection = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundReflection is not applicable to 2D");
            return;
        } else if ( this.getMemoryInfo() ) {
            avp.logger.warn("Viewer3D.setGroundReflection is not available when memory is limited");
            return;
        }

        this.prefs.set('groundReflection', value);
        this.impl.toggleGroundReflection(value);
    };

    /**
     * Toggles environment map for background.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether environment map for background is on or off.
     */
    Viewer3D.prototype.setEnvMapBackground = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setEnvMapBackground is not applicable to 2D");
            return;
        }

        this.prefs.set('envMapBackground', value);
        this.impl.toggleEnvMapBackground(value);
    };

    /**
     * Toggles first person tool popup.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether first person tool popup is showed or not.
     */
    Viewer3D.prototype.setFirstPersonToolPopup = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setFirstPersonToolPopup is not applicable to 2D");
            return;
        }

        this.prefs.set('firstPersonToolPopup', value);
    };

    /**
     * Returns the state of first person tool popup
     *
     * Not applicable to 2D.
     *
     * @returns {boolean} value is indicating whether first person tool popup is showed or not
     */
    Viewer3D.prototype.getFirstPersonToolPopup = function()
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getFirstPersonToolPopup is not applicable to 2D");
            return;
        }

        return this.prefs.firstPersonToolPopup;
    };

    /**
     * Toggles bimwalk tool popup.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether first person tool popup is showed or not.
     */
    Viewer3D.prototype.setBimWalkToolPopup = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setBimWalkToolPopup is not applicable to 2D");
            return;
        }

        this.prefs.set('bimWalkToolPopup', value);
    };

    /**
     * Toggles rendercache feature.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value - Indicates whether render cache is active or not.
     */
    Viewer3D.prototype.setRenderCache = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setRenderCache is not applicable to 2D");
            return;
        }

        this.impl.toggleVizBuffer(value);
        this.prefs.set('renderCache', value);
    };
    
    /**
     * Returns the state of first person tool popup
     *
     * Not applicable to 2D.
     *
     * @returns {boolean} value is indicating whether first person tool popup is showed or not
     */
    Viewer3D.prototype.getBimWalkToolPopup = function()
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getBimWalkToolPopup is not applicable to 2D");
            return;
        }

        return this.prefs.bimWalkToolPopup;
    };

    /**
     * Toggles whether progressive rendering is used. Warning: turning progressive rendering off
     * will have serious performance implications.
     * @param {boolean} value whether it is on or off
     */
    Viewer3D.prototype.setProgressiveRendering = function(value)
    {
        this.prefs.set('progressiveRendering', value);
        this.impl.toggleProgressive(value);
    };

    /**
     * AutoCAD drawings are commonly displayed with white lines on a black background. Setting reverse swaps (just)
     * these two colors.
     * @param {boolean} value whether it is on or off
     */
    Viewer3D.prototype.setSwapBlackAndWhite = function(value)
    {
        this.prefs.set('swapBlackAndWhite', value);
        this.impl.toggleSwapBlackAndWhite(value);
    };

    /**
     * Toggles whether the navigation should be optimized for performance. If set
     * to true, anti-aliasing and ambient shadows will be off while navigating.
     *
     * Not applicable to 2D.
     *
     * @param {boolean} value whether it is on or off
     */
    Viewer3D.prototype.setOptimizeNavigation = function(value)
    {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setOptimizeNaviation is not applicable to 2D");
            return;
        }

        this.prefs.set('optimizeNavigation', value);
        this.impl.setOptimizeNavigation(value);
    };

    /**
     * Locks or unlocks navigation controls.
     *
     * When navigation is locked, certain operations (for example, orbit, pan, or fit-to-view)
     * are disabled.
     *
     * @param {boolean} value True if the navigation should be locked.
     *
     * @see {@link Autodesk.Viewing.Viewer3D#setNavigationLockSettings}
     */
    Viewer3D.prototype.setNavigationLock = function(value)
    {
        if (this.navigation.getIsLocked() !== value) {
            this.navigation.setIsLocked(value);
            this.dispatchEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getActiveNavigationTool() });
        }
    };

    /**
     * Gets the current state of the navigation lock.
     * @returns {boolean} True if the navigation controls are currently locked.
     */
    Viewer3D.prototype.getNavigationLock = function()
    {
        return this.navigation.getIsLocked();
    };

    /**
     * Updates the configuration of the navigation lock,
     * i.e., which actions are available when navigation is locked.
     *
     * The configurable actions are 'orbit', 'pan', 'zoom', 'roll', 'fov', 'walk', or 'gotoview'.
     * By default, none of the actions are enabled when the navigation is locked.
     *
     * @param {object} settings Map of <action>:<boolean> pairs specifying
     * whether the given action is *enabled* even when the navigation is locked.
     *
     * @see {@link Autodesk.Viewing.Viewer3D#setNavigationLock}
     */
    Viewer3D.prototype.setNavigationLockSettings = function(settings)
    {
        this.navigation.setLockSettings(settings);
        this.dispatchEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getActiveNavigationTool() });
    };

    /**
     * Gets the current configuration of the navigation lock.
     *  @returns {object} Map of <action>:<boolean> pairs specifying
     * whether the given action is *enabled* even when the navigation is locked.
     */
    Viewer3D.prototype.getNavigationLockSettings = function()
    {
        return this.navigation.getLockSettings();
    };

    /**
     * Swaps the current navigation tool for the tool with the provided name.
     * Will trigger NAVIGATION_MODE_CHANGED event if the mode actually changes.
     *
     * @param {string} [toolName] - The name of the tool to activate. By default it will switch to the default tool.
     *
     * @returns {boolean} - True if the tool was set successfully. False otherwise.
     *
     * @see {@link Viewer3D#getActiveNavigationTool|getActiveNavigationTool()}
     */
    Viewer3D.prototype.setActiveNavigationTool = function(toolName)
    {
        if(toolName === this._pushedTool || (!toolName && !this._pushedTool))
            return true;

        if( this._pushedTool ) {
            if( !this.impl.controls.deactivateTool(this._pushedTool) ) {
                return false;
            }

            // Need to reset the activeName of the default tool, since "orbit",
            // "freeorbit", "dolly" and "pan" share the same instance.
            this.impl.controls.setToolActiveName(this.getDefaultNavigationToolName());
            this._pushedTool = null;
        }

        var isDefault = !toolName || toolName === this.getDefaultNavigationToolName();

        if (isDefault && this._pushedTool === null) {
            this.dispatchEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this.getDefaultNavigationToolName() });
            return true;
        }

        if( this.impl.controls.activateTool(toolName) ) {
            this._pushedTool = toolName;
            this.dispatchEvent({ type: av.NAVIGATION_MODE_CHANGED_EVENT, id: this._pushedTool });
            return true;
        }

        return false;
    };

    /**
     * Returns the name of the active navigation tool.
     * @returns {string} - The tool's name.
     *
     * @see {@link Viewer3D#setActiveNavigationTool|setActiveNavigationTool()}
     */
    Viewer3D.prototype.getActiveNavigationTool = function()
    {
        return this._pushedTool ? this._pushedTool : this._defaultNavigationTool;
    };

    /**
     * Sets the default navigation tool. This tool will always sit beneath the navigation tool on the tool stack.
     *
     * @param {string} toolName - The name of the new default navigation tool.
     */
    Viewer3D.prototype.setDefaultNavigationTool = function(toolName)
    {
        if (this._defaultNavigationTool) {
            this.impl.controls.deactivateTool(this._defaultNavigationTool);
        }

        if (this._pushedTool) {
            this.impl.controls.deactivateTool(this._pushedTool);
        }

        this.impl.controls.activateTool(toolName);
        this._defaultNavigationTool = toolName;

        if (this._pushedTool) {
            this.impl.controls.activateTool(this._pushedTool);
        }
    };

    /**
     * Returns the default navigation tool
     *
     * @returns {Object} - The default navigation tool.
     */
    Viewer3D.prototype.getDefaultNavigationToolName = function()
    {
        return this._defaultNavigationTool;
    };

    /**
     * Gets the current camera vertical field of view.
     * @returns { number } - the field of view in degrees.
     */
    Viewer3D.prototype.getFOV = function()
    {
        return this.navigation.getVerticalFov();
    };

    /**
     * Sets the current cameras vertical field of view.
     * @param { number } degrees - Field of view in degrees.
     */
    Viewer3D.prototype.setFOV = function(degrees)
    {
        this.navigation.setVerticalFov(degrees, true);
    };

    /**
     * Gets the current camera focal length.
     * @returns { number } - the focal length in millimetres.
     */
    Viewer3D.prototype.getFocalLength = function()
    {
        return this.navigation.getFocalLength();
    };

    /**
     * Sets the current cameras focal length.
     * @param { number } mm - Focal length in millimetres
     */
    Viewer3D.prototype.setFocalLength = function(mm)
    {
        this.navigation.setFocalLength(mm, true);
    };

    /**
     * Hides all lines in the scene.
     * @param {boolean} hide
     */
    Viewer3D.prototype.hideLines = function(hide){
        this.prefs.set('lineRendering', !hide);
        var that = this;

        function onGeometryLoaded(e) {
            //Only hide lines on model load if hide is false -- the default
            //visibility for all objects should be true, so we don't need
            //to call in such case.
            if (hide)
                e.model.hideLines(hide);

            that.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }

        if (!this.impl.hideLines(hide)) {
            this.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }
    };

    /**
     * Hides all points in the scene.
     * @param {boolean} hide
     */
    Viewer3D.prototype.hidePoints = function(hide){
        this.prefs.set('pointRendering', !hide);
        var that = this;

        function onGeometryLoaded(e) {
            //Only hide lines on model load if hide is false -- the default
            //visibility for all objects should be true, so we don't need
            //to call in such case.
            if (hide)
                e.model.hidePoints(hide);

            that.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }

        if (!this.impl.hidePoints(hide)) {
            this.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }
    };


    /**
     * Turns on/off display of edge topology (where available)
     * @param {boolean} show
     */
    Viewer3D.prototype.setDisplayEdges = function(show) {
        this.prefs.set('edgeRendering', show);
        this.impl.setDisplayEdges(show);
    };

    /**
     * @deprecated
     * Applies the camera to the current viewer's camera.
     * @param {THREE.Camera} camera - the camera to apply.
     * @param {boolean} [fit=false] - Do a fit to view after transition.
     */
    Viewer3D.prototype.applyCamera = function(camera, fit) {
        this.impl.setViewFromCamera(camera, true);
        if (fit)
            this.fitToView();
    };

    /**
     * Fits camera to objects by ID. It fits the entire model if no ID is provided.
     * Operation will fit to the model's bounding box when its object tree is not available.
     * To enqueue a fitToView() operation, use viewer.getObjectTree()'s callback(s).
     * 
     * @param {array| int} [objectIds] array of Ids, or null.
     * @param {model} [model] - The model containing the ``objectIds``.
     */
    Viewer3D.prototype.fitToView = function(objectIds, model){

        model = model || this.model;

        if (!model)
            return;

        if (model.isObjectTreeLoaded() || model.is2d()){
            this.impl.fitToView(objectIds, model);
        } else {
            this.impl.fitToView(null, model);
        }
        
        // Event gets fired from `impl`        
    };

    /**
     * Modifies a click action configuration entry.
     * @param {string} what - which click config to modify (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
     * @param {string} where - hit location selector (one of "onObject", "offObject").
     * @param {array|string} newAction - action list (containing any of "setCOI", "selectOnly", "selectToggle", "deselectAll", "deselectAll", "isolate", "showAll", "hide", "focus").
     * @returns {boolean} False if specified entry is not found, otherwise true.
     */
    Viewer3D.prototype.setClickConfig = function(what, where, newAction)
    {
        var config = this.clickHandler ? this.clickHandler.getClickBehavior()
            : this.impl.controls.getClickBehavior();

        if( what in config )
        {
            var actions = config[what];
            if( where in actions )
            {
                actions[where] = newAction;
                return true;
            }
        }
        return false;
    };

    /**
     * Fetch a click action configuration entry.
     * @param {string} what - which click config to fetch (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
     * @param {string} where - hit location selector (one of "onObject", "offObject").
     * @returns {array} action list for the given entry or null if not found.
     */
    Viewer3D.prototype.getClickConfig = function(what, where)
    {
        var config = this.clickHandler ? this.clickHandler.getClickBehavior()
            : this.impl.controls.getClickBehavior();

        if( what in config )
        {
            var actions = config[what];
            if( where in actions )
                return actions[where];
        }
        return null;
    };

    /**
     * Modify the default click behaviour for the viewer.
     * @param {boolean} state - If true the default is to set the center of interest. If false the default is single select.
     * @param {boolean} [updatePrefs=true] - If true, the user preferences will be updated.
     */
    Viewer3D.prototype.setClickToSetCOI = function(state, updatePrefs)
    {
        if (updatePrefs !== false)
            this.prefs.set('clickToSetCOI', state);

        var currentOn = this.getClickConfig("click", "onObject");
        if( state )
        {
            if( currentOn.indexOf("setCOI") === -1 ) // Not already set?
            {
                this.setClickConfig("click", "onObject",  [ "setCOI" ]);
            }
        }
        else if( currentOn.indexOf("setCOI") >= 0 ) // Is currently set?
        {
            this.setClickConfig("click", "onObject",  [ "selectOnly" ]);
        }
    };


    /**
     * Initializes all gui settings to their defaults or to the session stored setting
     * This gives session stored settings priority
     */
    Viewer3D.prototype.initSettings = function() {

        this.prefs.load(av.DefaultSettings);

        this.prefs.tag('3d');
        this.prefs.tag('2d');
        this.prefs.untag('2d', [ // 3d only
            'viewCube',
            'alwaysUsePivot',
            'zoomTowardsPivot',
            'reverseHorizontalLookDirection',
            'reverseVerticalLookDirection',
            'orbitPastWorldPoles',
            'clickToSetCOI',
            'ghosting',
            'optimizeNavigation',
            'renderCache',
            'ambientShadows',
            'antialiasing',
            'groundShadow',
            'groundReflection',
            'lineRendering',
            'edgeRendering',
            'lightPreset',
            'envMapBackground',
            'firstPersonToolPopup',
            'bimWalkToolPopup'
        ]);
        this.prefs.untag('3d', [ // 2d only
            'swapBlackAndWhite'
        ]);

        // Apply settings
        this.setQualityLevel(this.prefs.ambientShadows, this.prefs.antialiasing);
        this.setGroundShadow(this.prefs.groundShadow);
        this.setGroundReflection(this.prefs.groundReflection);
        this.setGhosting(this.prefs.ghosting);
        this.setProgressiveRendering(this.prefs.progressiveRendering);
        this.setSwapBlackAndWhite(this.prefs.swapBlackAndWhite);
        this.setClickToSetCOI(this.prefs.clickToSetCOI);
        this.setOptimizeNavigation(this.prefs.optimizeNavigation);
        this.hideLines(!this.prefs.lineRendering);
        this.hidePoints(!this.prefs.pointRendering);
        this.setDisplayEdges(this.prefs.edgeRendering);
        this.setEnvMapBackground(this.prefs.envMapBackground);
        this.setFirstPersonToolPopup(this.prefs.firstPersonToolPopup);
        this.setBimWalkToolPopup(this.prefs.bimWalkToolPopup);
        this.setRenderCache(this.prefs.renderCache);

        this.navigation.setUsePivotAlways(this.prefs.alwaysUsePivot);
        this.navigation.setReverseZoomDirection(this.prefs.reverseMouseZoomDir);
        this.navigation.setReverseHorizontalLookDirection(this.prefs.reverseHorizontalLookDirection);
        this.navigation.setReverseVerticalLookDirection(this.prefs.reverseVerticalLookDirection);
        this.navigation.setZoomTowardsPivot(this.prefs.zoomTowardsPivot);
        this.navigation.setOrbitPastWorldPoles(this.prefs.orbitPastWorldPoles);
        this.navigation.setUseLeftHandedInput(this.prefs.leftHandedMouseSetup);

        var bacStr = this.prefs.backgroundColorPreset;
        if (bacStr) {
            try {
                var bac = JSON.parse(bacStr);
                this.impl.setClearColors(bac[0],bac[1],bac[2],bac[3],bac[4],bac[5]);
            } catch(e) {
                this.prefs.set("backgroundColorPreset", null);
            }
        }

        // done last, so that if the environment has a background color, it
        // overrides any previous background color preference.
        var lightPreset = /*viewer.model.is2d() ? avp.DefaultLightPreset2d :*/ this.prefs.lightPreset;
        this.impl.setLightPreset(lightPreset);
    };

    /**
     * Sets the Light Presets (Environments) for the Viewer.
     *
     * Not applicable to 2D.
     *
     * Sets the preference in the UI
     * @param {Number} index - where
     * - 0 Simple Grey
     * - 1 Sharp Highlights
     * - 2 Dark Sky
     * - 3 Grey Room
     * - 4 Photo Booth
     * - 5 Tranquility
     * - 6 Infinity Pool
     * - 7 Simple White
     * - 8 Riverbank
     * - 9 Contrast
     * - 10 Rim Highlights
     * - 11 Cool Light
     * - 12 Warm Light
     * - 13 Soft Light
     * - 14 Grid Light
     * - 15 Plaza
     * - 16 Snow Field
     * @note this list is copied from the ones in Environments.js
     */

    Viewer3D.prototype.setLightPreset = function (index) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setLightPreset is not applicable to 2D");
            return;
        }

        this.prefs.set('lightPreset', index);

        this.impl.setLightPreset(index);
    };

    /**
     *  Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
     */
    Viewer3D.prototype.setUsePivotAlways = function (value) {
        this.prefs.set('alwaysUsePivot', value);
        this.navigation.setUsePivotAlways(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseZoomDirection = function (value) {
        this.prefs.set('reverseMouseZoomDir', value);
        this.navigation.setReverseZoomDirection(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseHorizontalLookDirection = function (value) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setReverseHorizontalLookDirection is not applicable to 2D");
            return;
        }

        this.prefs.set('reverseHorizontalLookDirection', value);
        this.navigation.setReverseHorizontalLookDirection(value);
    };

    /**
     * Set or unset a view navigation option to reverse the default direction for vertical look operations.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for reverse, false for default
     */
    Viewer3D.prototype.setReverseVerticalLookDirection = function (value) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setReverseVerticalLookDirection is not applicable to 2D");
            return;
        }

        this.prefs.set('reverseVerticalLookDirection', value);
        this.navigation.setReverseVerticalLookDirection(value);
    };

    /**
     * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true for towards the pivot, false for default
     */
    Viewer3D.prototype.setZoomTowardsPivot = function (value) {
        this.prefs.set('zoomTowardsPivot', value);
        this.navigation.setZoomTowardsPivot(value);
    };

    /**
     * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
     *
     * Not applicable to 2D.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to allow orbiting past the poles.
     */
    Viewer3D.prototype.setOrbitPastWorldPoles = function (value) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setOrbitPastWorldPoles is not applicable to 2D");
            return;
        }

        this.prefs.set('orbitPastWorldPoles', value);
        this.navigation.setOrbitPastWorldPoles(value);
    };

    /**
     * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
     *
     *  Sets the preference in the UI
     *  @param {boolean} value - value of the option, true to request reversal of mouse button assignments.
     */
    Viewer3D.prototype.setUseLeftHandedInput = function (value) {
        this.prefs.set('leftHandedMouseSetup', value);
        this.navigation.setUseLeftHandedInput(value);
    };

    /**
     * Set visibility for a single layer, or for all layers.
     *
     * Not yet implemented for 3D.
     *
     * @param {?Array} nodes - An array of layer nodes, or a single layer node, or null for all layers
     * @param {boolean} visible - true to show the layer, false to hide it
     * @param {boolean=} [isolate] - true to isolate the layer
     */
    Viewer3D.prototype.setLayerVisible = function (nodes, visible, isolate) {
        if( this.model && !this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setLayerVisible is not yet implemented for 3D");
            return;
        }

        function getLayerIndexes(node) {

            if (node.isLayer) {
                return [node.index];
            }

            if (node.children) {
                var layerIndexes = [];
                var children = node.children;
                for (var i = 0; i < children.length; ++i) {
                    layerIndexes = layerIndexes.concat( getLayerIndexes(children[i]) );
                }
                return layerIndexes;            
            }

            return [];
        }

        var layersRoot = this.model.getLayersRoot();
        if (!layersRoot || 0 === layersRoot.childCount) {
            return;
        }

        if (nodes === null) {
            nodes = [layersRoot];
        }
        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        if (isolate) {
            // if we isolate, that means turn off everything to start.
            var allLayerIndices = getLayerIndexes(layersRoot);
            this.impl.setLayerVisible(allLayerIndices, false);
            this.impl.visibilityManager.isolate();  // Turn off isolation
            visible = true; // force this because isolate + not visible doesn't make sense
        }

        // now set the visibility of the selected set
        var layerIndexes = [];
        for (var i = 0; i < nodes.length; ++i) {
            var nodeLayerIndices = getLayerIndexes(nodes[i]);
            layerIndexes = layerIndexes.concat( nodeLayerIndices );
        }
        this.impl.setLayerVisible(layerIndexes, visible);
        this.dispatchEvent({type: av.LAYER_VISIBILITY_CHANGED_EVENT});
    };

    /**
     * Returns true if the layer is visible.
     *
     * Not yet implemented for 3D.
     *
     * @param {Object} node - Layer node
     * @returns {boolean} true if the layer is visible
     */
    Viewer3D.prototype.isLayerVisible = function (node) {
        if( this.model && !this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.isLayerVisible is not yet implemented for 3D");
            return false;
        }

        return !!(node && node.isLayer && this.impl.isLayerVisible(node.index));
    };

    /**
     * Returns true if any layer is hidden.
     *
     * Not yet implemented for 3D.
     *
     * @returns {boolean} true if any layer is hidden
     */
    Viewer3D.prototype.anyLayerHidden = function () {
        if( this.model && !this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.anyLayerHidden is not yet implemented for 3D");
            return false;
        }

        var that = this;

        function anyLayerHidden(node) {
            if (node.isLayer) {
                return !that.impl.isLayerVisible(node.index);
            } else {
                var children = node.children;
                for (var i = 0; i < children.length; ++i) {
                    if (anyLayerHidden(children[i])) {
                        return true;
                    }
                }
            }
            return false;
        }

        var layersRoot = that.model.getLayersRoot();
        return !!(layersRoot && anyLayerHidden(layersRoot));
    };

    /**
     * If enabled, set ground shadow color
     *
     * Not applicable to 2D
     *
     * @param {THREE.Color} color
     */
    Viewer3D.prototype.setGroundShadowColor = function(color) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundShadowColor is not applicable to 2D");
            return;
        }

        this.impl.setGroundShadowColor(color);
    };

    /**
     * If enabled, set ground shadow alpha
     *
     * Not applicable to 2D
     *
     * @param {float} alpha
     */
    Viewer3D.prototype.setGroundShadowAlpha = function(alpha) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundShadowAlpha is not applicable to 2D");
            return;
        }

        this.impl.setGroundShadowAlpha(alpha);
    };

    /**
     * If enabled, set ground reflection color. This is reset to default when reflections toggled off.
     *
     * Not applicable to 2D
     *
     * @param {THREE.Color} color
     */
    Viewer3D.prototype.setGroundReflectionColor = function(color) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundReflectionColor is not applicable to 2D");
            return;
        }

        this.impl.setGroundReflectionColor(color);
    };

    /**
     * If enabled, set ground reflection alpha. This is reset to default when reflections toggled off.
     *
     * Not applicable to 2D
     *
     * @param {float} alpha
     */
    Viewer3D.prototype.setGroundReflectionAlpha = function(alpha) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.setGroundReflectionAlpha is not applicable to 2D");
            return;
        }

        this.impl.setGroundReflectionAlpha(alpha);
    };

    /**
     * Returns a list of active cut planes
     *
     * Not applicable to 2D
     *
     * @return {THREE.Vector4[]} List of Vector4 plane representation {x:a, y:b, z:c, w:d}
     */
    Viewer3D.prototype.getCutPlanes = function() {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getCutPlanes is not applicable to 2D");
            return [];
        }

        return this.impl.getCutPlanes();
    };

    /**
     * Apply a list of cut planes
     *
     * Not applicable to 2D
     *
     * @param {THREE.Vector4[]} planes - List of Vector4 plane representation: {x:a, y:b, z:c, w:d}
     * Plane general equation: ax + by + cz + d = 0 where a, b, and c are not all zero
     * Passing an empty list or null is equivalent to setting zero cut planes
     */
    Viewer3D.prototype.setCutPlanes = function(planes) {
        if( this.model && this.model.is2d() )
        {
            avp.logger.warn("Viewer3D.getCutPlanes is not applicable to 2D");
            return;
        }

        this.impl.setCutPlanes(planes);
    };

    /**
     * Captures the current screen image as Blob URL
     * Blob URL can be used like a regular image url (e.g., window.open, img.src, etc)
     * If width and height are 0, returns asynchronously and calls the callback with an image as Blob URL with dimensions equal to current canvas dimensions
     * If width and height are given, returns asynchronously and calls the callback with the resized image as Blob URL
     * If no callback is given, displays the image in a new window.<br>
     * See also [getScreenShotBuffer()]{@link Autodesk.Viewing.Viewer3D#getScreenShotBuffer}.
     * @param  {int}      [w]  width of the requested image
     * @param  {int}      [h]  height of the requested image
     * @param  {Function} [cb] callback
     * @return {DOMString}     screenshot image Blob URL, if no parameters are given
     */
    Viewer3D.prototype.getScreenShot = function(w, h, cb) {
        return this.impl.getScreenShot(w, h, cb);
    };

    /**
     * Alternative call to [getScreenShot()]{@link Autodesk.Viewing.Viewer3D#getScreenShot}
     * which internally uses additional steps (more processing) to generate the screenshot.
     * @param  {int}      [w]  width of the requested image
     * @param  {int}      [h]  height of the requested image
     * @param  {Function} [cb] callback
     */
    Viewer3D.prototype.getScreenShotBuffer = function (w, h, cb) {
        return this.impl.getScreenShotBuffer(w, h, cb);
    };

    /**
     * Sets the object context menu.
     * @param {?ObjectContextMenu=} [contextMenu]
     */
    Viewer3D.prototype.setContextMenu = function (contextMenu) {

        if (this.contextMenu) {

            // Hide the current context menu, just in case it's open right now.
            // This does nothing if the context menu is not open.
            //
            this.contextMenu.hide();
        }

        this.contextMenu = contextMenu || null; // to avoid undefined
    };

    /**
     * Activates the default context menu.<br>
     * Contains options Isolate, Hide selected, Show all objects, Focus and Clear selection.
     *
     * @returns {boolean} Whether the default context menu was successfully set (true) or not (false)
     */
    Viewer3D.prototype.setDefaultContextMenu = function() {

        var ave = Autodesk.Viewing.Extensions;
        if (ave && ave.ViewerObjectContextMenu) {
            this.setContextMenu(new ave.ViewerObjectContextMenu(this));
            return true;
        }
        return false;
    };

    Viewer3D.prototype.triggerContextMenu = function (event) {
        if (this.config && this.config.onTriggerContextMenuCallback) {
            this.config.onTriggerContextMenuCallback(event);
        }

        if (this.contextMenu) {
            this.contextMenu.show(event);
            return true;
        }
        return false;
    };

    Viewer3D.prototype.triggerSelectionChanged = function (dbId) {
        if (this.config && this.config.onTriggerSelectionChangedCallback) {
            this.config.onTriggerSelectionChangedCallback(dbId);
        }
    };

    Viewer3D.prototype.triggerDoubleTapCallback = function (event) {
        if (this.config && this.config.onTriggerDoubleTapCallback) {
            this.config.onTriggerDoubleTapCallback(event);
        }
    };

    Viewer3D.prototype.triggerSingleTapCallback = function (event) {
        if (this.config && this.config.onTriggerSingleTapCallback) {
            this.config.onTriggerSingleTapCallback(event);
        }
    };

    Viewer3D.prototype.initContextMenu = function() {

        // Disable the browser's default context menu by default, or if explicitly specified.
        //
        var disableBrowserContextMenu = !this.config || (this.config.hasOwnProperty("disableBrowserContextMenu") ? this.config.disableBrowserContextMenu : true);
        if (disableBrowserContextMenu) {
            this.onDefaultContextMenu = function (e) {
                e.preventDefault();
            };
            this.container.addEventListener('contextmenu', this.onDefaultContextMenu, false);
        }

        var self = this;

        function isRightClick(event) {
            var button = event.button;

            // Check for Firefox spoof: Control+LMB converted to RMB.
            // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
            if( "buttons" in event ) {
                // For button down the 1 bit will be on indicating LMB.
                // For button up it's off so check the flag to see if we
                // switched the down event.
                if( self.__firefoxLMBfix && !(event.buttons & 1) ) { // Button up?
                    self.__firefoxLMBfix = false;
                    button = 0;
                    // avp.logger.log("FIREFOX UP!!!");
                }
                else if( (button === 2) && (event.buttons & 1) ) {
                    button = 0;    // Convert back to reality.
                    self.__firefoxLMBfix = true;
                    // avp.logger.log("FIREFOX SUX!!!");
                }
            }

            var useLeftHandedInput = self.navigation ? self.navigation.getUseLeftHandedInput() : false;
            var rightButton = useLeftHandedInput ? 0 : 2;

            if( button === rightButton )
                return true;

            /* See SPK-930 and SPK-928
             var isMac = (navigator.userAgent.search("Mac OS") !== -1);
             var leftButton = (rightButton === 2) ? 0 : 2;
             return isMac && event.ctrlKey && (event.button === leftButton);
             */
            return false;
        }

        var canvas = this.canvas || this.container;

        canvas.addEventListener( 'mousedown',
            function(event) {
                if (isRightClick(event)) {
                    self.startX = event.clientX;
                    self.startY = event.clientY;
                }
            } );

        canvas.addEventListener( 'mouseup',
            function ( event ) {
                if (isRightClick(event) && event.clientX === self.startX && event.clientY === self.startY) {
                    self.triggerContextMenu(event);
                }
                return true;
            }, false );
    };


    /**
     * Registers a new callback that modifies the context menu.
     * This allows extensions and others to add, remove, or change items in the context menu.
     * Extensions that call registerContextMenuCallback() should call unregisterContextMenuCallback() in their unload().
     * @param {string} id - Unique id to identify this callback. Used by unregisterContextMenuCallback().
     * @param {function(Array, Object)} callback - Will be called before the context menu is displayed.
     * @see Viewer.unregisterContextMenuCallback
     * @see ObjectContextMenu.buildMenu
     *
     * @example
     * // Here's an example that appends a new context menu item:
     *
     * viewer.registerContextMenuCallback('MyExtensionName', function (menu, status) {
 *     if (status.hasSelected) {
 *         menu.push({
 *             title: 'My new context menu item with selected objects',
 *             target: function () {
 *                 alert('Do something with selected objects');
 *         });
 *     } else {
 *         menu.push({
 *             title: 'My new context menu item, no selected objects',
 *             target: function () {
 *                 alert('Do something else');
 *         });
 *     }
 * });
 */
    Viewer3D.prototype.registerContextMenuCallback = function (id, callback) {
        this.contextMenuCallbacks[id] = callback;
    };

    /**
     * Unregisters an existing callback that modifies the context menu.
     * Extensions that call registerContextMenuCallback() should call unregisterContextMenuCallback() in their unload().
     * @param {string} id - Unique id to identify this callback.
     * @returns {boolean} true if the callback was unregistered successfully.
     * @see Viewer.registerContextMenuCallback
     */
    Viewer3D.prototype.unregisterContextMenuCallback = function (id) {
        if (id in this.contextMenuCallbacks) {
            delete this.contextMenuCallbacks[id];
            return true;
        }
        return false;
    };

    /**
     * Runs all registered context menu callbacks.
     * @param {array} menu - Context menu items.
     * @param {Object} status - Information about nodes.
     * @see ObjectContextMenu.buildMenu
     * @private
     */
    Viewer3D.prototype.runContextMenuCallbacks = function (menu, status) {
        for (var id in this.contextMenuCallbacks) {
            if (this.contextMenuCallbacks.hasOwnProperty(id)) {
                this.contextMenuCallbacks[id](menu, status);
            }
        }
    };

    /**
     * Play animation if animation data is available as part of model data.
     * If the model data does not contain any animation, this function call is a no op.
     * @param  {Function} [callback] Callback function that would be invoked at each frame of the animation.
     * The callback function takes a single input value, with value range between 0 and 100, inclusive, with value
     * 100 indicates the animation has finished playing.
     * @example
     * Here is an example of callback function.
     * function(value) {
     *     if (value < 100)
     *         console.log("Animation progress: " + value + "%.");
     *     else
     *         console.log("Animation finished.");
     * }
     */
    Viewer3D.prototype.playAnimation = function (callback) {
        var animator = this.impl.keyFrameAnimator;
        if (animator) {
            animator.play(0, callback);
        }
    };

    /**
     * Join a live review session.
     *
     * @param {string} [sessionId] - The live review session id to join.
     */
    Viewer3D.prototype.joinLiveReview = function (sessionId) {
        if (!this.liveReviewClient) {
            this.liveReviewClient = new avp.LiveReviewClient(this);
        }

        var liveReviewClient = this.liveReviewClient;
        avp.loadDependency("lmv_io", "socket.io-1.3.5.js", function(){
            liveReviewClient.joinLiveReviewSession(sessionId);
        });
    };

    /**
     * Leave a live review session.
     */
    Viewer3D.prototype.leaveLiveReview = function () {
        if (this.liveReviewClient) {
            this.liveReviewClient.leaveLiveReviewSession();
        }
    };

    /**
     * Set model units
     * @param Model units
     */
    Viewer3D.prototype.setModelUnits = function(modelUnits) {
        if (this.model) {
            this.model.getData().overriddenUnits = modelUnits;
        }
    };

    /**
     * Calculates the pixel position in client space coordinates of a point in world space.<br>
     * See also
     * [clientToWorld()]{@link Autodesk.Viewing.Viewer3D#clientToWorld}.
     * @param {THREE.Vector3} point Point in world space coordinates.
     * @returns {THREE.Vector3} Point transformed and projected into client space coordinates. Z value is 0.
     */
    Viewer3D.prototype.worldToClient = function(point) {
        return this.impl.worldToClient(point);
    };

    /**
     * Given coordinates in pixel screen space it returns information of the underlying geometry node.
     * Hidden nodes will not be taken into account. Returns null if there is no geometry in the specified location.
     * For 2d models, it will return null outside the paper.<br>
     * See also
     * [worldToClient()]{@link Autodesk.Viewing.Viewer3D#worldToClient}.
     *
     * @param {Number} clientX - X coordinate where 0 is left
     * @param {Number} clientY - Y coordinate where 0 is top
     * @param {Boolean} [ignoreTransparent] - Ignores transparent materials
     * @returns {Object|null} contains point attribute. 3d models have additional attributes.
     */
    Viewer3D.prototype.clientToWorld = function(clientX, clientY, ignoreTransparent) {

        return this.impl.clientToWorld(clientX, clientY, ignoreTransparent);
    };

    /**
     * Expose if the model has topology information downloaded.
     * Only applicable to 3D models.
     * @returns {boolean} value - Indicates whether the model has topology information.
     */
    Viewer3D.prototype.modelHasTopology = function() {

        if (this.model && this.model.hasTopology()) {
            return true;
        }

        return false;
    };

    /**
     * Changes color of the selection for a particular selection type.
     * - Autodesk.Viewing.SelectionMode.MIXED
     *   - Sets the same color for REGULAR and OVERLAYED selection.
     * - Autodesk.Viewing.SelectionMode.REGULAR
     *   - Sets the color of regular selection.
     * - Autodesk.Viewing.SelectionMode.OVERLAYED
     *   - Sets the color of overlayed selection.
     * 
     * @example
     *  viewer.setSelectionColor(new THREE.Color(0xFF0000), Autodesk.Viewing.SelectionMode.MIXED); // red color
     * @param {THREE.Color} color
     * @param {number} selectionType a member of Autodesk.Viewing.SelectionMode.
     */
    Viewer3D.prototype.setSelectionColor = function(color, selectionType) {
        this.impl.setSelectionColor(color, selectionType);
    };

    /**
     * Create ViewCube.
     */
    Viewer3D.prototype.createViewCube = function() {

        if (!this.viewCubeUi) {
            this.viewCubeUi = new avp.ViewCubeUi(this);
            this.viewCubeUi.create();
        }
    };

    /**
     * Display ViewCube.
     * @param {boolean} display - Display or hide the ViewCube.
     */
    Viewer3D.prototype.displayViewCube = function(display) {

        if (this.viewCubeUi) {
            this.viewCubeUi.displayViewCube(display, false);
        }
    };

    /**
     * Display ViewCube.
     * @param {boolean} display - Display or hide the ViewCube with home and info buttons.
     */
    Viewer3D.prototype.displayViewCubeUI = function(display) {

        if (this.viewCubeUi) {
            this.viewCubeUi.setVisible(display);
        }
    };

    /**
     * Set the face of ViewCube and apply camera transformation according to it.
     * @param {string} face - The face name of ViewCube. The name can contain multiple face names,
     * the format should be `"[front/back], [top/bottom], [left/right]"`.
     */
    Viewer3D.prototype.setViewCube = function(face) {

        if (this.viewCubeUi && this.viewCubeUi.cube) {
            this.viewCubeUi.cube.cubeRotateTo(face);
        }
    };

    /**
     * Highlight an object with a theming color that is blended with the original object's material.
     * @param {number} dbId
     * @param {THREE.Vector4} color - (r, g, b, intensity), all in [0,1].
     * @param {Autodesk.Viewing.RenderModel} [model] - For multi-model support.
     */
    Viewer3D.prototype.setThemingColor = function(dbId, color, model) {
        // use default RenderModel by default
        model = model || this.model;

        model.setThemingColor(dbId, color);

        // we changed the scene to apply theming => trigger re-render
        this.impl.invalidate(true);
    };

    /**
     * Restore original colors for all themed shapes.
     * @param {Autodesk.Viewing.RenderModel} [model] - For multi-model support.
     */
    Viewer3D.prototype.clearThemingColors = function(model) {
        // use default RenderModel by default
        model = model || this.model;

        model.clearThemingColors();

        // we changed the scene to apply theming => trigger re-render
        this.impl.invalidate(true);
    };

    /**
     * Transfer model from this viewer to another one - including state of selection, ghosting, and theming.
     */
    Viewer3D.prototype.transferModel = function(modelId, viewer) {

        var model = this.impl.findModel(modelId);
        if (!model) {
            // unknown modeId
            return;
        }

        // collect all selected db ids for this model
        var selectedIds = [];
        this.getAggregateSelection(function(model, dbId) {
            if (model.id==modelId) {
                selectedIds.push(dbId);
            }
        });

        // collect isolated/hidden nodes
        var isolatedIds = this.impl.visibilityManager.getIsolatedNodes(model);
        var hiddenIds   = this.impl.visibilityManager.getHiddenNodes(model);

        // export all materials and textures to MaterialManager of the other viewer
        // Note: Getting the materials from MaterialManager directly is the safest way for consistent state between both viewers.
        // E.g., enumerating the materials of the RenderModel instead would not work for 2 reasons:
        //  a) If the model is still loading, some materials would get lost: SvfLoader adds all materials in onModelRootLoadDone() already.
        //     But, RenderModel only knows materials for meshes that have been already loaded.
        //  b) The material hashes are only known to MaterialManager
        var modelMaterials = this.impl.matman().exportModelMaterials(model);

        // remove model from this viewer
        this.impl.removeModel(model);

        // pass model to other viewer
        viewer.model = model;
        viewer.impl.addModel(model);

        // import materials to new viewer
        // Note that it is essential to do export/import of materials in separate steps:
        //  - Exporting materials must be done before removing the model. After removeModel(),
        //    MaterialManager would not contain the material of this model anymore.
        //  - Importing materials must be done after adding the model to make sure that everything is properly initialized.
        //    E.g., the layerTexture would not be initialized otherwise.
        viewer.impl.matman().importModelMaterials(modelMaterials);

        // if the other viewer had no model before, make sure that the loadSpinner disappears.
        if (viewer.loadSpinner) {
            viewer.loadSpinner.style.display = "None";
        }

        // link running loader to new viewer
        if (model.loader && model.loader.viewer3DImpl===this.impl) {
            model.loader.viewer3DImpl = viewer.impl;
        }

        // if model is still loading, the worker will call onLoadComplete later. If the model is still loaded,
        // we do it immediately.
        if (model.getData().loadDone) {
            viewer.impl.onLoadComplete(model);
        }

        // recover selection
        viewer.impl.selector.setSelection(selectedIds, model);

        // recover isolated/hidden nodes (Note that hiddenIds are only used if no node is isolated)
        if (isolatedIds.length!=0)      viewer.impl.visibilityManager.isolate(isolatedIds, model);
        else if (hiddenIds.length!=0)   viewer.impl.visibilityManager.hide(hiddenIds, model);
    };

	/**
     * Temporarily remove a model from the Viewer, but keep loaders, materials, and geometry alive.
     *
     * @param modelId
     * @returns {boolean} true indicates success, i.e., modelId referred to a visible model that is now hidden
     */
    Viewer3D.prototype.hideModel = function(modelId) {

        var scene = this.impl.modelQueue();
        var success = scene.hideModel(modelId);
        var model = this.impl.model;

        // If this.model was hidden, update it to another one
        if (success && model && model.id === modelId) {
            this.impl.model = null;
            if (!scene.isEmpty()) {
                // choose new main model
                this.impl.model = scene.getModels()[0];
            }
            // Keep this.model in-sync.
            this.model = this.impl.model;
        }

        this.impl.invalidate(true, true, true);
        return success;
    };

	/**
     * Make a previously hidden model visible again.
     *
     * @param modelId
     * @returns {boolean} true indicates success, i.e., ``modelId`` referred to a hidden model that is now visible
     */
    Viewer3D.prototype.showModel = function(modelId) {

        var scene = this.impl.modelQueue();
        var success = scene.showModel(modelId);

        // If this.model was null, set it to the new model
        if (success && !this.model) {
            // choose new main model
            this.impl.model = scene.getModels()[0];

            // Keep this.model in-sync. We should eliminate this.model to avoid that.
            this.model = this.impl.model;
        }

        this.impl.invalidate(true, true, true);
        return success;
    };

	/**
     * @returns {RenderModel[]}
     */
    Viewer3D.prototype.getHiddenModels = function() {
        var scene = this.impl.modelQueue();
        return scene.getHiddenModels();
    };

    /**
     * Get the memory stats when using on demand loading.
     * @returns {object|null} Object containing the total limit and total loaded memory usage for all models.
     *                        Return null if no model is being loaded on demand.
     */
    Viewer3D.prototype.getMemoryInfo = function() {
        var q = this.impl.modelQueue();
        return q ? q.getMemoryInfo() : null;
    };

    /**
     * @private
     */
    Viewer3D.prototype.onResetEvent = function() {
        var model = this.model;
        this.impl.setupLighting(model);
        if (model.isAEC() && model.is3d()) {
            this.impl.setLightPresetForAec();
        }
    };

    Autodesk.Viewing.Viewer3D = Viewer3D;

})();


(function() {

"use strict";

var avp = Autodesk.Viewing.Private;

var INTERPOLATION_TYPE = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2
};

var AnimationHandler = function() {
    this.animations = [];
};

AnimationHandler.prototype.init = function(data) {
    // return same data if initialized
    if (data.initialized === true) return data;

    // loop through all keys
    for (var h = 0; h < data.hierarchy.length; h++) {
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            // remove minus times
            if (data.hierarchy[h].keys[k].time < 0 ) {
                 data.hierarchy[h].keys[k].time = 0;
            }

            // create quaternions
            if (data.hierarchy[h].keys[k].rot !== undefined &&
              ! (data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
                var quat = data.hierarchy[h].keys[k].rot;
                if (!Array.isArray(quat)) {
                    quat = [quat._x, quat._y, quat._z, quat._w];
                }
                data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
            }
        }

        // remove all keys with same time
        for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
                data.hierarchy[h].keys.splice(k, 1);
                k--;
            }
        }

        // set index
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            data.hierarchy[h].keys[k].index = k;
        }
    }
    data.initialized = true;
    return data;
};

AnimationHandler.prototype.parse = function(root) {
    function parseRecurseHierarchy(root, hierarchy) {
        hierarchy.push(root);

        // check Object3D.children if not defined
        // do not animate camera's light node
        if (root.children && !(root instanceof THREE.Camera)) {
            for(var c = 0; c < root.children.length; c++)
                parseRecurseHierarchy(root.children[c], hierarchy);
        }
    }
    var hierarchy = [];
    parseRecurseHierarchy(root, hierarchy);
    return hierarchy;
};

AnimationHandler.prototype.play = function(animation) {
    if (this.animations.indexOf(animation) === -1) {
        this.animations.push(animation);
    }
};

AnimationHandler.prototype.stop = function(animation) {
    var index = this.animations.indexOf(animation);
    if (index !== -1) {
        this.animations.splice(index, 1);
    }
};

AnimationHandler.prototype.update = function(deltaTimeMS) {
    for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].update(deltaTimeMS);
    }
};

var Animation = function(root, data, animator) {
    this.root = root;
    this.handler = animator.animationHandler;
    this.data = this.handler.init(data);
    this.hierarchy = this.handler.parse(root);
    this.viewer = animator.viewer;
    this.animator = animator;

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.isPaused = true;
    this.loop = false;
    this.delta = 0.5;

    this.interpolationType = INTERPOLATION_TYPE.LINEAR;

    this.setStartAndEndKeyTime();
};

Animation.prototype.setStartAndEndKeyTime = function() {
    if (this.data.hierarchy.length > 0) {
        // root of hierarchy should have key time covering animation
        var keys = this.data.hierarchy[0].keys;
        this.startKeyTime = keys[0].time;
        this.endKeyTime = keys[keys.length-1].time;
    } else {
        this.startKeyTime = this.endKeyTime = 0;
    }
};

Animation.prototype.keyTypes = [];
Animation.prototype.defaultKey = {};

Animation.prototype.play = function(startTime) {
    this.currentTime = startTime !== undefined ? startTime : 0;
    this.isPlaying = true;
    this.isPaused = false;
    this.reset();
    this.handler.play(this);
};

Animation.prototype.pause = function() {
    if (this.isPaused === true) {
        this.handler.play(this);
    } else {
        this.handler.stop(this);
    }
    this.isPaused = !this.isPaused;
};

Animation.prototype.stop = function() {
    this.isPlaying = false;
    this.isPaused  = false;
    this.handler.stop(this);
};

Animation.prototype.goto = function(time) {
    if (!this.isPlaying) this.play();
    if (!this.isPaused) this.pause();
    var delta = time - this.currentTime;
    this.update(delta);
};

Animation.prototype.reset = function() {
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
        var object = this.hierarchy[h];

        if (object.animationCache === undefined) {
            object.animationCache = {};
        }

        if (object.animationCache[this.data.name] === undefined) {
            object.animationCache[this.data.name] = {
                prevKey: this.defaultKey,
                nextKey: this.defaultKey,
                originalMatrix: object.matrix
            };
        }

        // get keys to match our current time
        var animationCache = object.animationCache[this.data.name];
        for (var t = 0; t < this.keyTypes.length; t++) {
            var type = this.keyTypes[t];
            var prevKey = this.data.hierarchy[h].keys[0];
            var nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                prevKey = nextKey;
                nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
            animationCache.prevKey[type] = prevKey;
            animationCache.nextKey[type] = nextKey;
        }
    }

    this.setStartAndEndKeyTime();
};

Animation.prototype.getNextKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key < keys.length - 1 ? key : keys.length - 1;
    } else {
        key = key % keys.length;
    }

    for (; key < keys.length; key++) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[0];
};

Animation.prototype.getPrevKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key > 0 ? key : 0;
    } else {
        key = key >= 0 ? key : key + keys.length;
    }

    for (; key >= 0; key--) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[keys.length - 1];
};

Animation.prototype.isPlayingOutOfRange = function() {
    return (this.isPaused === false && (this.currentTime < this.startKeyTime - this.delta ||
            this.currentTime > this.endKeyTime + this.delta))
};

Animation.prototype.resetIfLooped = function() {
    if (this.loop === true && this.currentTime > this.endKeyTime) {
        this.currentTime %= this.endKeyTime;
        this.reset();
    }
};

var MeshAnimation = function(root, data, animator) {
    Animation.call(this, root, data, animator);
    //this.originalMatrix = root.matrix.clone();
    this.localMatrix = new THREE.Matrix4();
    
    this.root.getAnimTransform();
    this.relativeTransform = (data.custom && data.custom.transform && data.custom.transform === "abs")? false: true;

    /*
    if (this.relativeTransform) {
        //this.root.updateMatrixWorld();
    } else {
        
    }
    */
};

MeshAnimation.prototype = Object.create(Animation.prototype);
MeshAnimation.prototype.constructor = MeshAnimation;
MeshAnimation.prototype.keyTypes = ["pos", "rot", "scl"];
MeshAnimation.prototype.defaultKey = {pos: 0, rot: 0, scl: 0};

MeshAnimation.prototype.update = (function() {
    var points = [];
    var target;
    var newVector;
    var newQuat;
    var tmpMatrix1;
    var tmpMatrix2;
    
    function init_three() {
        if (target)
            return;
    
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
        newQuat = new THREE.Quaternion();
        tmpMatrix1 = new THREE.Matrix4();
        tmpMatrix2 = new THREE.Matrix4();
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                if (type === "pos") {
                    if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else /*if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD)*/ {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];

                        scale = scale * 0.33 + 0.33;

                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);

                        if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();

                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }
                } else if (type === "rot") {
                    THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                    object.quaternion.copy(newQuat);
                } else if (type === "scl") {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    object.scale.copy(newVector);
                }
            }

            // Note that object is expected to be a FragmentPointer here, not THREE.Object3D.

            if (!this.relativeTransform) {
                // Animation matrices in FragmentList are always applied after the world matrix.
                // If we right-multiply the worldMatrix inverse, we revert the original world matrix.

                // get anim matrix
                var animMatrix = tmpMatrix1.compose(object.position, object.quaternion, object.scale);

                // get inverse of world matrix
                var worldInv   = tmpMatrix2;
                object.getOriginalWorldMatrix(worldInv);
                worldInv.getInverse(worldInv);

                // compute final anim matrix in a way that we first revert the world matrix,
                // then apply the absolute anim matrix
                var finalAnimMatrix = tmpMatrix1.multiplyMatrices(animMatrix, worldInv);

                // write back to the object
                finalAnimMatrix.decompose(object.position, object.quaternion, object.scale);
            }

            // compose local transform and multiply to original transform
            object.updateAnimTransform();

            // update world matrix so scene bounds can be set correctly
            //object.updateMatrixWorld();
        }
    };
})();

var CameraAnimation = function(root, data, animator) {
    Animation.call(this, root, data, animator);
};

CameraAnimation.prototype = Object.create(Animation.prototype);
CameraAnimation.prototype.constructor = CameraAnimation;
CameraAnimation.prototype.keyTypes = ["pos", "up", "target", "fov", "perspective"];
CameraAnimation.prototype.defaultKey = {pos: 0, up: 0, target: 0, fov: 0, perspective:0};

CameraAnimation.prototype.update = (function() {
    var points = [];
    
    var target;
    var newVector;
    function init_three() {
        if (target)
            return;
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;
        
        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime  || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                var vector;
                if (type === "pos") {
                    vector = object.position;
                } else if (type === "up") {
                    vector = object.up;
                } else if (type === "target") {
                    vector = object.target;
                } else if (type === "fov") {
                    object.setFov(prevXYZ + (nextXYZ - prevXYZ) * scale);
                    continue;
                } else if (type === "perspective") {
                    var mode = scale > 0.5 ? nextXYZ : prevXYZ;
                    if (mode)
                        object.toPerspective();
                    else
                        object.toOrthographic();
                    continue;
                }

                if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    vector.copy(newVector);
                } else /*if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                    this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD)*/ {
                    points[0] = this.getPrevKeyWith(type, h, prevKey.index - 1)[type];
                    points[1] = prevXYZ;
                    points[2] = nextXYZ;
                    points[3] = this.getNextKeyWith(type, h, nextKey.index + 1)[type];

                    scale = scale * 0.33 + 0.33;

                    var currentPoint = interpolateCatmullRom(points, scale);
                    newVector.x = currentPoint[0];
                    newVector.y = currentPoint[1];
                    newVector.z = currentPoint[2];
                    vector.copy(newVector);

                    if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                        target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                        target.sub(vector);
                        target.y = 0;
                        target.normalize();

                        var angle = Math.atan2(target.x, target.z);
                        object.rotation.set(0, angle, 0);
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
        object.lookAt(object.target);
        this.animator.updateFlag |= this.animator.UPDATE_CAMERA;
    };
})();

var VisibilityAnimation = function(root, data, nodeId, animator) {
    Animation.call(this, root, data, animator);
    this.nodeId = nodeId;
    this.epsilon = 0.1;

    //Need to clone the material as it can be shared between many objects
    //and we need to modify it for this object specifically
    this.root.setMaterial(this.viewer.matman().cloneMaterial(root.getMaterial()));
};

VisibilityAnimation.prototype = Object.create(Animation.prototype);
VisibilityAnimation.prototype.constructor = VisibilityAnimation;
VisibilityAnimation.prototype.keyTypes = ["vis", "opa"];
VisibilityAnimation.prototype.defaultKey = {viz: 1, opa: 1};

VisibilityAnimation.prototype.update = (function() {
    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevVis = prevKey[type];
                var nextVis = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevVis === undefined || nextVis === undefined) continue;

                var material = object.getMaterial();

                if (type === "vis") {
                    var isNextKey = Math.abs(this.currentTime - nextKey.time) < this.epsilon;
                    var key = isNextKey ? nextKey : prevKey;
                    var vis = isNextKey ? nextVis : prevVis;
                    this.viewer.visibilityManager.setNodeOff(this.nodeId, !vis);
                } else if (type === "opa") {
                    var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                    if (scale < 0) scale = 0;
                    if (scale > 1) scale = 1;
                    var opacity = prevVis + (nextVis - prevVis) * scale;
                    
                    material.transparent = (opacity !== 1);
                    material.opacity = opacity;
                    if (opacity > 0) 
                        this.viewer.visibilityManager.setNodeOff(this.nodeId, false);
                }
            }
        }
    };
})();

var AnnotationAnimation = function(root, data, animator) {
    function createAnnotation(data, viewer, state) {
        var container = that.container = document.createElement('div');
        var name = data.name;
        container.id = name;
        container.style.cursor = "pointer";
        container.style.visibility = state;

        var text = document.createElement('div');
        text.id = name + '-txt';
        text.style.cssText = 'display: none;position: absolute;z-index: 1;';
        container.appendChild(text);

        var icon = document.createElement('img');
        var isAttached = data.custom && data.custom.att && data.custom.att === 1;
        icon.src = isAttached? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABv1BMVEUAAAAAAAAAAAAAAAABAwEAAAAAAAAjSRkAAAAFDASJqnZhg1IqTyAjSRkpTx8hRxggRRcAAAAhRRcKFwgAAACau4R9mnFmiFUhSBgbOhMZNhIAAAAECQMgQxcAAAAAAAAAAAAHDwXB2q2jw4yfvoivyJ6fuI6mv5eSr4KAoWu2trZpiV3Nzc0wVSUhRxhNT01vb28AAAAgRBcAAAAAAAAAAAAhRxgeQBYAAAAAAAAAAAAfQRbP5MC0zqCqyJKpyJJBYje3z6WxyKOFpXF9nmkrTiG+wb5xkGVcf0xYfEg1WSpNTU0hRhgfQhYfQhZVVVVAQEAXMREcOhQcHBwSJw0AAAAAAAAWLxAVLQ8AAAAAAAAfQhYIEgYAAACbvn+DsGCGsmSUunaItGXc6dStypelxY2ZvX2Ntm2JtGnS48fB17G40aWNuWucxH6ny4mUvnPF27aPuHCEsGHV5czI3Lq52KGvzJqz1JmqyJOqzY6ew4OYwHiGs2OEsWHb29vL4LvM5bnD3q2+3KWkyoaLtWuKtmfOzs7IyMi21pyawXqPuG/g4ODX68fI4rTG4LCu0ZKszJKlx4qZwHuBnXR2iXENcZskAAAAXnRSTlMAEAIBCAsF6BUn+vPu7erjsZyBEwP99/TRk3JgRUQ1IxwO/v79/Pv6+fn09PPq08q7sqWDe2xrY01AMBj+/v7+/v37+fn59fXz8u/c1cbFxLWonZiIcm1lYVdSQT8de/EoFwAAAgVJREFUOMutklVz21AQRiNFlswYs+M6DTdN0kCDZWZmuAKDZFtgiO2YYm6TlOEHV53ptGs5j93Xc+a7e3d36P/W9prdZ/PZ17aPxphz3mR0x91G07wTG8TDo5R3HLGH3S6fGPdSo8Na/to6W2HZBEqwPCNULlu1BkFdQSyKx4qxOMoyDDJSRB/HnTcqWbSbTmVS6V3E57hvXicOBZd1gmfj6Z1kPrmTjrMMfRizumDA+k3UTcRSyWg0mkzFEgLNlU3rIIJcns0KqJjJq0I+U0SqUJlZJv8JugU3J/QnHEwu6MCMqPN1pq+H3sFxCgOC7RyT48Ev6qLUL/gmeJrJ/p0DzSnyxTtAGLMbv9dohv8zSbomSqUpOxB0AdNXsUbnGEEQmJzKq3JrLgCaJAzms5LI1enfVefEamc/YzYQYFB6/1xBUsQex3E9UZHkUvO6X48PwQjLTKEjVRVFqUqd8v6naQsMUCNcL8xTrVJZluXyl1K7OW1+7sL71x15cvVH43O7UGi3mmc8lkCE0ByMbvXazwueycbHxiXPrUdv3hLDGiF8au/d4sO7Novtnj9k0BO45uRGTp98f2JlK/RqYzN8TK8bGTjZLTXgfvDp6rMNA0ZADAOWHI6VTYwE4WAZjz/s3V5yvIxADosIPlh0BNXHSdA8LFIfDgE8WDg5hmmx9h/40fgXth2SDk3yjP4AAAAASUVORK5CYII=" :
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABvFBMVEUAAAAAAAADAAAAAAAAAAACAAAAAAAAAAC5PznHVE8BAAAAAADbc27NXVeUDQaZDQaRBwAAAAAAAACHBgDuhoHVa2W9RD2QCAKYCAGPBgB0BQAAAAAAAACMBgAAAAADAAD2jonWb2n2jYjYbWfmeXPNzc3RYFqzODKfFA1RUVGKBgCVBwBvb2+WBwCBBgCFBgCWBwCLBgAAAAAAAACMBgCTBwByBQCTBwBbBACEBgAAAAAAAAAoAgBSBADgeHOoOzXmfnnofnjieHPGvr63t7e0tLTidW/ebmnba2XWZWDAT0qRHBfBSkRNTU2aFxGOBgBYTEsAAACNBgBAQEAAAABbBQAcHBxyBQBKBAAAAABfBAAAAAAAAAAsAgAkAgCJBgDZRT3MOTHQPDTVQjrlUkrjUEjRPjbOOjP/bGTvXFTqV0/fTETNOjL5Zl7eS0PzYFjxXlbiT0fUQTn0e3T7aGDWXFXbSEDTRj/PQTrOPjbb29vgamTxY1zoVE3STETTQjvSPzfOzs7IyMj5g3zzaWLXY13XYVrsXlbbU0zg4OD8lZD4gXq0eHXqd3HscWv2b2jrZmDQZWDdWVLkV1C5y9+5AAAAYHRSTlMAAgUBDggMEeDsIBj+8NHJxpxAEP754tDDtIFsYDkvI/78+/j08/DfycfHxbuvr5mTjYN0bWxkWVZTTDUjEfz8+/n59fT08vHw8PDw5NzV0Mq5uLWrm5iLfX1hV0g/ODZEwKduAAACAklEQVQ4y62SVXPbQBzEa1mWZYaY49ihBhtmKjMzw92JLLBsyxxT2mCZvnCVmU59VpO37Ms97G929nb+p05WXUvTE5GJ6aWuY+yFEdoVdAZd9MjCEYi5J0L3FZutSqVZdIYiPWaj/85j2yszAACGVyq7Lo+RIMZtxRaQOZaTwZZSLbrGLR2+aX54twVykpgVpRzgYbVGz5twYMPTV2ZkKZMupDOSzAiwfNazgQesDO9VASemU6lUWuQAgnyNXsEiiBlbEwE2W9CBQpbVAfRraIZoA5ZosII6EpB6MYrVpLxOQejowKsBL9UGSK+zCnnsF4omB7wkBkQHylDZ+rcDROD3hYcYQE0NHQhQ4f8uCQVG/XF9isJKLtI1TYBQQAgdPlqJzYcWMYBYd58/YJACD6UgpsTVA+51AhvKGgt9zQGN1xN4Dajs/vbtmBXf2mIP3/jGqiW9Q0nlGtn8tXBSnwGPWHYP5PcbLMs2JHFn+6p7WQ/ARTie3/rZm9+pZ+rfP/fawi8dhOFgqLlLX87dHOz/1D9ou/vsrcNiNgBrZzbf338yOXZvbDL2xm4ljCdn6j794cpswr/62p+wWy2m/042oQeMxudedK8mSdzGAy4/9vlm/STRtjGRTz9u3nnge2U3+O2h4o9GfXG7lcLKGWZY8ycduG3sQJCk0Tb+w3S0/Qemc4+eJchuZgAAAABJRU5ErkJggg==";
        icon.id = name + '-img';
        icon.style.cssText = 'display: block;position: absolute;z-index: 1;';
        container.appendChild(icon);

        viewer.api.container.appendChild(container);

        container.addEventListener('click', function () {
            text.style.display = text.style.display === 'none'? 'block' : 'none';
        });

        var color = 0x007F00;
        var opacity = 0.6;
        var geometry = new THREE.SphereGeometry(0.01);
        var material = new THREE.MeshPhongMaterial({color:color, ambient:color, opacity:opacity, transparent:true});
        var mesh = new THREE.Mesh(geometry, material);
        mesh.visible = false;

        if (viewer.overlayScenes["annotation"] === undefined) {
        // add annotation to an overlay scene
            viewer.createOverlayScene("annotation");
        }
        viewer.addOverlay("annotation", mesh);

        return mesh;
    }

    var that = this;
    if (root === null) {
        root = createAnnotation(data, animator.viewer, 'hidden');
    }
    Animation.call(this, root, data, animator);
    this.id = data.name;
    this.text = "";
    this.state = 'hidden';
    this.epsilon = 0.1;

    this.viewer.api.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
        that.updateText(root.position, that.text);
    });
};

AnnotationAnimation.prototype = Object.create(Animation.prototype);
AnnotationAnimation.prototype.constructor = AnnotationAnimation;
AnnotationAnimation.prototype.keyTypes = ["pos", "text", "vis"];
AnnotationAnimation.prototype.defaultKey = {pos: 0, text: "", vis: 1};

AnnotationAnimation.prototype.stop = function() {
    Animation.prototype.stop.call(this);
    this.container.parentNode.removeChild(this.container);
    this.viewer.removeOverlay("annotation", this.root);
    this.root = null;
};

AnnotationAnimation.prototype.updateText = function(position, text) {
    function projectToScreen(position, camera, canvas) {
        var pos = position.clone();
        var projScreenMat = new THREE.Matrix4();
        camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        projScreenMat.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        pos.applyProjection(projScreenMat);

        return {x: (pos.x + 1) * canvas.width / 2 + canvas.offsetLeft,
                y: (-pos.y + 1) * canvas.height / 2 + canvas.offsetTop};
    }
    var coord = projectToScreen(position, this.viewer.camera, this.viewer.canvas);
    var element = document.getElementById(this.id + '-txt');
    if (element) {
        element.innerHTML = text;
        element.style.left = coord.x + 'px';
        element.style.top = coord.y + 'px';
        this.text = text;
    }
    element = document.getElementById(this.id + '-img');
    if (element) {
        element.style.left = coord.x + 'px';
        element.style.top = coord.y - 24 + 'px'; // adjust based on image height
    }
};

AnnotationAnimation.prototype.update = (function() {
    var points = [];

    var target;
    var newVector;
    function init_three() {
        if (target)
            return;
        target = new THREE.Vector3();
        newVector = new THREE.Vector3();
    }


    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        init_three();

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            var element = document.getElementById(this.id);
            if (element) element.style.visibility = this.state;
            return;
        }

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                // interpolate
                if (type === "pos") {
                    if (this.interpolationType === INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];

                        scale = scale * 0.33 + 0.33;

                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);

                        if (this.interpolationType === INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();

                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }

                } else if (type === "text") {
                    var text = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextXYZ : prevXYZ;
                    this.updateText(object.position, text);
                } else if (type === "vis") {
                    var element = document.getElementById(this.id);
                    if (element) {
                        var visible = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextXYZ : prevXYZ;
                        element.style.visibility = visible? 'visible' : 'hidden';
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
    };
})();

var PolylineAnimation = function(root, data, animator) {
    this.viewer = animator.viewer;
    if (root === null) {
        root = this.createPolyline([]);
    }
    Animation.call(this, root, data, animator);
    this.epsilon = 0.1;
};

PolylineAnimation.prototype = Object.create(Animation.prototype);
PolylineAnimation.prototype.constructor = PolylineAnimation;
PolylineAnimation.prototype.keyTypes = ["points", "vis"];
PolylineAnimation.prototype.defaultKey = {points: [], vis: 1};

PolylineAnimation.prototype.stop = function() {
    Animation.prototype.stop.call(this);
    this.viewer.removeOverlay("polyline", this.root);
    this.root = null;
};

PolylineAnimation.prototype.update = (function() {
    function removePolyline(anim) {
        if (anim.root) {
            anim.viewer.removeOverlay("polyline", anim.root);
            anim.root = null;
        }
    }

    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        this.resetIfLooped();

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            removePolyline(this);
            return;
        }

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];

            // loop thru keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevPoints = prevKey[type];
                var nextPoints = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevPoints === undefined || nextPoints === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                if (type === "points") {
                    // interpolate start and end points
                    var points = scale < 0.5? prevPoints : nextPoints;
                    this.viewer.removeOverlay("polyline", this.root);
                    this.root = null;
                    var vertices = [];
                    for (var i = 0; i < points.length; i++) {
                        var pt = points[i].slice();
                        if (i === 0) {
                            pt[0] = prevPoints[i][0] + (nextPoints[i][0] - prevPoints[i][0]) * scale;
                            pt[1] = prevPoints[i][1] + (nextPoints[i][1] - prevPoints[i][1]) * scale;
                            pt[2] = prevPoints[i][2] + (nextPoints[i][2] - prevPoints[i][2]) * scale;
                        }
                        else if (i === points.length-1) {
                            var p = prevPoints.length - 1;
                            var n = nextPoints.length - 1;
                            pt[0] = prevPoints[p][0] + (nextPoints[n][0] - prevPoints[p][0]) * scale;
                            pt[1] = prevPoints[p][1] + (nextPoints[n][1] - prevPoints[p][1]) * scale;
                            pt[2] = prevPoints[p][2] + (nextPoints[n][2] - prevPoints[p][2]) * scale;
                        }
                        var newpt = new THREE.Vector3(pt[0], pt[1], pt[2]);
                        vertices.push(newpt);
                    }
                    this.root = this.createPolyline(vertices);
                } else if (type === "vis") {
                    var vis = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextPoints : prevPoints;
                    this.root.visible = vis;
                    if (!vis) removePolyline(this);
                }
            }
        }
    };
})();

PolylineAnimation.prototype.createPolyline = function(points) {
    var geometry = new THREE.Geometry();
    for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(points[i]);
    }
    geometry.computeLineDistances();

    var material = new THREE.LineDashedMaterial({color: 0x0, dashSize:1, gapSize:0.5, linewidth:1});
    var line = new THREE.Line(geometry, material, THREE.LineStrip);

    // add polyline to an overlay scene
    if (this.viewer.overlayScenes["polyline"] === undefined) {
        this.viewer.createOverlayScene("polyline");
    }
    this.viewer.addOverlay("polyline", line);

    return line;
};

// Catmull-Rom spline
function interpolateCatmullRom(points, scale) {
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;

        return (2 * (p1 - p2) + v0 + v1) * t3 + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    var c = [], v3 = [],
    point, intPoint, weight, w2, w3,
    pa, pb, pc, pd;

    point = (points.length - 1) * scale;
    intPoint = Math.floor(point);
    weight = point - intPoint;

    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

    pa = points[c[0]];
    pb = points[c[1]];
    pc = points[c[2]];
    pd = points[c[3]];

    w2 = weight * weight;
    w3 = weight * w2;

    v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
    v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
    v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);

    return v3;
}


avp.Animation = Animation;
avp.AnimationHandler = AnimationHandler;
avp.MeshAnimation = MeshAnimation;
avp.CameraAnimation = CameraAnimation;
avp.PolylineAnimation = PolylineAnimation;
avp.VisibilityAnimation = VisibilityAnimation;
avp.AnnotationAnimation = AnnotationAnimation;


})();

(function() {

"use strict";

var avp = Autodesk.Viewing.Private;

/**
 *  This is the keyframe animator class that performs keyframe animation
 *
 *  @constructor
 *  @alias Autodesk.Viewing.Private.KeyFrameAnimator
 *  @param {Viewer3DImpl} viewer The viewer
 *  @param {number} duration The duration of the animation in seconds
 */
var KeyFrameAnimator = function(viewer, duration) {
    this.animations = [];
    this.viewer = viewer;
    this.keys = [];
    this.isPlaying = false;
    this.isPaused = true;
    this.updateFlag = 0;
    this.duration = duration;
    this.currentTime = 0;
    this.onPlayCallback = null;
    this.animationHandler = new Autodesk.Viewing.Private.AnimationHandler();
    this.areCameraAnimationsPaused = false;
    this.UPDATE_SCENE = 1;
    this.UPDATE_CAMERA = 2;
};

/**
 * Destructor. Releasing references to other objects.
 */
KeyFrameAnimator.prototype.destroy = function() {
    this.stop();
    this.viewer = null;
    this.keys = null;
    this.animations = null;
    this.isPlaying = false;
    this.isPaused = false;
    this.animationHandler = null;
};

/**
 * Add an animation to the keyframe animator
 *
 * @param {object} animation The animation object to add
 */
KeyFrameAnimator.prototype.add = function(animation) {
    // return if animation has no hierarchy data or less than two keys
    if (!animation.hierarchy || animation.hierarchy.length < 1 || !animation.hierarchy[0].keys ||
        animation.hierarchy[0].keys.length < 2)
        return;

    var anim = null;
    var that = this;
    if (animation.type === "camera") {
        anim = new avp.CameraAnimation(that.viewer.camera, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "annotation") {
        anim = new avp.AnnotationAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "polyline") {
        anim = new avp.PolylineAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "mesh" || animation.type === "visibility") {
    
        that.viewer.model.getData().instanceTree.enumNodeFragments(animation.id, function(fragId) {

            var mesh = that.viewer.getFragmentProxy(that.viewer.model, fragId);
            if (mesh) {
                // meshes of the node will share same data
                if (animation.type === "mesh")
                    anim = new avp.MeshAnimation(mesh, animation, that);
                else
                    anim = new avp.VisibilityAnimation(mesh, animation, animation.id, that);
                    
                that.animations.push(anim);
            }
        
        }, true);
    
    }


    // sort and remove duplicates
    function sortAndRemoveDuplicateKeys(keys) {
        function removeDuplicates(a,b,c) {
            b=a.length;while(c=--b)while(c--)a[b]!==a[c]||a.splice(c,1);
        }

        // sort keys
        keys.sort(function(a, b) {return a-b});

        // remove duplicates
        removeDuplicates(keys);
    }

    if (anim) {
        // add keys
        for (var h = 0, hl = animation.hierarchy.length; h < hl; h ++) {
            var keys = animation.hierarchy[h].keys;
            for (var i = 0; i < keys.length; i++) {
                // add user defined (non extra) keys
                if (keys[i].xk === undefined)
                    that.keys.push(keys[i].time);
            }
        }
        sortAndRemoveDuplicateKeys(that.keys);
    }

    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Update all animations in the keyframe animator
 *
 * @param {number} time The time in second to advance
 * @return {number} 0 for no update, 1 for scene, 2 for camera, 3 for both
 */
KeyFrameAnimator.prototype.update = function(time) {
    this.animationHandler.update(time);
    var update = this.updateFlag;
    if (this.isPlaying && !this.isPaused) {
        this.currentTime += time;
        this.currentTime = Math.min(this.currentTime, this.duration);
        if (this.onPlayCallback) {
            // send playback percentage
            this.onPlayCallback(this.duration > 0? this.currentTime / this.duration * 100 : 0);    
        }
        if (this.currentTime >= this.duration) {
            this.pause();
        }
        update |= this.UPDATE_SCENE;
    }
    this.updateFlag = 0;
    return update;
};

/**
 * Play all animations
 *
 * @param {number} startTime The time in second to start
 */
KeyFrameAnimator.prototype.play = function(startTime, onPlayCallback) {
    this.onPlayCallback = onPlayCallback;

    // auto-rewind and play if reached the end
    if (this.currentTime >= this.duration) {
        this.goto(0);
    }

    if (this.isPlaying) {
        this.pause();
        return;
    }

    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.play(startTime);
    }

    this.isPlaying = true;
    this.isPaused = false;
};

/**
 * Pause all animations
 *
 */
KeyFrameAnimator.prototype.pause = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        // pause sync with same state
        if (animation.isPaused === this.isPaused) {
            animation.pause();
        }
    }

    this.isPaused = !this.isPaused;
    this.areCameraAnimationsPaused = this.isPaused;
};

/**
 * Pause camera animations
 *
 */
KeyFrameAnimator.prototype.pauseCameraAnimations = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        if (animation instanceof Autodesk.Viewing.Private.CameraAnimation) {
            animation.pause();
        }
    }

    this.areCameraAnimationsPaused = !this.areCameraAnimationsPaused;
};

/**
 * Stop all animations
 *
 */
KeyFrameAnimator.prototype.stop = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.stop();
    }

    this.isPlaying = false;
    this.isPaused  = false;
};

/**
 * Goto specific time in the animation
 *
 * @param {number} time The specific time in second
 */
KeyFrameAnimator.prototype.goto = function(time) {
    if (time === undefined) return;
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.goto(time);
    }

    this.isPlaying = true;
    this.isPaused  = true;
    this.currentTime = time;
    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Step forward to next key
 *
 */
KeyFrameAnimator.prototype.next = function() {
    // find next key time
    function findNextKey(time, keys) {
        var key = -1;
        for (var t = 0; t < keys.length; t++) {
            if (keys[t] > time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[keys.length-1] : key);
    }
    var time = findNextKey(this.currentTime, this.keys);
    this.goto(time);
};

/**
 * Step backward to previous key
 *
 */
KeyFrameAnimator.prototype.prev = function() {
    // find previous key time
    function findPrevKey(time, keys) {
        var key = -1;
        for (var t = keys.length-1; t > -1; t--) {
            if (keys[t] < time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[0] : key);
    }
    var time = findPrevKey(this.currentTime, this.keys);
    this.goto(time);
};

avp.KeyFrameAnimator = KeyFrameAnimator;


})();
(function() {

var av = Autodesk.Viewing,
    endp = av.endpoint = av.endpoint || {},
    avp = av.Private;

    endp.ENDPOINT_API_DERIVATIVE_SERVICE_V2 = 'derivativeV2';
    endp.ENDPOINT_API_MODEL_DERIVATIVE_V2 = 'modelDerivativeV2';

    var _apis_data = {
        derivativeV2:  {
            baseURL: '/derivativeservice/v2',
            itemURL: '/derivativeservice/v2/derivatives/:derivativeurn',
            manifestURL: '/derivativeservice/v2/manifest/:urn',
            thumbnailsURL: '/derivativeservice/v2/thumbnails/:urn'
        },
        modelDerivativeV2: {
            baseURL: '/modelderivative/v2/',
            itemURL: '/modelderivative/v2/designdata/:urn/manifest/:derivativeurn',
            manifestURL: '/modelderivative/v2/designdata/:urn/manifest',
            thumbnailsURL: '/modelderivative/v2/designdata/:urn/thumbnail'
        }
    };

    var _endpoint = '';
    var _api = endp.ENDPOINT_API_DERIVATIVE_SERVICE_V2;
    var _useCredentials = false;

    endp.HTTP_REQUEST_HEADERS = {};

    /**
     * Sets the endpoint and api to be used to create REST API request strings.
     * @param {string} endpoint
     * @param {string} api - Possible values are derivativeV2, modelDerivativeV2
     */
    endp.setEndpointAndApi = function(endpoint, api) {
        _endpoint = endpoint;
        _api = api;
    };

    /**
     * Returns the endpoint plus the api used to create REST API request strings.
     * Examples: "viewing.api.autodesk.com/derivativeservice/v2", "developer.api.autodesk.com/modelderivative/v2/"
     * @returns {string}
     */
    endp.getEndpointAndApi = function() {
        return _endpoint + _apis_data[_api].baseURL;
    };

    /**
     * Returns the endpoint used to create REST API request strings.
     * Examples: "viewing.api.autodesk.com", "developer.api.autodesk.com"
     * @returns {string}
     */
    endp.getApiEndpoint = function() {
        return _endpoint;
    };

    /**
     * Returns a REST API request strings to be used to get the manifest of the provided urn.
     * Examples: "viewing.api.autodesk.com/derivativeservice/v2/urn" or
     * "developer.api.autodesk.com/modelderivative/v2/designdata/urn/manifest"
     * @param {string | null} endpoint - When provided is used instead of the globally set endpoint.
     * @param {string} urn
     * @param {string} api - When provided is used instead of the globally set API flavor
     * @returns {string}
     */
    endp.getManifestApi = function(endpoint, urn, api) {
        var url = (endpoint || _endpoint);
        api = api || _api;
        url += _apis_data[api].manifestURL;
        // If urn is not provided we return same string that before for backward compatibility.
        urn = urn || '';
        url = url.replace(':urn', urn);
        return url;
    };

    /**
     * Returns a REST API request strings to be used to get a derivative urn.
     * Examples: "viewing.api.autodesk.com/derivativeservice/v2/urn",
     * "developer.api.autodesk.com/modelderivative/v2/designdata/urn/manifest/derivativeurn"
     * @param {string | null} endpoint - When provided is used instead of the globally set API endpoint.
     * @param {string} derivativeUrn
     * @param {string} api - When provided is used instead of the globally set API flavor
     * @returns {string}
     */
    endp.getItemApi = function(endpoint, derivativeUrn, api) {
        var itemApi = (endpoint || _endpoint) + _apis_data[api || _api].itemURL;

        // If urn is not provided we return same string that before for backward compatibility.
        derivativeUrn = derivativeUrn || '';

        // Extract svf urn from item urn, needed when using model derivative.
        var urn = derivativeUrn;
        urn = urn.split('/');
        urn = urn[0] || '';
        urn = urn.split(':');
        urn = urn[urn.length-1] || '';

        itemApi = itemApi.replace(':urn', urn);
        itemApi = itemApi.replace(':derivativeurn', derivativeUrn);

        return itemApi;
    };

    /**
     * Returns a REST API request strings to be used to get the thumbnail for a specific urn.
     * Examples: "viewing.api.autodesk.com//derivativeservice/v2/thumbnails/urn",
     * "developer.api.autodesk.com/modelderivative/v2/modelderivative/v2/designdata/urn/thumbnail"
     * @param {string | null} endpoint - When provided is used instead of the globally set endpoint.
     * @param {string} urn
     * @param {string} api - When provided is used instead of the globally set API flavor
     * @returns {string}
     */
    endp.getThumbnailApi = function(endpoint, urn, api) {
        var thumbnailApi = (endpoint || _endpoint) + _apis_data[api || _api].thumbnailsURL;
        return thumbnailApi.replace(':urn', urn || '');
    };

    endp.makeOssPath = function(root, bucket, object) {
        return (root || _endpoint) + "/oss/v2/buckets/" + bucket + "/objects/" + encodeURIComponent(decodeURIComponent(object));
    };

    endp.getUseCredentials = function() {
        return _useCredentials;
    };

    endp.pathRequiresCredentials = function(path) {
        return path.indexOf('://') === -1 ||
            path.indexOf(window.location.host) !== -1 ||
            avp.urlIsApiViewingOrDev(path);
    };

    endp.getDomainParam = function() {
        return (this.getUseCredentials() && !av.isNodeJS) ? ("domain=" + encodeURIComponent(window.location.origin)) : "";
    };

    endp.setUseCredentials = function(useCredentials) {
        _useCredentials = useCredentials;
    };

    // TODO: Deprecate.
    endp.setApiEndpoint = function(endpoint) {
        _endpoint = endpoint;
        _api = endp.ENDPOINT_API_DERIVATIVE_SERVICE_V2;
    };

    // TODO: Deprecate.
	/**
     * @deprecated
     * @param root
     * @returns {*}
     */
    av.getViewingUrl = function(root) {
        return (root || _endpoint) + _apis_data[_api].baseURL;
    };

})();


(function() {

"use strict";

var av = Autodesk.Viewing,
    endp = av.endpoint = av.endpoint || {},
    avp = av.Private;

    var global = av.getGlobal();

    endp.PROTEIN_ROOT = null;
    endp.PRISM_ROOT = null;
    global.LOCALIZATION_REL_PATH = "";
    global.LMV_VIEWER_VERSION = "3.1";  // Gets replaced with content from deployment/package.json
    global.LMV_VIEWER_PATCH = "1";// Gets replaced with build number from TeamCity
    global.LMV_BUILD_TYPE = "RELEASE"; // Either Development or Release/RELEASE
    global.LMV_RESOURCE_VERSION = null;
    global.LMV_RESOURCE_ROOT = "";

    if (LMV_VIEWER_VERSION.charAt(0) === 'v'){
        // remove prefixed 'v'
        // Required due to TeamCity build pipeline (LMV-1361)
        LMV_VIEWER_VERSION = LMV_VIEWER_VERSION.substr(1);
    }


    global.stderr = function() {
        console.warn('"stderr" is deprecated; please use "Autodesk.Viewing.Private.logger" instead');
    };

    avp.env = null;
    // GUID of the current active document item.
    avp.docItemId = null;

    avp.token = {
        accessToken : null,
        getAccessToken : null,
        tokenRefreshInterval : null
    };

    // A list of resources that record the URL and necessary auxilary information (such as ACM headers and / or
    // session id) required to get the resource. This bag of collection will be passed from JS to native code so
    // all viewer consumable resources could be downloaded on native side for offline viewing.
    // avp.assets = isAndroidDevice() ? [] : null;
    avp.assets = [];
    // Set viewer in offline mode if set to true. In offline mode, viewer would ignore all URNs in bubble JSON
    // and assume the viewables are laid out in local file system path relative to the bubble.json.
    avp.offline = false;
    // Offline resource prefix specified by viewer consumer (e.g. IOS web view). Used as prefix to concatenate with
    // each resource relative path to form the absolute path of each resource.
    avp.offlineResourcePrefix = null;

    var LmvEndpoints = {
        local: {
            RTC:        ['https://rtc-dev.api.autodesk.com:443', 'https://lmv.autodesk.com:443'] //port # is required here.
        },
        dev: {
            RTC:        ['https://rtc-dev.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        },
        stg: {
            RTC:        ['https://rtc-stg.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        },
        prod: {
            RTC:        ['https://rtc.api.autodesk.com:443', 'https://lmv.autodesk.com:443']
        }
    };

    var ViewingApiUrls = {
        local: "",
        dev: "https://viewing-dev.api.autodesk.com",
        stg: "https://viewing-staging.api.autodesk.com",
        prod: "https://viewing.api.autodesk.com"
    };

    var DevApiUrls = {
        local: "",
        dev: "https://developer-dev.api.autodesk.com",
        stg: "https://developer-stg.api.autodesk.com",
        prod: "https://developer.api.autodesk.com"
    };

    // The apps on https://developer.autodesk.com had to be created under an ADS account... Ask for brozp
    var AdpConfigs = {
        stg: { CLIENT_ID: 'lmv-stag', CLIENT_KEY: 'kjemi1rwAgsqIqyvDUtc9etPD6MsAzbV', ENDPOINT: 'https://ase-stg.autodesk.com' },
        prod: { CLIENT_ID: 'lmv-prod', CLIENT_KEY: 'iaoUM2CRGydfn703yfPq4MAogZi8I5u4', ENDPOINT: 'https://ase.autodesk.com' }
    };

    avp.EnvironmentConfigurations = {
        Local: {
            ROOT:       '',
            LMV:        LmvEndpoints["local"]
        },
        Development: {
            ROOT:       ViewingApiUrls["dev"],
            LMV:        LmvEndpoints["dev"],
            bubbleManifest: true
        },
        Staging: {
            ROOT:       ViewingApiUrls["stg"],
            LMV:        LmvEndpoints["stg"],
            bubbleManifest: true
        },
        Production: {
            ROOT:       ViewingApiUrls["prod"],
            LMV:        LmvEndpoints["prod"],
            bubbleManifest: true
        },
        AutodeskDevelopment: {
            ROOT:       DevApiUrls["dev"],
            LMV:        LmvEndpoints["dev"]
        },
        AutodeskStaging: {
            ROOT:       DevApiUrls["stg"],
            LMV:        LmvEndpoints["stg"]
        },
        AutodeskProduction: {
            ROOT:       DevApiUrls["prod"],
            LMV:        LmvEndpoints["prod"]
        }
    };


    avp.initializeEnvironmentVariable = function (options) {
        var env;

        // Use the enviroment that was explicitly specified.
        //
        if (options && options.env) {
            env = options.env;
        }

        // If not available, check if the environment was specified in the query parameters.
        //
        if (!env) {
            env = avp.getParameterByName("env");
        }

        if (options && options.offlineResourcePrefix) {
            avp.offlineResourcePrefix = options.offlineResourcePrefix;
        }

        if (options && options.offline && options.offline === "true") {
            avp.offline = true;
        }

        // If still not available, try to resolve the environment based on the url.
        //
        if (!env) {
            switch (window.location.hostname) {
                case "viewing-dev.api.autodesk.com" :
                    env = 'Development';
                    break;
                case "viewing-staging.api.autodesk.com" :
                    env = 'Staging';
                    break;
                case "viewing.api.autodesk.com" :
                    env = 'Production';
                    break;
                case "developer-dev.api.autodesk.com" :
                    env = 'AutodeskDevelopment';
                    break;
                case "developer-stg.api.autodesk.com" :
                    env = 'AutodeskStaging';
                    break;
                case "developer.api.autodesk.com" :
                    env = 'AutodeskProduction';
                    break;

                case "localhost.autodesk.com" :
                    env = 'Local';
                    break;
                case "" : // IP addresses on Chrome.
                    env = 'Local';
                    break;
                case "127.0.0.1" :
                    env = 'Local';
                    break;
                default:
                    env = 'AutodeskProduction';
            }
        }

        avp.env = env;

        if (typeof window !== "undefined") {
            avp.logger.info("Host name : " + window.location.hostname);
        }
        avp.logger.info("Environment initialized as : " + env);
    };

    avp.initializeServiceEndPoints = function (options) {

        // Get endpoint.
        var endpoint = options.endpoint;
        if (!endpoint) {
            var config = avp.EnvironmentConfigurations[avp.env];
            endpoint = config['ROOT'];
        }

        // Get endpoint api.
        var api = options.api || av.endpoint.ENDPOINT_API_DERIVATIVE_SERVICE_V2;

        av.endpoint.setEndpointAndApi(endpoint, api);

        if (av.isNodeJS)
            return;

        //Derive the root for static viewer resources based on the
        //location of the main viewer script
        var libList = [
            "viewer3D.js",
            "viewer3D.min.js",
            "firefly.js",
            "firefly.min.js"
        ];
        if (options && options.hasOwnProperty('libraryName'))
            libList.push(options.libraryName);

        var root;
        var scriptUrl;

        // TODO_NOP: this doesn't work for Polymer / Web Components
        for (var i=0; i<libList.length; i++) {
            var script = avp.getScript(libList[i]);
            scriptUrl = script ? script.src : "";
            var idx = scriptUrl.indexOf(libList[i]);
            if (idx >= 0) {
                root = scriptUrl.substr(0, idx);
                break;
            }
        }

        //Derive any custom version request
        LMV_RESOURCE_VERSION = "v" + LMV_VIEWER_VERSION;

        var version = avp.getParameterByNameFromPath("v", scriptUrl);
        if (version && version.length && version != LMV_RESOURCE_VERSION) {
            avp.logger.warn("Version string mismatch between requested and actual version: " + version + " vs. " + LMV_RESOURCE_VERSION + ". Using " + version);
            LMV_RESOURCE_VERSION = version;
        } else if (!version || !version.length) {
            LMV_RESOURCE_VERSION = null;
            avp.logger.info("No viewer version specified, will implicitly use " + LMV_VIEWER_VERSION);
        }

        LMV_RESOURCE_ROOT = root || LMV_RESOURCE_ROOT;
    };

    avp.initLoadContext = function(inputObj) {

        inputObj = inputObj || {};

        inputObj.auth = av.endpoint.getUseCredentials();
        inputObj.endpoint = av.endpoint.getApiEndpoint();

        if (!inputObj.headers)
            inputObj.headers = {};

        var endp = av.endpoint;
        for (var p in endp.HTTP_REQUEST_HEADERS) {
            inputObj.headers[p] = endp.HTTP_REQUEST_HEADERS[p];
        }

        //This is done to avoid CORS errors on content served from proxy or browser cache
        //The cache will respond with a previously received response, but the Access-Control-Allow-Origin
        //response header might not match the current Origin header (e.g. localhost vs. developer.api.autodesk.com)
        //which will cause a CORS error on the second request for the same resource.
        var domainParam = av.endpoint.getDomainParam();
        if (domainParam) {
            if (inputObj.queryParams) {
                inputObj.queryParams += "&" + domainParam;
            } else {
                inputObj.queryParams = domainParam;
            }
        }


        return inputObj;
    };
  
    // Refresh the token in request header, in case that the third party cookie is disabled
    avp.refreshRequestHeader = function(token) {

        av.endpoint.HTTP_REQUEST_HEADERS["Authorization"] = "Bearer " + token;

    };

    avp.refreshToken = function(token, onSuccess, onError) {

        // Store the token
        avp.token.accessToken = token;        
        avp.refreshRequestHeader(token);

        if (onSuccess instanceof Function) {
            onSuccess();
        }
    };

    avp.initializeAuth = function (onSuccessCallback, options) {

        var shouldInitializeAuth = options ? options.shouldInitializeAuth : undefined;
        if (shouldInitializeAuth === undefined) {
            var p = avp.getParameterByName("auth");
            shouldInitializeAuth = (p.toLowerCase() !== "false");
        }

        //Skip Auth in case we are serving the viewer locally
        if (avp.env == "Local" || !shouldInitializeAuth) {
            setTimeout(onSuccessCallback, 0);
            av.endpoint.setUseCredentials((typeof options.useCredentials !== "undefined") ? options.useCredentials : false);
            return av.endpoint.getUseCredentials();
        }

        av.endpoint.setUseCredentials((typeof options.useCredentials !== "undefined") ? options.useCredentials : true);

        var accessToken;

        function onGetAccessToken(token /* access token value. */, expire /* expire time, in seconds. */) {
            accessToken = token;
            avp.refreshToken(accessToken, avp.token.tokenRefreshInterval ? null /* If this is a token refresh call,
             don't invoke the onSuccessCallback which will loadDocument and so on. */
                : onSuccessCallback);
            var interval = expire - 60; // Refresh 1 minute before token expire.
            if (interval <= 0) {
                // We can't get a precise upper bound if the token is such a short lived one (expire in a minute),
                // so just use the original one.
                interval = expire;
            }
            avp.token.tokenRefreshInterval = interval * 1000;
            setTimeout(function() {options.getAccessToken(onGetAccessToken)}, avp.token.tokenRefreshInterval);
        }

        if (options && options.getAccessToken) {
            avp.token.getAccessToken = options.getAccessToken;

            accessToken = options.getAccessToken(onGetAccessToken);

            //Backwards compatibility with the old synchronous API
            if (typeof accessToken === "string" && accessToken) {
                avp.refreshToken(accessToken, onSuccessCallback);
            }

        } else if (options && options.accessToken) {
            accessToken = options.accessToken;
            avp.refreshToken(accessToken, onSuccessCallback);
        } else {
            accessToken = avp.getParameterByName("accessToken");
            if (!accessToken) {
                accessToken = "9AMaRKBoPCIBy61JmQ8OLLLyRblS";
                avp.logger.warn("Warning : no access token is provided. Use built in token : " + accessToken);
            }
            avp.refreshToken(accessToken, onSuccessCallback);
        }

        //TODO: this seems like a pointless thing to return
        return av.endpoint.getUseCredentials();
    };

    avp.initializeLogger = function (options) {

        avp.logger.initialize(options);

        // ADP is opt-out
        if (options && options.hasOwnProperty('useADP') && options.useADP == false) {
            return;
        }
        //Also bail on ADP if we are a node module
        if (av.isNodeJS)
            return;

        // Load Autodesk Data Platform client
        // (and if we're in RequireJS environment, use its APIs to avoid problems)
        var url = 'https://ase-cdn.autodesk.com/adp/v1.0.3/js/adp-web-analytics-sdk.min.js';
        var callback = function() {
            if (typeof (Adp) === 'undefined') {
                avp.logger.warn('Autodesk Data Platform SDK not found');
                return;
            }

            var adpConfig;
            switch (LMV_BUILD_TYPE) {
                case 'Production': adpConfig = AdpConfigs['prod']; break;
                default: adpConfig = AdpConfigs['stg']; break;
            }
            var facets = {
                product: {
                    name: 'LMV',
                    line_name: 'LMV',
                    key: adpConfig.CLIENT_ID,
                    id: adpConfig.CLIENT_KEY,
                    id_provider: 'appkey',
                    build_id: LMV_VIEWER_VERSION + '.' + LMV_VIEWER_PATCH,
                    build_tag: LMV_BUILD_TYPE
                }
            };
            var config = {
                server: adpConfig.ENDPOINT,
                enable_geo_data: false,
                enable_browser_data: true,
                enable_session_messages: true
            };
            avp.logger.adp = new Adp(facets, config);
        };

        if (typeof require === 'function') {
            require([url], function(adp) {
                window.Adp = adp;
                callback();
            });
        } else {
            avp.loadDependency('Adp', url, callback);
        }

    };

    avp.initializeProtein = function () {

        //For local work, don't redirect texture requests to the CDN,
        //because local ones will load much faster, presumably.
        if (avp.ENABLE_DEBUG && avp.env == "Local" && !av.endpoint.getUseCredentials() /* when auth is true, the viewer is operating under
        local mode but connect to remote server to get data. */)
            return;

        // In offline mode, viewer will get the texture from the locally cached SVF data sets, instead pinging texture
        // CDN.
        // TODO: this will break when translators stop including Protein into SVF.
        if (avp.offline) {
            return;
        }

        var xhr1 = new XMLHttpRequest();
        xhr1.open("GET", "https://raas-assets.autodesk.com/StaticContent/BaseAddress?family=protein", true);
        xhr1.responseType = "json";

        xhr1.onload = function (e) {
            var res = xhr1.response.url;
            if (res && res.length) {
                res = res.replace("http://", "https://");
                av.endpoint.PROTEIN_ROOT = res + "/";
                avp.logger.info("Protein root is: " + av.endpoint.PROTEIN_ROOT);
            }
        };

        xhr1.send();

        var xhr2 = new XMLHttpRequest();
        xhr2.open("GET", "https://raas-assets.autodesk.com/StaticContent/BaseAddress?family=prism", true);
        xhr2.responseType = "json";

        xhr2.onload = function (e) {
            var res = xhr2.response.url;
            if (res && res.length) {
                res = res.replace("http://", "https://");
                av.endpoint.PRISM_ROOT = res + "/";
                avp.logger.info("Prism root is: " + av.endpoint.PRISM_ROOT);
            }
        };

        //xhr.onerror = ;
        //xhr.ontimeout = ;

        xhr2.send();
    };

// Returns the query parameter value from window url
    avp.getParameterByName = function (name) {
        if (typeof window === "undefined") {
            return "";
        }
        return avp.getParameterByNameFromPath(name, window.location.href);
    };

// return value of parameter from a url
    avp.getParameterByNameFromPath = function (name, url) {
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(url);
        if (results == null)
            return "";
        else
            return decodeURIComponent(results[1].replace(/\+/g, " "));
    };

    avp.urlIsApiViewingOrDev = function(url) {
                // Dev API endpoints
        return  url.indexOf('developer.api.autodesk.com') !== -1 ||
                url.indexOf('developer-stg.api.autodesk.com') !== -1 ||
                url.indexOf('developer-dev.api.autodesk.com') !== -1 ||
                // Viewing API endpoints
                url.indexOf('viewing.api.autodesk.com') !== -1 ||
                url.indexOf('viewing-staging.api.autodesk.com') !== -1 ||
                url.indexOf('viewing-dev.api.autodesk.com') !== -1;
    };

// Return a default document URN for demo purpose.
    avp.getDemoDocumentURN = function () {
        var documentId;

        switch (avp.env) {
            case "Development" :
                //documentId = "urn:dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6Y29sdW1idXMvTWljaGFlbF9IYW5kLV8tYjE0MDk3ODQxNzcwMDZSQ0Nhci5kd2Y";
                documentId = "urn:dXJuOmFkc2suYTM2MGJldGFkZXY6ZnMuZmlsZTplbnRlcnByaXNlLmxtdnRlc3QuRFM1YTczMFFUYmYwMDIyZDA3NTFhYmE5MjZlZDZkMjJlZDY0P3ZlcnNpb249MQ==";
                break;
            case "Staging" :
                documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
                break;
            case "Production" :
                documentId = "FIXME";
                break;
            default:
                //documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvUkMgQ2FyLmR3Zg"
                documentId = "https://lmv.rocks/viewer/data/gears/output/bubble.json";
        }

        return documentId;
    };

    /**
     * Normalizes memory options passed into the viewer instance or stated in the URL
     * The URL parameter to check is `viewermemory` and has a number value that represents
     * the MegaByte memory limit.
     * @example: 
     *      ?viewermemory=500 ----- set memory limit of 500 MB
     *      ?viewermemory=500f ---- force memory limit of 500 MB, which activates on-demand-loading mechanism (debug). 
     * @private
     */
    avp.processMemoryOptions = function(config3d) {
        
        if (!config3d)
            return;

        var memLimit;
        // Verify memory values are valid/consistant
        if (config3d.memory) {
            memLimit = parseInt(config3d.memory.limit) | 0;
            var forced = (config3d.memory.debug && config3d.memory.debug.force) || false;
            if (forced && memLimit <= 0) {
                config3d.memory.force = false; // disable forced when the limit is not valid.
                avp.logger.warn('config.memory.limit value is invalid: (' + config3d.memory.limit + ')');
            }
        }

        // If URL argument is passed in, override limit specified through code
        var urlValue = avp.getParameterByName('viewermemory');
        memLimit = parseInt(urlValue);
        // If urlValue isn't a number, memLimit will be a NaN and comparison will fail.
        if (memLimit >= 0) {
            // Now, truncate memLimit to an integer.
            memLimit = memLimit | 0;
            // Only allow forced when memLimit > 0, memLimit == 0 disables the limit.
            var isForced = memLimit > 0 && urlValue.charAt(urlValue.length-1).toLowerCase() === 'f'; // Check if there is an F at the end.
            config3d.memory = { 
                limit: memLimit,
                debug: { force: isForced }
             };
            if (isForced) {
                avp.logger.info('Forcing memory limit to URL param: (' + memLimit + ' MegaBytes).');
            } else {
                avp.logger.info('Setting memory limit to URL param: (' + memLimit + ' MegaBytes).');
            }
        } else {
			// don't issue warning if viewermemory parameter (e.g., "&viewermemory=500") is not in URL at all
			if ( urlValue !== "" )
				avp.logger.warn('Invalid viewermemory URL param value: (' + urlValue + ')');
        }
    };

    avp.setLanguage = function (language, callback) {

        var options = {
            lng: language,
            resGetPath: 'res/locales/__lng__/__ns__.json',
            ns: {
                namespaces: ['allstrings'],
                defaultNs: 'allstrings'
            },
            fallbackLng: "en",
            debug: false
        };

        LOCALIZATION_REL_PATH = "res/locales/" + language + "/";
        Autodesk.Viewing.i18n.init(options, function (t) {
            Autodesk.Viewing.i18n.clearDebugLocString(); //Calls localize as well
            if (callback) {
                callback();
            }
        });
    };

    avp.extendLocalization = function (locales) {
        if (locales !== null && typeof locales === "object") {
            Object.keys(locales).forEach(function(language) {
                Autodesk.Viewing.i18n.addResourceBundle(
                    language,
                    "allstrings",
                    locales[language],
                    true,
                    true
                );
            });
            return true;
        }
        return false;
    };

    avp.initializeLocalization = function (options) {
        // Initialize language for localization. The corresponding string files
        // will be downloaded.
        var language = (options && options.language) || navigator.language;

        // use iso scheme (ab/ab-XY)
        var tags = language.split('-');
        language = tags.length > 1 ? tags[0].toLowerCase() + '-' + tags[1].toUpperCase() : tags[0].toLowerCase();

        // check supported language tags and subtags
        var supportedTags = ["cs", "de", "en", "es", "fr", "it", "nl", "ja", "ko", "pl", "pt-BR", "ru", "tr", "zh-HANS", "zh-HANT"];
        if (supportedTags.indexOf(language) === -1) {
            if (language.indexOf("zh-CN") > -1) language = "zh-HANS";
            else if (language.indexOf("zh-TW") > -1) language = "zh-HANT";
            else if (tags.length > 1 && supportedTags.indexOf(tags[0]) > -1) language = tags[0];
            else language = "en";
        }

        // Uncomment below to default to english
        //language = "en";
        avp.setLanguage(language);
    };

    avp.initializeUserInfo = function (options) {
        if (!options || !options.userInfo) return;
        avp.setUserName(options.userInfo.name);
        if (options.comment2Token) {
            avp.comment2Token = options.comment2Token;
        }
    };


// TODO:  This is here for now, until we find a better place for it.
//
    /**
     * Returns the first source url found containing the given script name.
     * @private
     * @param {string} scriptName - Script name.
     * @returns {HTMLScriptElement} The script element whose source location matches the input parameter.
     */
    avp.getScript = function (scriptName) {
        scriptName = scriptName.toLowerCase();
        var scripts = document.getElementsByTagName('SCRIPT');
        if (scripts && scripts.length > 0) {
            for (var i = 0; i < scripts.length; ++i) {
                if (scripts[i].src && scripts[i].src.toLowerCase().indexOf(scriptName) !== -1) {
                    return scripts[i];
                }
            }
        }
        return null;
    };

    /**
     * Returns the full url of a resource with version.
     * The version will be determined from the LMV_VIEWER_VERSION variable.
     * @private
     * @param {string} resourceRelativePath - The path of the resource relative to LMV_RESOURCE_ROOT.
     * @returns {string} The full resource path.
     */
    avp.getResourceUrl = function (resourceRelativePath) {
        var version = LMV_RESOURCE_VERSION;
        return LMV_RESOURCE_ROOT + resourceRelativePath + (version ? ('?v=' + version) : '');
    };

    /**
     * @param {string} libNamespace - window property name expected to be loaded after library is on the document if it contains '://' will be use to resolve the url insted of libName.
     * @param {string} libName - url to load the library from.
     * @param {function} callback - success callback function
     * @param {function} onError - error callback function
     * @param {string} amdName - Should be the name module defined on the define function.
     * @description  Loads a script (e.g. an external library JS) and calls the callback once loaded. Used for delayed loading of required libraries. Accepts both relative and absolute URLs.
     */
    avp.loadDependency = function(libNamespace, libName, callback, onError, amdName) {
        if (typeof window[libNamespace] === "undefined") {
            var s = document.createElement("SCRIPT");
            s.src = libName.indexOf('://') > 0 ? libName : avp.getResourceUrl(libName);
            var clearCallbacks = function() {
                s.onerror = null;
                s.onload = null;
            };
            var errCallback = function() {
                clearCallbacks();
                onError && onError();
            };
            var successCallback = function() {
                clearCallbacks();
                //if there is a dependency which use amd and we are running on amd environment we load it through require
                if(typeof define === 'function' && define.amd && typeof require === 'function' && amdName) {
                    require([amdName], function(moduleDefinition) {
                        window[libNamespace] = moduleDefinition;
                        callback && callback();
                    }, errCallback);
                } else {
                    callback &&  callback();
                }
            };
            s.onload = successCallback;
            s.onerror = errCallback;
            document.head.appendChild(s);
        }
        else if (callback)
            callback();
    };

    /**
     * Inject a css file into the page. 
     * There's a callback if you need to know when it gets downloaded (rare).
     * Accepts both relative and absolute URLs.
     */
    avp.injectCSS = function(cssUrl, callback, onError) {
        var href = cssUrl.indexOf('://') > 0 ? cssUrl : avp.getResourceUrl(cssUrl);

        // Verify that we haven't downloaded it already
        var results = document.getElementsByTagName('link');
        for (var i=0, len=results.length; i<len; i++) {
            if (results[i].href === href) {
                // Already downloaded
                callback && callback();
                return;
            }
        }

        // else, download it
        var s = document.createElement("link");
        s.setAttribute('rel',"stylesheet");
        s.setAttribute('type',"text/css");
        s.setAttribute('href', href);
        if (callback) {
            s.onload = callback;
        }
        if (onError) {
            s.onerror = onError;
        }
        document.head.appendChild(s);
    };

    /**
     * Download an HTML template. 
     * If successful, will invoke callback(null, templateString)
     * If failure, will invoke callback("some error", null)
     */
    avp.getHtmlTemplate = function(templateUrl, callback) {
        var href = templateUrl.indexOf('://') > 0 ? templateUrl : avp.getResourceUrl(templateUrl);
        var request = new XMLHttpRequest();
        request.onload = requestLoad;
        request.onerror = requestError;
        request.ontimeout = requestError;
        request.open('GET', href, true);
        request.send();

        function requestError(err) {
            callback(err, null);
        }
        function requestLoad(event) {
            var content = event.currentTarget.responseText;
            callback(null, content);
        }
        
    };

    /**
     * @typedef {Object} InitOptions
     * @property {string} env 
     *          Can be "AutodeskProduction" (default), "AutodeskStaging", or "AutodeskDevelopment".
     * @property {string} api
     *          Can be undefined (default), "derivativeV2", or "modelDerivativeV2".
     * @property {function} getAccessToken
     *          A function that provides an access token asynchronously.
     *          The function signature is `getAccessToken(onSuccess)`, where onSuccess is a callback that getAccessToken
     *          function should invoke when a token is granted, with the token being the first input parameter for the
     *          onSuccess function, and the token expire time (in seconds) being the second input parameter for the
     *          function. Viewer relies on both getAccessToken and the expire time to automatically renew token, so
     *          it is critical that getAccessToken must be implemented as described here.
     * @property {string} language
     *          Preferred language code as defined in RFC 4646, such as "en", "de", "fr", etc.
     *          If no language is set, viewer will pick it up from the browser. If language is not as defined in RFC,
     *          viewer will fall back to "en" but the behavior is undefined.
     * @property {number} logLevel
     *          Specifies which types of messages will be logged into the console. 
     *          Values are: 5 Debug, 4 Logs, 3 Info, 2 Warnings, 1 Errors, 0 None.
     *          Defaults to (1) for Errors only.
     *          All values can be found in Autodesk.Viewing.Private.LogLevels.
     * @property {string} webGLHelpLink
     *          A link url to a help page on webGL if it's disabled. Supported only
     *          when using the GuiViewer3D instance; not supported in headless mode.
     */


    /**
     * Returns a new object that can be passed to Autodesk.Viewing.Initializer() for
     * initialization. Developers should consider customizing attributes in this object
     * before passing it to Autodesk.Viewing.Initializer().
     * 
     * Available since version 2.13
     * 
     * @returns {InitOptions} Can be passed into Autodesk.Viewing.Initializer()
     * 
     * @example
     *  var options = Autodesk.Viewing.createInitializerOptions();
     *  options.getAccessToken = function(onSuccess) {
     *      var accessToken, expire;
     *      // Code to retrieve and assign token value to
     *      // accessToken and expire time in seconds.
     *      onSuccess(accessToken, expire);
     *  };
     *  Autodesk.Viewing.Initializer(options, function() {
     *      alert("initialization complete");
     *  });
     * 
     * 
     * @category Core
     */
    Autodesk.Viewing.createInitializerOptions = function() {

        // Attributes fully supported
        // See @typedef {Object} InitOptions above for details on each one of these...
        var opts = {  
            env: 'AutodeskProduction',
            // TODO: Use commented api when we deprecate useDerivativeServiceV2 flag and old endpoints.js.
            api: undefined /*av.endpoint.ENDPOINT_API_DERIVATIVE_SERVICE_V2*/,
            getAccessToken: undefined,
            language: undefined,
            logLevel: avp.LogLevels.ERROR,
            webGLHelpLink: null
        };

        // Attributes that exist, but we don't fully support (yet)
        // opts.offline: false,
        // opts.offlineResourcePrefix: 'data'

        return opts;
    };

    /**
     * @typedef {Object} ViewerConfig
     * @property {array} extensions 
     *          Ids of extensions that need to be loaded always.
     * @property {string} sharedPropertyDbPath
     *          Some documents have a global Property Database file, which is shared across all
     *          referenced 2D and 3D models. Use Document.getPropertyDbPath() to populate this field;
     *          automatically populated when using a ViewingApplication instance.
     * @property {Object} canvasConfig
     *          Allows to modify the default user input interactions with the viewer. For example, one
     *          could change the left-mouse click to isolate a node instead of selecting it.
     * @property {boolean} startOnInitialize
     *          True by default, whether viewer.run() gets invoked as soon as initialization is complete,
     *          effectively commencing the viewer's main rendering loop. 
     * @property {array} experimental
     *          An interface to enable experimental features that are yet to be released.
     *          Each feature is identified with a string. To enable a feature, remove the first two double dashes.
     */

    /**
     * Returns a new object that can be passed to a Viewer instance when created.
     * 
     * Available since version 2.13
     * 
     * @returns {ViewerConfig} 
     *          Can be passed into a ViewingApplication's registerViewer() 3rd parameter,
     *          or directly when constructing a Viewer instance.
     * 
     * @example
     * var myConfig = Autodesk.Viewing.createViewerConfig();
     * myConfig.extensions.push('MyAwesomeExtension');
     * //
     * // Direct usage...
     * var myViewer = new Autodesk.Viewing.Viewer3D( myDiv, myConfig );
     * //
     * // ...or through a ViewingApplication
     * viewerApp = new Autodesk.Viewing.ViewingApplication('MyViewerDiv');
     * viewerApp.registerViewer(viewerApp.k3D, Autodesk.Viewing.Private.GuiViewer3D, myConfig);
     * 
     * 
     * @category Core
     */
    Autodesk.Viewing.createViewerConfig = function() {

        // Global Viewer configuration values
        var config = {

            extensions: [],
            // useConsolidation: false, // 100 MB -- Needs work before exposing (here or elsewhere)
            // consolidationMemoryLimit: 100 * 1024 * 1024, // 100 MB -- Needs work before exposing (here or elsewhere)
            sharedPropertyDbPath: undefined,
            // bubbleNode: undefined, -- Needs work before exposing here.
            canvasConfig: undefined, // TODO: Needs documentation or something.
            startOnInitialize: true,

            // Enables experimental, non-supported features
            experimental: []
        };

        // Ask each extension to register their default options
        Autodesk.Viewing.theExtensionManager.popuplateOptions(config);

        // Also ask the bundled viewers
        av.Viewer3D && av.Viewer3D.populateConfigOptions(config);
        avp.GuiViewer3D && avp.GuiViewer3D.populateConfigOptions(config);

        return config;
    };

    /**
     * Checks whether an experimental flag has been set into the viewer's' `config` 
     * object, which happens to be the same as the extension's `options` object. 
     * @private
     */
    avp.isExperimentalFlagEnabled = function(flagName, config3d) {
        if (!config3d || !Array.isArray(config3d.experimental))
            return false;
        return config3d.experimental.indexOf(flagName) !== -1;
    };


    /**
     * Helper class for initializing the viewer runtime.
     *
     * Includes:
     *  - End points of cloud services the viewer uses, like viewing service and search service.
     *  - Authentication and authorization cookie settings on the client side.
     *  - Misc runtime environment variables and viewer configurations parameters.
     *
     * @constructor
     * @param {object} options - The options object contains configuration parameters used to do initializations. If no
     * access token or authentication callback is provided, the Initializer will fall back
     * on an access token provided in the URL query string, or a previous access token stored in
     * the cookie cache, if available. The static function Autodesk.Viewing.createInitializerOptions() can be used to create
     * an object with all the supported attributes.
     * @param {string} [options.env] - Can be "Development", "Staging" or "Production", for viewers running without PAAS
     * endpoints. Can be "AutodeskDevelopment", "AutodeskStaging", or "AutodeskProduction"
     * for viewers running with PAAS endpoints.
     * @param {function} [options.getAccessToken] - An function that provides an access token asynchronously.
     * The function signature is `getAccessToken(onSuccess)`, where onSuccess is a callback that getAccessToken
     * function should invoke when a token is granted, with the token being the first input parameter for the
     * onSuccess function, and the token expire time (in seconds) being the second input parameter for the
     * function. Viewer relies on both getAccessToken and the expire time to automatically renew token, so
     * it is critical that getAccessToken must be implemented as described here.
     * @param {boolean} [options.useADP] - Whether to report analytics to ADP. True by default.
     * @param {string} [options.accessToken] - An access token.
     * @param {string} [options.webGLHelpLink] - A link to a help page on webGL if it's disabled.
     * @param {string} [options.language] - Preferred language code as defined in RFC 4646, such as "en", "de", "fr", etc.
     * If no language is set, viewer will pick it up from the browser. If language is not as defined in RFC,
     * viewer will fall back to "en" but the behavior is undefined.
     * @param {function} callback - A method the client executes when initialization is finished.
     * @example
     *  var options = {
     *     env: "AutodeskProduction",
     *     language: "en",
     *     webGLHelpLink: "http://my.webgl.help.link",
     *     getAccessToken: function(onSuccess) {
     *         var accessToken, expire;
     *         // Code to retrieve and assign token value to
     *         // accessToken and expire time in seconds.
     *         onSuccess(accessToken, expire);
     *     }
     *  };
     *  var callback = function() {
     *     alert("initialization complete");
     *  };
     *  Autodesk.Viewing.Initializer(options, callback);
     * @category Core
     */
    Autodesk.Viewing.Initializer = function (options, callback) {

        function init() {
            avp.initializeLegacyNamespaces(false);

            //Kick off a request for the web worker script, so it loads in parallel with three.js
            avp.initWorkerScript();

            //Temporarily silence THREE.warn due to new builds of Chrome producing oodles of shader compile warnings.
            THREE.warn = avp.logger.warn.bind(avp.logger);

            avp.initializeAuth(callback, options);
            avp.initializeLocalization(options);
            avp.initializeUserInfo(options);
        }


        if (av.isNodeJS) {

            avp.initializeEnvironmentVariable(options);
            avp.initializeServiceEndPoints(options);
            avp.initializeLogger(options);
            //avp.initializeProtein(); //TODO:NODE

            //init_three_dds_loader(); //TODO:NODE
            //init_three_pvr_loader(); //TODO:NODE
            avp.initializeAuth(callback, options);

        } else {

            avp.WEBGL_HELP_LINK = options ? options.webGLHelpLink : null;
            avp.initializeEnvironmentVariable(options);
            avp.initializeServiceEndPoints(options);
            avp.initializeLogger(options);
            // There were plans to have a common materials endpoint where shared textures are hosted.
            // However, decals (for example) or other user-assigned textures will not be found there.
            // So, we must comment this out, see https://jira.autodesk.com/browse/LMV-2726
            //avp.initializeProtein();
            avp.disableDocumentTouchSafari();

            //Load Promise (IE11), three.js & wgs.js, then continue initialization
            avp.loadDependency('Promise', 'es6-promise.min.js', function() { // Usually a no-op
                avp.loadDependency('THREE', 'three.min.js', function() {
                    avp.loadDependency('WGS', 'wgs.js', init);
                });
            }, null, 'es6-promise-polyfill');
        }
    };

})();

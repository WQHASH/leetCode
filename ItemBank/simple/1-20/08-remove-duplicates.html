<script>
	// 给定一个排序数组，你需要在原地删除重复出现的元素，
	// 使得每个元素只出现一次，返回移除后数组的新长度。
	// **不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

	/**
	 * @param {number[]} nums
	 * @return {number}
	 */
	(function(){
		var removeDuplicates = function(nums) {
			var obj = {};
			var arr =[];
			for(var i=0,len=nums.length;i<len;i++){
				obj[nums[i]] = i;
			}
			for(var key in obj){
				arr.push(key);
			}
			return arr.length;
		};
		var nums = [0,0,11,22,11,22,4,5];
		console.log(removeDuplicates(nums));
	})();

	(function(){
		var removeDuplicates = function(nums) {
			return Array.from(new Set(nums)).length
		
		};
		var nums = [0,0,11,22,11,22,4,5];
		console.log(removeDuplicates(nums));

	})();

	//这里只是比较左右相邻的两元素，不是整个的去重  [leetCode也是如此]

	(function(){
		var removeDuplicates = function(nums) {
			var ans = 0;
			for(var i=nums.length;i--;){
				if(i===nums.length-1){
					ans++;
				}else if(nums[i] === nums[i+1]){
					nums.splice(i,1);
				}else{
					ans++;
				}
			}
			console.log(nums,"ans")  // [0, 22, 11, 22, 4, 5]
			return ans;
		};
		var nums = [0,0,0,22,11,22,4,5];
		console.log(removeDuplicates(nums));	//6

	})();

	//更合理的写法不用新空间来存储数组相关数据
	(function(){
		var removeDuplicates = function(nums) {
			var repeatIndex = 1;
		    for(var i = 1; i < nums.length; i++){
		        if(nums[i - 1] != nums[i]){
		            nums[repeatIndex] = nums[i]
		            repeatIndex++;
		        }
		    }
		    console.log(nums,repeatIndex,"nums") // [0, 22, 11, 22, 4, 5, 4, 5] 6
		    //用于区分nums1数据的处理
		    return nums.length = nums.length < repeatIndex ? nums.length : repeatIndex;
		};
		var nums = [0,0,0,22,11,22,4,5];
		// var nums1 = [0,0,0,0,0,0,0];
		console.log(removeDuplicates(nums));	// 6

	})();
</script>